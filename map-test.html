<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Walkable Areas Grid Test</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        h1 {
            margin-bottom: 24px;
            color: #1f2937;
        }

        .controls {
            display: flex;
            gap: 16px;
            margin-bottom: 24px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        label {
            font-size: 14px;
            font-weight: 500;
            color: #374151;
        }

        input, select, button {
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
        }

        button {
            background: #4f46e5;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s;
        }

        button:hover {
            background: #4338ca;
        }

        .map-container {
            position: relative;
            width: 100%;
            height: 600px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            overflow: hidden;
            background: #f9fafb;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 1000;
        }

        .grid-cell {
            position: absolute;
            border: 2px solid rgba(79, 70, 229, 0.4);
            background: rgba(79, 70, 229, 0.15);
            transition: all 0.2s;
            cursor: pointer;
            pointer-events: auto;
        }

        .grid-cell.walkable {
            background: rgba(34, 197, 94, 0.6);
            border: 2px solid rgba(22, 163, 74, 0.9);
        }

        .grid-cell.non-walkable {
            background: rgba(239, 68, 68, 0.6);
            border: 2px solid rgba(220, 38, 38, 0.9);
        }

        .grid-cell.restricted {
            background: rgba(168, 85, 247, 0.6);
            border: 2px solid rgba(147, 51, 234, 0.9);
        }

        .grid-cell.unknown {
            background: rgba(156, 163, 175, 0.4);
            border: 2px solid rgba(107, 114, 128, 0.7);
        }

        .grid-cell:hover {
            opacity: 0.8;
            transform: scale(1.02);
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-top: 16px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.2);
        }

        .info-panel {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
            margin-top: 20px;
        }

        .info-panel h3 {
            margin-bottom: 8px;
            color: #1e293b;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 16px;
            margin-top: 12px;
        }

        .stat {
            text-align: center;
            padding: 12px;
            background: white;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #1e293b;
        }

        .stat-label {
            font-size: 12px;
            color: #64748b;
            margin-top: 4px;
        }

        .instructions {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 24px;
        }

        .instructions h3 {
            color: #92400e;
            margin-bottom: 8px;
        }

        .instructions ul {
            color: #92400e;
            margin-left: 20px;
        }

        .instructions li {
            margin-bottom: 4px;
        }

        .keyboard-shortcuts {
            background: #eff6ff;
            border: 1px solid #3b82f6;
            border-radius: 8px;
            padding: 12px;
            margin-top: 16px;
            font-size: 12px;
        }

        .keyboard-shortcuts strong {
            color: #1e40af;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .map-container {
                height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üó∫Ô∏è Walkable Areas Grid Test</h1>
        
        <div class="instructions">
            <h3>üìã How to Use This Test</h3>
            <ul>
                <li>Enter your coordinates or click "üìç Use My Location"</li>
                <li>Click "üó∫Ô∏è Load Map" to visualize your area</li>
                <li>Click "‚¨ú Generate Grid" to create the test grid</li>
                <li>Click grid cells to cycle through: Unknown ‚Üí Walkable ‚Üí Non-walkable</li>
                <li>Observe how coverage percentage changes as you classify areas</li>
            </ul>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="latitude">Your Latitude:</label>
                <input type="number" id="latitude" step="0.000001" placeholder="e.g., 40.7128" />
            </div>
            
            <div class="control-group">
                <label for="longitude">Your Longitude:</label>
                <input type="number" id="longitude" step="0.000001" placeholder="e.g., -74.0060" />
            </div>
            
            <div class="control-group">
                <label for="grid-size">Grid Size:</label>
                <select id="grid-size">
                    <option value="15">15x15</option>
                    <option value="20">20x20</option>
                    <option value="25" selected>25x25</option>
                    <option value="30">30x30</option>
                    <option value="40">40x40</option>
                    <option value="50">50x50</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="radius">Radius (meters):</label>
                <input type="number" id="radius" value="500" min="100" max="2000" step="50" />
            </div>
            
            <button onclick="getCurrentLocation()">üìç Use My Location</button>
            <button onclick="showLocationHelp()">‚ùì Need Coordinates?</button>
            <button onclick="loadMap()">üó∫Ô∏è Load Map</button>
            <button onclick="generateGrid()">‚¨ú Generate Grid</button>
            <button onclick="autoDetectWalkable()" id="autoDetectBtn">ü§ñ Auto-Detect Walkable Areas</button>
            <button onclick="showRestrictedAreas()" id="restrictedBtn">üö´ Show Restricted Areas</button>
            <button onclick="debugOSMData()" id="debugBtn">üîç Debug OSM Data</button>
            <button onclick="toggleRawDataOverlay()" id="rawDataBtn">üìä Show Raw OSM Data</button>
            <button onclick="toggleEnhancedDetection()" id="enhancedBtn">üéØ Enhanced Detection</button>
            <button onclick="debugSpecificCell()" id="debugCellBtn">üî¨ Debug Cell Intersection</button>
            <button onclick="clearGrid()">üßπ Clear Grid</button>
        </div>

        <div class="map-container">
            <div id="map">
                <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #6b7280; font-size: 18px; text-align: center; flex-direction: column; gap: 16px;">
                    <div style="font-size: 48px;">üìç</div>
                    <div>Enter coordinates and click "Load Map" to begin</div>
                    <div style="font-size: 14px; color: #9ca3af;">This simulates how your dog walking app would analyze walkable areas</div>
                </div>
            </div>
            <div class="grid-overlay" id="grid-overlay"></div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(34, 197, 94, 0.3); border-color: rgba(34, 197, 94, 0.6);"></div>
                <span>Walkable (roads, sidewalks, parks)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(239, 68, 68, 0.3); border-color: rgba(239, 68, 68, 0.6);"></div>
                <span>Non-walkable (private property, buildings)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(156, 163, 175, 0.2); border-color: rgba(156, 163, 175, 0.4);"></div>
                <span>Unknown/Unclassified</span>
            </div>
        </div>

        <div class="info-panel">
            <h3>üìä Grid Analysis</h3>
            <p>Click on grid cells to classify areas. This simulates how the app would analyze walkable vs non-walkable areas in your residential neighborhood.</p>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(34, 197, 94, 0.6); border: 2px solid rgba(22, 163, 74, 0.9);"></div>
                    <span>Walkable Areas</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(239, 68, 68, 0.6); border: 2px solid rgba(220, 38, 38, 0.9);"></div>
                    <span>Non-walkable Areas</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(168, 85, 247, 0.6); border: 2px solid rgba(147, 51, 234, 0.9);"></div>
                    <span>Restricted Areas</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(156, 163, 175, 0.4); border: 2px solid rgba(107, 114, 128, 0.7);"></div>
                    <span>Unknown Areas</span>
                </div>
            </div>

            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="walkable-count">0</div>
                    <div class="stat-label">Walkable Cells</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="non-walkable-count">0</div>
                    <div class="stat-label">Non-walkable Cells</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="restricted-count">0</div>
                    <div class="stat-label">Restricted Cells</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="unknown-count">0</div>
                    <div class="stat-label">Unknown Cells</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="coverage-percent">0%</div>
                    <div class="stat-label">Area Coverage</div>
                </div>
            </div>

            <div class="keyboard-shortcuts">
                <strong>Keyboard Shortcuts:</strong> Press <strong>1</strong> then click = Walkable | <strong>2</strong> then click = Non-walkable | <strong>3</strong> then click = Unknown | <strong>C</strong> = Clear grid | <strong>G</strong> = Generate grid | <strong>R</strong> = Toggle raw OSM data | <strong>E</strong> = Enhanced detection
            </div>
        </div>
    </div>

    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        let map = null;
        let gridCells = [];
        let currentState = 'walkable'; // Current classification mode

        // Sample coordinates (New York City) - user will replace with their location
        const defaultCoords = { lat: 40.7128, lng: -74.0060 };

        function getCurrentLocation() {
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = 'üì° Getting location...';
            button.disabled = true;

            console.log('Attempting to get location...');

            if (!navigator.geolocation) {
                alert('Geolocation is not supported by this browser.');
                button.textContent = originalText;
                button.disabled = false;
                return;
            }

            // Check if page is served over HTTPS or localhost
            const isSecure = location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
            if (!isSecure) {
                alert('Geolocation requires HTTPS or localhost. Please enter coordinates manually or serve the page over HTTPS.');
                button.textContent = originalText;
                button.disabled = false;
                return;
            }

            const options = {
                enableHighAccuracy: true,
                timeout: 10000, // 10 seconds
                maximumAge: 60000 // 1 minute
            };

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    console.log('Location success:', position);
                    document.getElementById('latitude').value = position.coords.latitude.toFixed(6);
                    document.getElementById('longitude').value = position.coords.longitude.toFixed(6);
                    button.textContent = '‚úÖ Location found!';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.disabled = false;
                    }, 2000);
                    console.log(`Location obtained: ${position.coords.latitude}, ${position.coords.longitude}`);
                },
                (error) => {
                    console.error('Geolocation error:', error);
                    let errorMessage = 'Could not get your location. ';
                    
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                            errorMessage += 'Permission denied. Please allow location access and try again.';
                            break;
                        case error.POSITION_UNAVAILABLE:
                            errorMessage += 'Location information unavailable.';
                            break;
                        case error.TIMEOUT:
                            errorMessage += 'Location request timed out.';
                            break;
                        default:
                            errorMessage += 'An unknown error occurred.';
                            break;
                    }
                    
                    errorMessage += '\n\nPlease enter coordinates manually or try again.';
                    alert(errorMessage);
                    
                    button.textContent = '‚ùå Location failed';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.disabled = false;
                    }, 3000);
                },
                options
            );
        }

        function showLocationHelp() {
            const helpMessage = `üìç How to get your coordinates:

Method 1: Google Maps
‚Ä¢ Open maps.google.com
‚Ä¢ Right-click on your location
‚Ä¢ Click the coordinates that appear
‚Ä¢ Copy them here

Method 2: GPS Coordinates app
‚Ä¢ Search "GPS coordinates" in your app store
‚Ä¢ Use any GPS app on your phone

Method 3: Manual entry
‚Ä¢ If you know your approximate address, search online for "[your address] coordinates"

The format should be:
Latitude: Like 40.7128 (North/South)
Longitude: Like -74.0060 (East/West)`;

            alert(helpMessage);
        }

        function loadMap() {
            const lat = parseFloat(document.getElementById('latitude').value);
            const lng = parseFloat(document.getElementById('longitude').value);

            if (isNaN(lat) || isNaN(lng)) {
                alert('Please enter valid coordinates.');
                return;
            }

            // Validate coordinates are reasonable
            if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                alert('Please enter valid coordinates (latitude: -90 to 90, longitude: -180 to 180).');
                return;
            }

            // Clear the map div and create a new map
            const mapDiv = document.getElementById('map');
            mapDiv.innerHTML = '';
            
            // Destroy existing map if it exists
            if (map !== null) {
                map.remove();
                map = null;
            }

            // Create new Leaflet map
            map = L.map('map').setView([lat, lng], 16);

            // Add OpenStreetMap tiles
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            // Add a marker at the center location
            L.marker([lat, lng])
                .addTo(map)
                .bindPopup(`üìç Your Location<br>${lat.toFixed(4)}, ${lng.toFixed(4)}`)
                .openPopup();

            // Add a circle to show the radius
            const radius = parseInt(document.getElementById('radius').value);
            L.circle([lat, lng], {
                color: '#4f46e5',
                fillColor: '#4f46e5',
                fillOpacity: 0.1,
                radius: radius
            }).addTo(map).bindPopup(`Search radius: ${radius}m`);

            console.log(`Real map loaded for coordinates: ${lat}, ${lng} with ${radius}m radius`);
        }

        function generateGrid() {
            const gridSize = parseInt(document.getElementById('grid-size').value);
            const radius = parseInt(document.getElementById('radius').value);
            const gridOverlay = document.getElementById('grid-overlay');
            
            // Clear existing grid
            gridOverlay.innerHTML = '';
            gridCells = [];

            if (!map) {
                alert('Please load the map first!');
                return;
            }

            // Get the actual map container dimensions
            const mapContainer = map.getContainer();
            const containerWidth = mapContainer.clientWidth;
            const containerHeight = mapContainer.clientHeight;
            
            // Use the smaller dimension to ensure square cells that fit in the view
            const smallerDimension = Math.min(containerWidth, containerHeight);
            const cellPixelSize = smallerDimension / gridSize;
            
            // Calculate offsets to center the grid
            const leftOffset = (containerWidth - smallerDimension) / 2;
            const topOffset = (containerHeight - smallerDimension) / 2;

            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell unknown';
                    
                    // Position cells as perfect squares using pixel dimensions
                    cell.style.left = `${leftOffset + (col * cellPixelSize)}px`;
                    cell.style.top = `${topOffset + (row * cellPixelSize)}px`;
                    cell.style.width = `${cellPixelSize}px`;
                    cell.style.height = `${cellPixelSize}px`;
                    
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.dataset.state = 'unknown';
                    
                    // Add tooltip
                    cell.title = `Cell ${row},${col} - Click to classify`;
                    
                    cell.addEventListener('click', () => toggleCellState(cell));
                    
                    gridOverlay.appendChild(cell);
                    gridCells.push(cell);
                }
            }

            updateStats();
            console.log(`Generated ${gridSize}x${gridSize} SQUARE grid (${gridCells.length} cells, ${cellPixelSize.toFixed(1)}px each)`);
            
            // Show success message
            const originalText = event.target.textContent;
            event.target.textContent = `‚úÖ ${gridCells.length} square cells created!`;
            setTimeout(() => {
                event.target.textContent = originalText;
            }, 2000);
        }

        function toggleCellState(cell) {
            const currentState = cell.dataset.state;
            let newState;
            
            // Cycle through states: unknown -> walkable -> non-walkable -> restricted -> unknown
            switch (currentState) {
                case 'unknown':
                    newState = 'walkable';
                    break;
                case 'walkable':
                    newState = 'non-walkable';
                    break;
                case 'non-walkable':
                    newState = 'restricted';
                    break;
                case 'restricted':
                    newState = 'unknown';
                    break;
                default:
                    newState = 'unknown';
            }
            
            cell.dataset.state = newState;
            cell.className = `grid-cell ${newState}`;
            cell.title = `Cell ${cell.dataset.row},${cell.dataset.col} - ${newState.replace('-', ' ')}`;
            
            updateStats();

            // Visual feedback
            cell.style.transform = 'scale(1.1)';
            setTimeout(() => {
                cell.style.transform = '';
            }, 150);
        }

        function updateStats() {
            const walkable = gridCells.filter(cell => cell.dataset.state === 'walkable').length;
            const nonWalkable = gridCells.filter(cell => cell.dataset.state === 'non-walkable').length;
            const restricted = gridCells.filter(cell => cell.dataset.state === 'restricted').length;
            const unknown = gridCells.filter(cell => cell.dataset.state === 'unknown').length;
            const total = gridCells.length;
            
            const classified = walkable + nonWalkable + restricted;
            const coveragePercent = total > 0 ? Math.round((classified / total) * 100) : 0;
            
            document.getElementById('walkable-count').textContent = walkable;
            document.getElementById('non-walkable-count').textContent = nonWalkable;
            document.getElementById('restricted-count').textContent = restricted;
            document.getElementById('unknown-count').textContent = unknown;
            document.getElementById('coverage-percent').textContent = `${coveragePercent}%`;
        }

        function clearGrid() {
            if (gridCells.length === 0) {
                alert('No grid to clear. Generate a grid first!');
                return;
            }

            gridCells.forEach(cell => {
                cell.dataset.state = 'unknown';
                cell.className = 'grid-cell unknown';
                cell.title = `Cell ${cell.dataset.row},${cell.dataset.col} - Click to classify`;
            });
            updateStats();
            
            // Visual feedback
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = '‚úÖ Grid cleared!';
            setTimeout(() => {
                button.textContent = originalText;
            }, 1500);
        }

        // Auto-detect walkable areas using OpenStreetMap data
        async function autoDetectWalkable() {
            if (!map) {
                alert('Please load the map first!');
                return;
            }

            if (gridCells.length === 0) {
                alert('Please generate a grid first!');
                return;
            }

            const button = document.getElementById('autoDetectBtn');
            const originalText = button.textContent;
            button.textContent = 'üîç Analyzing area...';
            button.disabled = true;

            try {
                const center = map.getCenter();
                const radius = parseInt(document.getElementById('radius').value);
                
                console.log(`Querying walkable areas around ${center.lat}, ${center.lng} within ${radius}m`);
                
                // Query both walkable AND restricted areas
                const [walkableData, restrictedData] = await Promise.all([
                    queryWalkableAreas(center.lat, center.lng, radius),
                    queryRestrictedAreas(center.lat, center.lng, radius)
                ]);
                
                // Combine the data
                const combinedData = {
                    elements: [
                        ...(walkableData?.elements || []),
                        ...(restrictedData?.elements || [])
                    ]
                };
                
                // Apply the data to existing grid
                if (combinedData.elements.length > 0) {
                    classifyGridWithOSMData(combinedData);
                    button.textContent = '‚úÖ Detection complete!';
                } else {
                    button.textContent = '‚ùå No data found';
                }
                
            } catch (error) {
                console.error('Auto-detection error:', error);
                button.textContent = '‚ùå Detection failed';
            }
            
            setTimeout(() => {
                button.textContent = originalText;
                button.disabled = false;
            }, 3000);
        }

        // Query OpenStreetMap Overpass API for walkable areas
        async function queryWalkableAreas(lat, lng, radius) {
            const overpassUrl = 'https://overpass-api.de/api/interpreter';
            
            // Enhanced Overpass query for walkable areas with access restrictions
            const query = `
                [out:json][timeout:25];
                (
                  // Roads and highways (walkable, not private)
                  way["highway"~"^(primary|secondary|tertiary|residential|unclassified|service|footway|path|pedestrian|cycleway)$"]["access"!="private"]["access"!="no"](around:${radius},${lat},${lng});
                  
                  // Sidewalks specifically  
                  way["footway"="sidewalk"]["access"!="private"](around:${radius},${lat},${lng});
                  
                  // Parks and recreational areas (exclude fee-based and private)
                  way["leisure"~"^(park|playground|recreation_ground|garden)$"]["access"!="private"]["fee"!="yes"](around:${radius},${lat},${lng});
                  rel["leisure"~"^(park|playground|recreation_ground|garden)$"]["access"!="private"]["fee"!="yes"](around:${radius},${lat},${lng});
                  
                  // Public paths and trails (explicitly exclude private)
                  way["highway"="track"]["access"!="private"]["access"!="no"](around:${radius},${lat},${lng});
                );
                out geom;
            `;

            try {
                const response = await fetch(overpassUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: 'data=' + encodeURIComponent(query)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('OSM Data received:', data.elements?.length || 0, 'elements');
                return data;
                
            } catch (error) {
                console.error('Error querying OpenStreetMap:', error);
                return null;
            }
        }

        // Classify grid cells based on OSM data
        function classifyGridWithOSMData(osmData) {
            if (!osmData || !osmData.elements) {
                console.error('No OSM data to process');
                return;
            }

            const bounds = map.getBounds();
            const gridSize = parseInt(document.getElementById('grid-size').value);
            
            let classifiedCount = 0;
            
            console.log(`\nüîç Classification Method: ${enhancedDetectionEnabled ? 'ENHANCED GEOMETRIC INTERSECTION' : 'CENTER-POINT + RADIUS'}`);
            
            gridCells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                
                let isWalkable, isRestricted, detectionInfo = '';
                
                if (enhancedDetectionEnabled) {
                    // ENHANCED: Use geometric intersection with grid cell boundaries
                    const cellBounds = getGridCellBounds(row, col, gridSize, bounds);
                    
                    const walkableResult = checkGridCellIntersectsWalkableAreas(cellBounds, osmData.elements);
                    const restrictedResult = checkGridCellIntersectsRestrictedAreas(cellBounds, osmData.elements);
                    
                    isWalkable = walkableResult.intersects;
                    isRestricted = restrictedResult.intersects;
                    
                    if (walkableResult.intersects) {
                        detectionInfo = ` - intersects with ${walkableResult.feature} (${walkableResult.type})`;
                    } else if (restrictedResult.intersects) {
                        detectionInfo = ` - intersects with ${restrictedResult.feature} (${restrictedResult.type})`;
                    }
                    
                } else {
                    // ORIGINAL: Use center point + radius detection
                    const latRange = bounds.getNorthEast().lat - bounds.getSouthWest().lat;
                    const lngRange = bounds.getNorthEast().lng - bounds.getSouthWest().lng;
                    
                    const cellLat = bounds.getSouthWest().lat + (latRange * (1 - (row + 0.5) / gridSize));
                    const cellLng = bounds.getSouthWest().lng + (lngRange * (col + 0.5) / gridSize);
                    
                    isWalkable = checkPointInWalkableAreas(cellLat, cellLng, osmData.elements);
                    isRestricted = checkPointInRestrictedAreas(cellLat, cellLng, osmData.elements);
                    
                    detectionInfo = ` - center point at ${cellLat.toFixed(6)}, ${cellLng.toFixed(6)}`;
                }
                
                // PRIORITY: Walkable areas take precedence over restricted areas
                // If there's any public walkable access, the cell is considered walkable
                if (isWalkable) {
                    cell.dataset.state = 'walkable';
                    cell.className = 'grid-cell walkable';
                    cell.title = `Cell ${row},${col} - walkable (${enhancedDetectionEnabled ? 'geometric' : 'radius'} detection)${detectionInfo}`;
                    classifiedCount++;
                    console.log(`Cell ${row},${col} marked as WALKABLE${detectionInfo}`);
                } else if (isRestricted) {
                    cell.dataset.state = 'restricted';
                    cell.className = 'grid-cell restricted';
                    cell.title = `Cell ${row},${col} - restricted (${enhancedDetectionEnabled ? 'geometric' : 'radius'} detection)${detectionInfo}`;
                    classifiedCount++;
                    console.log(`Cell ${row},${col} marked as RESTRICTED${detectionInfo}`);
                } else {
                    cell.dataset.state = 'non-walkable';
                    cell.className = 'grid-cell non-walkable';
                    cell.title = `Cell ${row},${col} - non-walkable (${enhancedDetectionEnabled ? 'geometric' : 'radius'} detection)`;
                }
            });
            
            console.log(`\nüìä Auto-classified ${classifiedCount} cells as walkable/restricted out of ${gridCells.length} total using ${enhancedDetectionEnabled ? 'GEOMETRIC' : 'CENTER-POINT'} detection`);
            updateStats();
        }

        // Check if a point is within any walkable areas
        function checkPointInWalkableAreas(pointLat, pointLng, osmElements) {
            for (const element of osmElements) {
                if (element.type === 'way' && element.geometry) {
                    // Only check walkable elements (not restricted ones)
                    const tags = element.tags || {};
                    const isRestrictedElement = tags.fee === 'yes' || tags.access === 'private' || 
                                              tags.access === 'no' || tags.access === 'customers' ||
                                              tags.landuse === 'military' || tags.dog === 'no';
                    
                    if (!isRestrictedElement) {
                        // Check proximity to walkable infrastructure
                        for (const node of element.geometry) {
                            const distance = calculateDistance(pointLat, pointLng, node.lat, node.lon);
                            
                            // Different detection radii based on infrastructure type
                            let detectionRadius = 30; // Default 30m
                            
                            if (tags.highway === 'footway' || tags.highway === 'pedestrian') {
                                detectionRadius = 20; // Footways and pedestrian areas
                            } else if (tags.highway === 'residential' || tags.highway === 'service') {
                                detectionRadius = 50; // Residential streets (likely have sidewalks)
                            } else if (tags.highway && tags.highway.match(/^(primary|secondary|tertiary)$/)) {
                                detectionRadius = 60; // Major roads (wider with sidewalks)
                            } else if (tags.leisure === 'park') {
                                detectionRadius = 40; // Parks
                            }
                            
                            if (distance < detectionRadius) {
                                console.log(`Found walkable: ${tags.name || tags.highway || 'unnamed'} at ${distance.toFixed(1)}m (radius: ${detectionRadius}m)`);
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        // Check if a point is within any restricted areas
        function checkPointInRestrictedAreas(pointLat, pointLng, osmElements) {
            for (const element of osmElements) {
                if (element.type === 'way' && element.geometry) {
                    // Enhanced restricted element detection
                    const tags = element.tags || {};
                    const isRestrictedElement = 
                        tags.fee === 'yes' || 
                        tags.access === 'private' || 
                        tags.access === 'no' || 
                        tags.access === 'customers' ||
                        tags.landuse === 'military' || 
                        tags.dog === 'no' ||
                        // Additional fee-based attraction tags
                        tags.admission ||
                        (tags.leisure === 'garden' && tags.tourism) || // Botanical gardens that are tourist attractions
                        (tags.tourism === 'attraction' && tags.leisure === 'garden') ||
                        (tags.name && tags.name.toLowerCase().includes('botanical')) ||
                        (tags.name && tags.name.toLowerCase().includes('vandusen')) ||
                        // Common patterns for fee-based venues
                        (tags.tourism === 'zoo') ||
                        (tags.tourism === 'museum') ||
                        (tags.tourism === 'theme_park');
                    
                    if (isRestrictedElement) {
                        console.log(`Found restricted element: ${tags.name || 'Unnamed'} with tags:`, tags);
                        // Check proximity to restricted areas
                        for (const node of element.geometry) {
                            const distance = calculateDistance(pointLat, pointLng, node.lat, node.lon);
                            // If within 15 meters of a restricted area, consider it restricted
                            if (distance < 15) {
                                console.log(`Point ${pointLat.toFixed(6)}, ${pointLng.toFixed(6)} is ${distance.toFixed(1)}m from restricted area: ${tags.name || 'Unnamed'}`);
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        // Show restricted areas that are excluded from walkable detection
        async function showRestrictedAreas() {
            if (!map) {
                alert('Please load the map first!');
                return;
            }

            const button = document.getElementById('restrictedBtn');
            const originalText = button.textContent;
            button.textContent = 'üîç Finding restrictions...';
            button.disabled = true;

            try {
                const center = map.getCenter();
                const radius = parseInt(document.getElementById('radius').value);
                
                // Query for restricted areas
                const restrictedData = await queryRestrictedAreas(center.lat, center.lng, radius);
                
                if (restrictedData && restrictedData.elements && restrictedData.elements.length > 0) {
                    displayRestrictedAreasInfo(restrictedData.elements);
                    button.textContent = '‚úÖ Restrictions found!';
                } else {
                    alert('No specifically tagged restricted areas found in this area.\n\nThis could mean:\n‚Ä¢ Area has good public access\n‚Ä¢ OSM data may not have detailed access tags\n‚Ä¢ Your pay-to-enter garden might not be tagged with fee=yes');
                    button.textContent = 'ü§∑ No restrictions found';
                }
                
            } catch (error) {
                console.error('Error finding restricted areas:', error);
                button.textContent = '‚ùå Query failed';
            }
            
            setTimeout(() => {
                button.textContent = originalText;
                button.disabled = false;
            }, 3000);
        }

        // Query OpenStreetMap for restricted/fee-based areas
        async function queryRestrictedAreas(lat, lng, radius) {
            const overpassUrl = 'https://overpass-api.de/api/interpreter';
            
            const query = `
                [out:json][timeout:25];
                (
                  // Fee-based areas (like your pay-to-enter garden)
                  way["fee"="yes"](around:${radius},${lat},${lng});
                  rel["fee"="yes"](around:${radius},${lat},${lng});
                  
                  // Private access areas
                  way["access"="private"](around:${radius},${lat},${lng});
                  way["access"="no"](around:${radius},${lat},${lng});
                  
                  // Customer-only areas
                  way["access"="customers"](around:${radius},${lat},${lng});
                  rel["access"="customers"](around:${radius},${lat},${lng});
                  
                  // Military or restricted areas
                  way["landuse"="military"](around:${radius},${lat},${lng});
                  
                  // Dog-restricted areas
                  way["dog"="no"](around:${radius},${lat},${lng});
                );
                out geom;
            `;

            try {
                const response = await fetch(overpassUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: 'data=' + encodeURIComponent(query)
                });

                const data = await response.json();
                console.log('Restricted areas data:', data.elements?.length || 0, 'elements');
                return data;
                
            } catch (error) {
                console.error('Error querying restricted areas:', error);
                return null;
            }
        }

        // Display information about restricted areas found
        function displayRestrictedAreasInfo(restrictedElements) {
            let restrictionTypes = {};
            
            restrictedElements.forEach(element => {
                const tags = element.tags || {};
                
                if (tags.fee === 'yes') {
                    restrictionTypes['Fee-based (pay-to-enter)'] = (restrictionTypes['Fee-based (pay-to-enter)'] || 0) + 1;
                }
                if (tags.access === 'private') {
                    restrictionTypes['Private access'] = (restrictionTypes['Private access'] || 0) + 1;
                }
                if (tags.access === 'no') {
                    restrictionTypes['No access'] = (restrictionTypes['No access'] || 0) + 1;
                }
                if (tags.access === 'customers') {
                    restrictionTypes['Customers only'] = (restrictionTypes['Customers only'] || 0) + 1;
                }
                if (tags.landuse === 'military') {
                    restrictionTypes['Military/restricted'] = (restrictionTypes['Military/restricted'] || 0) + 1;
                }
                if (tags.dog === 'no') {
                    restrictionTypes['No dogs allowed'] = (restrictionTypes['No dogs allowed'] || 0) + 1;
                }
            });
            
            let message = `üö´ Found ${restrictedElements.length} restricted areas:\n\n`;
            
            for (const [type, count] of Object.entries(restrictionTypes)) {
                message += `‚Ä¢ ${type}: ${count}\n`;
            }
            
            message += `\nüí° These areas are excluded from walkable detection because they have access restrictions that matter for everyday dog walking.`;
            
            alert(message);
        }

        // Debug function to show all OSM data in the area
        async function debugOSMData() {
            if (!map) {
                alert('Please load the map first!');
                return;
            }

            const button = document.getElementById('debugBtn');
            const originalText = button.textContent;
            button.textContent = 'üîç Gathering data...';
            button.disabled = true;

            try {
                const center = map.getCenter();
                const radius = parseInt(document.getElementById('radius').value);
                
                // Query for ALL relevant areas (walkable AND restricted)
                const [walkableData, restrictedData] = await Promise.all([
                    queryWalkableAreas(center.lat, center.lng, radius),
                    queryRestrictedAreas(center.lat, center.lng, radius)
                ]);
                
                // Also query specifically for botanical gardens, museums, etc.
                const specialData = await querySpecialAreas(center.lat, center.lng, radius);
                
                // Combine and analyze
                const allElements = [
                    ...(walkableData?.elements || []),
                    ...(restrictedData?.elements || []),
                    ...(specialData?.elements || [])
                ];
                
                displayOSMDebugInfo(allElements);
                button.textContent = '‚úÖ Data analyzed!';
                
            } catch (error) {
                console.error('Debug error:', error);
                button.textContent = '‚ùå Debug failed';
            }
            
            setTimeout(() => {
                button.textContent = originalText;
                button.disabled = false;
            }, 3000);
        }

        // Query for special fee-based areas that might use different tags
        async function querySpecialAreas(lat, lng, radius) {
            const overpassUrl = 'https://overpass-api.de/api/interpreter';
            
            const query = `
                [out:json][timeout:25];
                (
                  // Botanical gardens, museums, attractions
                  way["leisure"="garden"](around:${radius},${lat},${lng});
                  way["tourism"~"^(attraction|museum|zoo|theme_park)$"](around:${radius},${lat},${lng});
                  rel["leisure"="garden"](around:${radius},${lat},${lng});
                  rel["tourism"~"^(attraction|museum|zoo|theme_park)$"](around:${radius},${lat},${lng});
                  
                  // Anything with admission fees using different tags
                  way["admission"](around:${radius},${lat},${lng});
                  rel["admission"](around:${radius},${lat},${lng});
                  
                  // Places with opening hours (often indicates restricted access)
                  way["opening_hours"](around:${radius},${lat},${lng});
                  rel["opening_hours"](around:${radius},${lat},${lng});
                );
                out geom;
            `;

            try {
                const response = await fetch(overpassUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: 'data=' + encodeURIComponent(query)
                });

                const data = await response.json();
                console.log('Special areas data:', data.elements?.length || 0, 'elements');
                return data;
                
            } catch (error) {
                console.error('Error querying special areas:', error);
                return null;
            }
        }

        // Display detailed OSM debug information
        function displayOSMDebugInfo(elements) {
            let debugInfo = `üîç OSM Debug Report\n\n`;
            debugInfo += `Found ${elements.length} total elements in your area:\n\n`;
            
            const categorizedElements = {
                'Botanical Gardens': [],
                'Tourism/Attractions': [],
                'Parks/Recreation': [],
                'Fee-based Areas': [],
                'Access Restricted': [],
                'Roads/Walkways': [],
                'Other': []
            };
            
            elements.forEach(element => {
                const tags = element.tags || {};
                const name = tags.name || 'Unnamed';
                
                if (tags.leisure === 'garden' || (tags.name && tags.name.toLowerCase().includes('garden'))) {
                    categorizedElements['Botanical Gardens'].push({name, tags, element});
                } else if (tags.tourism) {
                    categorizedElements['Tourism/Attractions'].push({name, tags, element});
                } else if (tags.fee === 'yes' || tags.admission) {
                    categorizedElements['Fee-based Areas'].push({name, tags, element});
                } else if (tags.access === 'private' || tags.access === 'no' || tags.access === 'customers') {
                    categorizedElements['Access Restricted'].push({name, tags, element});
                } else if (tags.leisure === 'park' || tags.landuse === 'recreation_ground') {
                    categorizedElements['Parks/Recreation'].push({name, tags, element});
                } else if (tags.highway) {
                    categorizedElements['Roads/Walkways'].push({name, tags, element});
                } else {
                    categorizedElements['Other'].push({name, tags, element});
                }
            });
            
            for (const [category, items] of Object.entries(categorizedElements)) {
                if (items.length > 0) {
                    debugInfo += `üìç ${category} (${items.length}):\n`;
                    items.slice(0, 5).forEach(item => { // Show first 5 items
                        debugInfo += `  ‚Ä¢ ${item.name}\n`;
                        debugInfo += `    Tags: ${Object.entries(item.tags).map(([k,v]) => `${k}=${v}`).join(', ')}\n`;
                    });
                    if (items.length > 5) {
                        debugInfo += `  ... and ${items.length - 5} more\n`;
                    }
                    debugInfo += `\n`;
                }
            }
            
            // Specific analysis for VanDusen Gardens
            const vandusenElements = elements.filter(el => 
                el.tags?.name && el.tags.name.toLowerCase().includes('vandusen')
            );
            
            if (vandusenElements.length > 0) {
                debugInfo += `üåø VanDusen Gardens Analysis:\n`;
                vandusenElements.forEach(el => {
                    debugInfo += `  ‚Ä¢ Name: ${el.tags.name}\n`;
                    debugInfo += `  ‚Ä¢ All tags: ${JSON.stringify(el.tags, null, 2)}\n`;
                });
                debugInfo += `\n`;
            }
            
            debugInfo += `üí° If VanDusen Gardens shows as green (walkable), it means OSM data doesn't include proper restriction tags like fee=yes or access=private.`;
            
            // Show in a scrollable dialog
            const textarea = document.createElement('textarea');
            textarea.value = debugInfo;
            textarea.style.width = '80vw';
            textarea.style.height = '60vh';
            textarea.style.fontFamily = 'monospace';
            textarea.style.fontSize = '12px';
            
            const modal = document.createElement('div');
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100%';
            modal.style.height = '100%';
            modal.style.backgroundColor = 'rgba(0,0,0,0.8)';
            modal.style.display = 'flex';
            modal.style.alignItems = 'center';
            modal.style.justifyContent = 'center';
            modal.style.zIndex = '10000';
            
            const container = document.createElement('div');
            container.style.backgroundColor = 'white';
            container.style.padding = '20px';
            container.style.borderRadius = '8px';
            container.style.maxWidth = '90vw';
            container.style.maxHeight = '90vh';
            container.style.overflow = 'auto';
            
            const closeButton = document.createElement('button');
            closeButton.textContent = '‚úï Close';
            closeButton.style.marginBottom = '10px';
            closeButton.onclick = () => document.body.removeChild(modal);
            
            container.appendChild(closeButton);
            container.appendChild(textarea);
            modal.appendChild(container);
            document.body.appendChild(modal);
        }

        // Calculate distance between two points in meters using Haversine formula
        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 6371e3; // Earth's radius in meters
            const œÜ1 = lat1 * Math.PI/180;
            const œÜ2 = lat2 * Math.PI/180;
            const ŒîœÜ = (lat2-lat1) * Math.PI/180;
            const ŒîŒª = (lng2-lng1) * Math.PI/180;

            const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
                      Math.cos(œÜ1) * Math.cos(œÜ2) *
                      Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c; // Distance in meters
        }

        // Variables to store raw data overlays
        let rawDataLayers = [];
        let rawDataVisible = false;
        let enhancedDetectionEnabled = false;

        // Toggle raw OSM data overlay on the map
        async function toggleRawDataOverlay() {
            if (!map) {
                alert('Please load the map first!');
                return;
            }

            const button = document.getElementById('rawDataBtn');
            
            if (rawDataVisible) {
                // Remove existing overlays
                clearRawDataOverlays();
                button.textContent = 'üìä Show Raw OSM Data';
                rawDataVisible = false;
                return;
            }

            const originalText = button.textContent;
            button.textContent = 'üîç Loading OSM data...';
            button.disabled = true;

            try {
                const center = map.getCenter();
                const radius = parseInt(document.getElementById('radius').value);
                
                console.log('Loading raw OSM data for visualization...');
                
                // Get both walkable and restricted areas data
                const [walkableData, restrictedData, specialData] = await Promise.all([
                    queryWalkableAreas(center.lat, center.lng, radius),
                    queryRestrictedAreas(center.lat, center.lng, radius),
                    querySpecialAreas(center.lat, center.lng, radius)
                ]);
                
                // Create overlays for different types of data
                if (walkableData?.elements) {
                    createDataOverlay(walkableData.elements, 'walkable', '#22c55e', 'Walkable areas from OSM');
                }
                
                if (restrictedData?.elements) {
                    createDataOverlay(restrictedData.elements, 'restricted', '#ef4444', 'Restricted areas from OSM');
                }
                
                if (specialData?.elements) {
                    createDataOverlay(specialData.elements, 'special', '#a855f7', 'Special areas (gardens, tourism)');
                }
                
                button.textContent = '‚úÖ Raw data visible';
                rawDataVisible = true;
                
                // Add legend for raw data
                showRawDataLegend();
                
            } catch (error) {
                console.error('Error loading raw data:', error);
                button.textContent = '‚ùå Failed to load';
            }
            
            setTimeout(() => {
                if (rawDataVisible) {
                    button.textContent = 'üóëÔ∏è Hide Raw OSM Data';
                }
                button.disabled = false;
            }, 2000);
        }

        // Create overlay for specific data type
        function createDataOverlay(elements, type, color, description) {
            const layerGroup = L.layerGroup();
            let addedFeatures = 0;
            
            elements.forEach((element, index) => {
                if (element.type === 'way' && element.geometry) {
                    const coordinates = element.geometry.map(node => [node.lat, node.lon]);
                    
                    if (coordinates.length >= 2) {
                        const tags = element.tags || {};
                        const name = tags.name || `Unnamed ${type} feature`;
                        
                        // Create polyline for ways
                        const polyline = L.polyline(coordinates, {
                            color: color,
                            weight: 3,
                            opacity: 0.7
                        });
                        
                        // Create popup with detailed information
                        const tagsList = Object.entries(tags)
                            .map(([key, value]) => `<strong>${key}:</strong> ${value}`)
                            .join('<br>');
                        
                        polyline.bindPopup(`
                            <div style="max-width: 300px;">
                                <h4 style="margin: 0 0 8px 0; color: ${color};">${name}</h4>
                                <p style="margin: 0 0 8px 0; font-size: 12px; color: #666;">
                                    ${description} ‚Ä¢ ID: ${element.id}
                                </p>
                                <div style="max-height: 200px; overflow-y: auto; font-size: 11px;">
                                    ${tagsList}
                                </div>
                            </div>
                        `);
                        
                        layerGroup.addLayer(polyline);
                        addedFeatures++;
                    }
                } else if (element.type === 'relation' && element.members) {
                    // Handle relations (like parks that are relations)
                    const tags = element.tags || {};
                    const name = tags.name || `Unnamed ${type} relation`;
                    
                    // For relations, we'll just show a marker at the center if we can calculate it
                    // This is simplified - in reality, you'd need to resolve the relation members
                    if (element.center) {
                        const marker = L.circleMarker([element.center.lat, element.center.lon], {
                            color: color,
                            fillColor: color,
                            fillOpacity: 0.5,
                            radius: 8
                        });
                        
                        const tagsList = Object.entries(tags)
                            .map(([key, value]) => `<strong>${key}:</strong> ${value}`)
                            .join('<br>');
                        
                        marker.bindPopup(`
                            <div style="max-width: 300px;">
                                <h4 style="margin: 0 0 8px 0; color: ${color};">${name}</h4>
                                <p style="margin: 0 0 8px 0; font-size: 12px; color: #666;">
                                    ${description} (Relation) ‚Ä¢ ID: ${element.id}
                                </p>
                                <div style="max-height: 200px; overflow-y: auto; font-size: 11px;">
                                    ${tagsList}
                                </div>
                            </div>
                        `);
                        
                        layerGroup.addLayer(marker);
                        addedFeatures++;
                    }
                }
            });
            
            if (addedFeatures > 0) {
                layerGroup.addTo(map);
                rawDataLayers.push(layerGroup);
                console.log(`Added ${addedFeatures} ${type} features to map`);
            } else {
                console.log(`No ${type} features found to display`);
            }
        }

        // Clear all raw data overlays
        function clearRawDataOverlays() {
            rawDataLayers.forEach(layer => {
                map.removeLayer(layer);
            });
            rawDataLayers = [];
            hideRawDataLegend();
        }

        // Show legend for raw data overlays
        function showRawDataLegend() {
            // Remove existing raw data legend if it exists
            hideRawDataLegend();
            
            const legendDiv = document.createElement('div');
            legendDiv.id = 'raw-data-legend';
            legendDiv.innerHTML = `
                <div style="position: absolute; top: 10px; right: 10px; background: white; padding: 12px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.3); z-index: 1000; font-size: 12px; min-width: 200px;">
                    <h4 style="margin: 0 0 8px 0; color: #1f2937;">üó∫Ô∏è Raw OSM Data</h4>
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                        <div style="width: 16px; height: 3px; background: #22c55e;"></div>
                        <span>Walkable areas</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                        <div style="width: 16px; height: 3px; background: #ef4444;"></div>
                        <span>Restricted areas</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                        <div style="width: 16px; height: 3px; background: #a855f7;"></div>
                        <span>Special areas</span>
                    </div>
                    <div style="font-size: 10px; color: #666; border-top: 1px solid #eee; padding-top: 6px;">
                        Click any line/marker for details
                    </div>
                </div>
            `;
            
            document.querySelector('.map-container').appendChild(legendDiv);
        }

        // Hide raw data legend
        function hideRawDataLegend() {
            const legend = document.getElementById('raw-data-legend');
            if (legend) {
                legend.remove();
            }
        }

        // Toggle enhanced geometric detection
        function toggleEnhancedDetection() {
            enhancedDetectionEnabled = !enhancedDetectionEnabled;
            const button = document.getElementById('enhancedBtn');
            
            if (enhancedDetectionEnabled) {
                button.textContent = 'üéØ Enhanced: ON';
                button.style.background = '#22c55e';
                console.log('‚úÖ Enhanced geometric detection enabled - will check grid cell boundaries vs OSM geometry');
            } else {
                button.textContent = 'üéØ Enhanced Detection';
                button.style.background = '#4f46e5';
                console.log('‚ùå Enhanced detection disabled - using center-point method');
            }
        }

        // Calculate grid cell boundary coordinates - FIXED to match visual grid positioning
        function getGridCellBounds(row, col, gridSize, bounds) {
            const northeast = bounds.getNorthEast();
            const southwest = bounds.getSouthWest();
            
            const latRange = northeast.lat - southwest.lat;
            const lngRange = northeast.lng - southwest.lng;
            
            // Get the map container dimensions (same as visual grid calculation)
            const mapContainer = map.getContainer();
            const containerWidth = mapContainer.clientWidth;
            const containerHeight = mapContainer.clientHeight;
            
            // Use the smaller dimension to match visual grid (creates square cells)
            const smallerDimension = Math.min(containerWidth, containerHeight);
            
            // Calculate how much of the map bounds the grid actually covers
            const gridWidthRatio = smallerDimension / containerWidth;
            const gridHeightRatio = smallerDimension / containerHeight;
            
            // Calculate the actual lat/lng range covered by the grid (not full bounds)
            const gridLatRange = latRange * gridHeightRatio;
            const gridLngRange = lngRange * gridWidthRatio;
            
            // Calculate centering offsets in geographic coordinates
            const latOffset = (latRange - gridLatRange) / 2;
            const lngOffset = (lngRange - gridLngRange) / 2;
            
            // Calculate the southwest corner of the grid area (not the map bounds)
            const gridSouthwest = {
                lat: southwest.lat + latOffset,
                lng: southwest.lng + lngOffset
            };
            
            // Calculate cell boundaries within the actual grid area
            const cellLatMin = gridSouthwest.lat + (gridLatRange * (1 - (row + 1) / gridSize));
            const cellLatMax = gridSouthwest.lat + (gridLatRange * (1 - row / gridSize));
            const cellLngMin = gridSouthwest.lng + (gridLngRange * col / gridSize);
            const cellLngMax = gridSouthwest.lng + (gridLngRange * (col + 1) / gridSize);
            
            return {
                north: cellLatMax,
                south: cellLatMin,
                east: cellLngMax,
                west: cellLngMin,
                center: {
                    lat: (cellLatMin + cellLatMax) / 2,
                    lng: (cellLngMin + cellLngMax) / 2
                },
                // Debug info
                debug: {
                    gridWidthRatio: gridWidthRatio.toFixed(3),
                    gridHeightRatio: gridHeightRatio.toFixed(3),
                    containerDimensions: `${containerWidth}x${containerHeight}`,
                    smallerDimension: smallerDimension
                }
            };
        }

        // Check if a line segment intersects with a rectangle (grid cell)
        function lineIntersectsRect(x1, y1, x2, y2, rectWest, rectSouth, rectEast, rectNorth) {
            // Check if line is completely inside rectangle
            if (pointInRect(x1, y1, rectWest, rectSouth, rectEast, rectNorth) || 
                pointInRect(x2, y2, rectWest, rectSouth, rectEast, rectNorth)) {
                return true;
            }
            
            // Check line intersection with each edge of rectangle
            return (
                lineIntersectsLine(x1, y1, x2, y2, rectWest, rectSouth, rectEast, rectSouth) || // bottom edge
                lineIntersectsLine(x1, y1, x2, y2, rectEast, rectSouth, rectEast, rectNorth) || // right edge
                lineIntersectsLine(x1, y1, x2, y2, rectEast, rectNorth, rectWest, rectNorth) || // top edge
                lineIntersectsLine(x1, y1, x2, y2, rectWest, rectNorth, rectWest, rectSouth)    // left edge
            );
        }

        // Check if point is inside rectangle
        function pointInRect(x, y, west, south, east, north) {
            return x >= west && x <= east && y >= south && y <= north;
        }

        // Check if two line segments intersect
        function lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) {
            const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (Math.abs(denom) < 1e-10) return false; // parallel lines
            
            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
            
            return t >= 0 && t <= 1 && u >= 0 && u <= 1;
        }

        // Enhanced check for walkable areas using geometric intersection
        function checkGridCellIntersectsWalkableAreas(cellBounds, osmElements) {
            for (const element of osmElements) {
                if (element.type === 'way' && element.geometry && element.geometry.length >= 2) {
                    const tags = element.tags || {};
                    const isRestrictedElement = tags.fee === 'yes' || tags.access === 'private' || 
                                              tags.access === 'no' || tags.access === 'customers' ||
                                              tags.landuse === 'military' || tags.dog === 'no';
                    
                    if (!isRestrictedElement) {
                        // Check if any segment of this OSM way intersects with the grid cell
                        for (let i = 0; i < element.geometry.length - 1; i++) {
                            const node1 = element.geometry[i];
                            const node2 = element.geometry[i + 1];
                            
                            if (lineIntersectsRect(
                                node1.lon, node1.lat, 
                                node2.lon, node2.lat,
                                cellBounds.west, cellBounds.south, 
                                cellBounds.east, cellBounds.north
                            )) {
                                console.log(`Geometric intersection found: ${tags.name || tags.highway || 'unnamed'} crosses grid cell`);
                                return {
                                    intersects: true,
                                    feature: tags.name || tags.highway || 'unnamed feature',
                                    type: tags.highway || tags.leisure || 'unknown'
                                };
                            }
                        }
                        
                        // Also check if any nodes are within the cell bounds
                        for (const node of element.geometry) {
                            if (pointInRect(node.lon, node.lat, cellBounds.west, cellBounds.south, cellBounds.east, cellBounds.north)) {
                                console.log(`Point intersection found: ${tags.name || tags.highway || 'unnamed'} has nodes in grid cell`);
                                return {
                                    intersects: true,
                                    feature: tags.name || tags.highway || 'unnamed feature',
                                    type: tags.highway || tags.leisure || 'unknown'
                                };
                            }
                        }
                    }
                }
            }
            return { intersects: false };
        }

        // Enhanced check for restricted areas using geometric intersection
        function checkGridCellIntersectsRestrictedAreas(cellBounds, osmElements) {
            for (const element of osmElements) {
                if (element.type === 'way' && element.geometry && element.geometry.length >= 2) {
                    const tags = element.tags || {};
                    const isRestrictedElement = 
                        tags.fee === 'yes' || 
                        tags.access === 'private' || 
                        tags.access === 'no' || 
                        tags.access === 'customers' ||
                        tags.landuse === 'military' || 
                        tags.dog === 'no' ||
                        tags.admission ||
                        (tags.leisure === 'garden' && tags.tourism) ||
                        (tags.tourism === 'attraction' && tags.leisure === 'garden') ||
                        (tags.name && tags.name.toLowerCase().includes('botanical')) ||
                        (tags.name && tags.name.toLowerCase().includes('vandusen')) ||
                        (tags.tourism === 'zoo') ||
                        (tags.tourism === 'museum') ||
                        (tags.tourism === 'theme_park');
                    
                    if (isRestrictedElement) {
                        // Check geometric intersection
                        for (let i = 0; i < element.geometry.length - 1; i++) {
                            const node1 = element.geometry[i];
                            const node2 = element.geometry[i + 1];
                            
                            if (lineIntersectsRect(
                                node1.lon, node1.lat, 
                                node2.lon, node2.lat,
                                cellBounds.west, cellBounds.south, 
                                cellBounds.east, cellBounds.north
                            )) {
                                console.log(`Restricted area intersection found: ${tags.name || 'unnamed'} crosses grid cell`);
                                return {
                                    intersects: true,
                                    feature: tags.name || 'unnamed restricted area',
                                    type: tags.tourism || tags.leisure || 'restricted'
                                };
                            }
                        }
                        
                        // Check if any nodes are within the cell bounds
                        for (const node of element.geometry) {
                            if (pointInRect(node.lon, node.lat, cellBounds.west, cellBounds.south, cellBounds.east, cellBounds.north)) {
                                console.log(`Restricted area point found: ${tags.name || 'unnamed'} has nodes in grid cell`);
                                return {
                                    intersects: true,
                                    feature: tags.name || 'unnamed restricted area',
                                    type: tags.tourism || tags.leisure || 'restricted'
                                };
                            }
                        }
                    }
                }
            }
            return { intersects: false };
        }

        // Debug specific cell intersection
        async function debugSpecificCell() {
            if (!map || gridCells.length === 0) {
                alert('Please load map and generate grid first!');
                return;
            }

            const button = document.getElementById('debugCellBtn');
            const originalText = button.textContent;
            button.textContent = 'üî¨ Click a cell to debug...';
            button.style.background = '#f59e0b';

            // Add temporary click handler to grid cells
            const debugClickHandler = async (event) => {
                const cell = event.target;
                if (!cell.classList.contains('grid-cell')) return;

                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const gridSize = parseInt(document.getElementById('grid-size').value);

                console.log(`\nüî¨ DEBUGGING CELL ${row},${col}`);
                
                // Get cell bounds
                const bounds = map.getBounds();
                const cellBounds = getGridCellBounds(row, col, gridSize, bounds);
                
                console.log('Cell Bounds:', cellBounds);
                console.log('Grid Scaling Debug:', cellBounds.debug);
                
                // Get fresh OSM data for this area
                try {
                    button.textContent = 'üîç Analyzing intersection...';
                    
                    const center = map.getCenter();
                    const radius = parseInt(document.getElementById('radius').value);
                    const osmData = await queryWalkableAreas(center.lat, center.lng, radius);
                    
                    console.log(`Found ${osmData?.elements?.length || 0} OSM elements total`);
                    
                    // Check each OSM element against this specific cell
                    let intersectionCount = 0;
                    let walkableIntersections = [];
                    
                    if (osmData?.elements) {
                        osmData.elements.forEach((element, idx) => {
                            if (element.type === 'way' && element.geometry && element.geometry.length >= 2) {
                                const tags = element.tags || {};
                                const featureName = tags.name || tags.highway || `Element-${idx}`;
                                
                                // Check each line segment
                                for (let i = 0; i < element.geometry.length - 1; i++) {
                                    const node1 = element.geometry[i];
                                    const node2 = element.geometry[i + 1];
                                    
                                    const intersects = lineIntersectsRect(
                                        node1.lon, node1.lat, 
                                        node2.lon, node2.lat,
                                        cellBounds.west, cellBounds.south, 
                                        cellBounds.east, cellBounds.north
                                    );
                                    
                                    if (intersects) {
                                        intersectionCount++;
                                        walkableIntersections.push({
                                            feature: featureName,
                                            segment: i,
                                            from: `${node1.lat.toFixed(6)}, ${node1.lon.toFixed(6)}`,
                                            to: `${node2.lat.toFixed(6)}, ${node2.lon.toFixed(6)}`,
                                            tags: tags
                                        });
                                        console.log(`‚úÖ INTERSECTION ${intersectionCount}: ${featureName} segment ${i}`);
                                        console.log(`   From: ${node1.lat.toFixed(6)}, ${node1.lon.toFixed(6)}`);
                                        console.log(`   To: ${node2.lat.toFixed(6)}, ${node2.lon.toFixed(6)}`);
                                        console.log(`   Tags:`, tags);
                                    }
                                }
                            }
                        });
                    }
                    
                    // Show results
                    const currentState = cell.dataset.state;
                    console.log(`\nüìä CELL ${row},${col} ANALYSIS:`);
                    console.log(`   Current state: ${currentState}`);
                    console.log(`   Found ${intersectionCount} intersections with walkable features`);
                    console.log(`   Cell bounds: ${cellBounds.south.toFixed(6)} to ${cellBounds.north.toFixed(6)} lat, ${cellBounds.west.toFixed(6)} to ${cellBounds.east.toFixed(6)} lng`);
                    
                    if (intersectionCount > 0 && currentState !== 'walkable') {
                        console.log(`‚ö†Ô∏è  MISMATCH: Cell has ${intersectionCount} walkable intersections but is marked as "${currentState}"`);
                        
                        // Create detailed alert
                        let alertMessage = `üî¨ CELL ${row},${col} DEBUG RESULTS:\n\n`;
                        alertMessage += `Current state: ${currentState}\n`;
                        alertMessage += `Found ${intersectionCount} walkable intersections!\n\n`;
                        
                        if (walkableIntersections.length > 0) {
                            alertMessage += `Intersecting features:\n`;
                            walkableIntersections.slice(0, 3).forEach((intersection, idx) => {
                                alertMessage += `${idx + 1}. ${intersection.feature}\n`;
                            });
                            if (walkableIntersections.length > 3) {
                                alertMessage += `... and ${walkableIntersections.length - 3} more\n`;
                            }
                        }
                        
                        alertMessage += `\nThis suggests the intersection detection isn't working properly for this cell.`;
                        alert(alertMessage);
                    } else if (intersectionCount === 0 && currentState === 'walkable') {
                        alert(`üî¨ CELL ${row},${col}: No intersections found but marked as walkable.\nThis could be from center-point detection or restricted area logic.`);
                    } else {
                        alert(`üî¨ CELL ${row},${col}: ${intersectionCount} intersections found, state "${currentState}" appears correct.`);
                    }
                    
                } catch (error) {
                    console.error('Debug error:', error);
                    alert('Debug failed: ' + error.message);
                }
                
                // Remove click handlers and reset button
                gridCells.forEach(c => c.removeEventListener('click', debugClickHandler));
                button.textContent = originalText;
                button.style.background = '#4f46e5';
            };

            // Add click handlers to all grid cells
            gridCells.forEach(cell => {
                cell.addEventListener('click', debugClickHandler);
            });

            // Reset button after 30 seconds
            setTimeout(() => {
                gridCells.forEach(cell => cell.removeEventListener('click', debugClickHandler));
                if (button.textContent.includes('Click a cell')) {
                    button.textContent = originalText;
                    button.style.background = '#4f46e5';
                }
            }, 30000);
        }

        // Keyboard shortcuts for easier testing
        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'c') {
                clearGrid();
                e.preventDefault();
            }
            if (e.key.toLowerCase() === 'g') {
                generateGrid();
                e.preventDefault();
            }
            if (e.key.toLowerCase() === 'r') {
                toggleRawDataOverlay();
                e.preventDefault();
            }
            if (e.key.toLowerCase() === 'e') {
                toggleEnhancedDetection();
                e.preventDefault();
            }
        });

        // Initialize with default coordinates
        document.getElementById('latitude').value = defaultCoords.lat;
        document.getElementById('longitude').value = defaultCoords.lng;

        // Welcome message
        console.log('üó∫Ô∏è Walkable Areas Grid Test loaded');
        console.log('');
        console.log('üìã Instructions:');
        console.log('1. Enter your coordinates or click "Use My Location"');
        console.log('2. Click "Load Map" to visualize your area');
        console.log('3. Click "Generate Grid" to create the test grid');
        console.log('4. Click grid cells to cycle through: Unknown ‚Üí Walkable ‚Üí Non-walkable');
        console.log('');
        console.log('‚å®Ô∏è Keyboard shortcuts: C=clear, G=generate');
        console.log('');
        console.log('This test simulates how your dog walking app would analyze walkable areas!');
    </script>
</body>
</html> 