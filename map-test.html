<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Walkable Areas Grid Test</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        h1 {
            margin-bottom: 24px;
            color: #1f2937;
        }

        .controls {
            display: flex;
            gap: 16px;
            margin-bottom: 24px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        label {
            font-size: 14px;
            font-weight: 500;
            color: #374151;
        }

        input, select, button {
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
        }

        button {
            background: #4f46e5;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s;
        }

        button:hover {
            background: #4338ca;
        }

        .map-container {
            position: relative;
            width: 100%;
            height: 600px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            overflow: hidden;
            background: #f9fafb;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 1000;
        }

        .grid-cell {
            position: absolute;
            border: 2px solid rgba(79, 70, 229, 0.4);
            background: rgba(79, 70, 229, 0.15);
            transition: all 0.2s;
            cursor: pointer;
            pointer-events: auto;
        }

        .grid-cell.walkable {
            background: rgba(34, 197, 94, 0.6);
            border: 2px solid rgba(22, 163, 74, 0.9);
        }

        .grid-cell.non-walkable {
            background: rgba(239, 68, 68, 0.6);
            border: 2px solid rgba(220, 38, 38, 0.9);
        }

        .grid-cell.restricted {
            background: rgba(168, 85, 247, 0.6);
            border: 2px solid rgba(147, 51, 234, 0.9);
        }

        .grid-cell.unknown {
            background: rgba(156, 163, 175, 0.4);
            border: 2px solid rgba(107, 114, 128, 0.7);
        }

        .grid-cell:hover {
            opacity: 0.8;
            transform: scale(1.02);
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-top: 16px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.2);
        }

        .info-panel {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
            margin-top: 20px;
        }

        .info-panel h3 {
            margin-bottom: 8px;
            color: #1e293b;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 16px;
            margin-top: 12px;
        }

        .stat {
            text-align: center;
            padding: 12px;
            background: white;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #1e293b;
        }

        .stat-label {
            font-size: 12px;
            color: #64748b;
            margin-top: 4px;
        }

        .instructions {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 24px;
        }

        .instructions h3 {
            color: #92400e;
            margin-bottom: 8px;
        }

        .instructions ul {
            color: #92400e;
            margin-left: 20px;
        }

        .instructions li {
            margin-bottom: 4px;
        }

        .keyboard-shortcuts {
            background: #eff6ff;
            border: 1px solid #3b82f6;
            border-radius: 8px;
            padding: 12px;
            margin-top: 16px;
            font-size: 12px;
        }

        .keyboard-shortcuts strong {
            color: #1e40af;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .map-container {
                height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üó∫Ô∏è Walkable Areas Grid Test</h1>
        
        <div class="instructions">
            <h3>üìã How to Use This Test</h3>
            <ul>
                <li>Enter your coordinates or click "üìç Use My Location"</li>
                <li>Click "üó∫Ô∏è Load Map" to visualize your area</li>
                <li>Click "‚¨ú Generate Grid" to create the test grid</li>
                <li>Click grid cells to cycle through: Unknown ‚Üí Walkable ‚Üí Non-walkable</li>
                <li>Observe how coverage percentage changes as you classify areas</li>
            </ul>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="latitude">Your Latitude:</label>
                <input type="number" id="latitude" step="0.000001" placeholder="e.g., 40.7128" />
            </div>
            
            <div class="control-group">
                <label for="longitude">Your Longitude:</label>
                <input type="number" id="longitude" step="0.000001" placeholder="e.g., -74.0060" />
            </div>
            
            <div class="control-group">
                <label for="grid-size">Grid Size:</label>
                <select id="grid-size">
                    <option value="10">10x10</option>
                    <option value="15" selected>15x15</option>
                    <option value="20">20x20</option>
                    <option value="25">25x25</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="radius">Radius (meters):</label>
                <input type="number" id="radius" value="500" min="100" max="2000" step="50" />
            </div>
            
            <button onclick="getCurrentLocation()">üìç Use My Location</button>
            <button onclick="showLocationHelp()">‚ùì Need Coordinates?</button>
            <button onclick="loadMap()">üó∫Ô∏è Load Map</button>
            <button onclick="generateGrid()">‚¨ú Generate Grid</button>
            <button onclick="autoDetectWalkable()" id="autoDetectBtn">ü§ñ Auto-Detect Walkable Areas</button>
            <button onclick="showRestrictedAreas()" id="restrictedBtn">üö´ Show Restricted Areas</button>
            <button onclick="debugOSMData()" id="debugBtn">üîç Debug OSM Data</button>
            <button onclick="clearGrid()">üßπ Clear Grid</button>
        </div>

        <div class="map-container">
            <div id="map">
                <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #6b7280; font-size: 18px; text-align: center; flex-direction: column; gap: 16px;">
                    <div style="font-size: 48px;">üìç</div>
                    <div>Enter coordinates and click "Load Map" to begin</div>
                    <div style="font-size: 14px; color: #9ca3af;">This simulates how your dog walking app would analyze walkable areas</div>
                </div>
            </div>
            <div class="grid-overlay" id="grid-overlay"></div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(34, 197, 94, 0.3); border-color: rgba(34, 197, 94, 0.6);"></div>
                <span>Walkable (roads, sidewalks, parks)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(239, 68, 68, 0.3); border-color: rgba(239, 68, 68, 0.6);"></div>
                <span>Non-walkable (private property, buildings)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(156, 163, 175, 0.2); border-color: rgba(156, 163, 175, 0.4);"></div>
                <span>Unknown/Unclassified</span>
            </div>
        </div>

        <div class="info-panel">
            <h3>üìä Grid Analysis</h3>
            <p>Click on grid cells to classify areas. This simulates how the app would analyze walkable vs non-walkable areas in your residential neighborhood.</p>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(34, 197, 94, 0.6); border: 2px solid rgba(22, 163, 74, 0.9);"></div>
                    <span>Walkable Areas</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(239, 68, 68, 0.6); border: 2px solid rgba(220, 38, 38, 0.9);"></div>
                    <span>Non-walkable Areas</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(168, 85, 247, 0.6); border: 2px solid rgba(147, 51, 234, 0.9);"></div>
                    <span>Restricted Areas</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(156, 163, 175, 0.4); border: 2px solid rgba(107, 114, 128, 0.7);"></div>
                    <span>Unknown Areas</span>
                </div>
            </div>

            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="walkable-count">0</div>
                    <div class="stat-label">Walkable Cells</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="non-walkable-count">0</div>
                    <div class="stat-label">Non-walkable Cells</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="restricted-count">0</div>
                    <div class="stat-label">Restricted Cells</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="unknown-count">0</div>
                    <div class="stat-label">Unknown Cells</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="coverage-percent">0%</div>
                    <div class="stat-label">Area Coverage</div>
                </div>
            </div>

            <div class="keyboard-shortcuts">
                <strong>Keyboard Shortcuts:</strong> Press <strong>1</strong> then click = Walkable | <strong>2</strong> then click = Non-walkable | <strong>3</strong> then click = Unknown | <strong>C</strong> = Clear grid | <strong>G</strong> = Generate grid
            </div>
        </div>
    </div>

    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        let map = null;
        let gridCells = [];
        let currentState = 'walkable'; // Current classification mode

        // Sample coordinates (New York City) - user will replace with their location
        const defaultCoords = { lat: 40.7128, lng: -74.0060 };

        function getCurrentLocation() {
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = 'üì° Getting location...';
            button.disabled = true;

            console.log('Attempting to get location...');

            if (!navigator.geolocation) {
                alert('Geolocation is not supported by this browser.');
                button.textContent = originalText;
                button.disabled = false;
                return;
            }

            // Check if page is served over HTTPS or localhost
            const isSecure = location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
            if (!isSecure) {
                alert('Geolocation requires HTTPS or localhost. Please enter coordinates manually or serve the page over HTTPS.');
                button.textContent = originalText;
                button.disabled = false;
                return;
            }

            const options = {
                enableHighAccuracy: true,
                timeout: 10000, // 10 seconds
                maximumAge: 60000 // 1 minute
            };

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    console.log('Location success:', position);
                    document.getElementById('latitude').value = position.coords.latitude.toFixed(6);
                    document.getElementById('longitude').value = position.coords.longitude.toFixed(6);
                    button.textContent = '‚úÖ Location found!';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.disabled = false;
                    }, 2000);
                    console.log(`Location obtained: ${position.coords.latitude}, ${position.coords.longitude}`);
                },
                (error) => {
                    console.error('Geolocation error:', error);
                    let errorMessage = 'Could not get your location. ';
                    
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                            errorMessage += 'Permission denied. Please allow location access and try again.';
                            break;
                        case error.POSITION_UNAVAILABLE:
                            errorMessage += 'Location information unavailable.';
                            break;
                        case error.TIMEOUT:
                            errorMessage += 'Location request timed out.';
                            break;
                        default:
                            errorMessage += 'An unknown error occurred.';
                            break;
                    }
                    
                    errorMessage += '\n\nPlease enter coordinates manually or try again.';
                    alert(errorMessage);
                    
                    button.textContent = '‚ùå Location failed';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.disabled = false;
                    }, 3000);
                },
                options
            );
        }

        function showLocationHelp() {
            const helpMessage = `üìç How to get your coordinates:

Method 1: Google Maps
‚Ä¢ Open maps.google.com
‚Ä¢ Right-click on your location
‚Ä¢ Click the coordinates that appear
‚Ä¢ Copy them here

Method 2: GPS Coordinates app
‚Ä¢ Search "GPS coordinates" in your app store
‚Ä¢ Use any GPS app on your phone

Method 3: Manual entry
‚Ä¢ If you know your approximate address, search online for "[your address] coordinates"

The format should be:
Latitude: Like 40.7128 (North/South)
Longitude: Like -74.0060 (East/West)`;

            alert(helpMessage);
        }

        function loadMap() {
            const lat = parseFloat(document.getElementById('latitude').value);
            const lng = parseFloat(document.getElementById('longitude').value);

            if (isNaN(lat) || isNaN(lng)) {
                alert('Please enter valid coordinates.');
                return;
            }

            // Validate coordinates are reasonable
            if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                alert('Please enter valid coordinates (latitude: -90 to 90, longitude: -180 to 180).');
                return;
            }

            // Clear the map div and create a new map
            const mapDiv = document.getElementById('map');
            mapDiv.innerHTML = '';
            
            // Destroy existing map if it exists
            if (map !== null) {
                map.remove();
                map = null;
            }

            // Create new Leaflet map
            map = L.map('map').setView([lat, lng], 16);

            // Add OpenStreetMap tiles
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            // Add a marker at the center location
            L.marker([lat, lng])
                .addTo(map)
                .bindPopup(`üìç Your Location<br>${lat.toFixed(4)}, ${lng.toFixed(4)}`)
                .openPopup();

            // Add a circle to show the radius
            const radius = parseInt(document.getElementById('radius').value);
            L.circle([lat, lng], {
                color: '#4f46e5',
                fillColor: '#4f46e5',
                fillOpacity: 0.1,
                radius: radius
            }).addTo(map).bindPopup(`Search radius: ${radius}m`);

            console.log(`Real map loaded for coordinates: ${lat}, ${lng} with ${radius}m radius`);
        }

        function generateGrid() {
            const gridSize = parseInt(document.getElementById('grid-size').value);
            const radius = parseInt(document.getElementById('radius').value);
            const gridOverlay = document.getElementById('grid-overlay');
            
            // Clear existing grid
            gridOverlay.innerHTML = '';
            gridCells = [];

            const cellSize = 100 / gridSize; // Percentage size of each cell

            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell unknown';
                    cell.style.left = `${col * cellSize}%`;
                    cell.style.top = `${row * cellSize}%`;
                    cell.style.width = `${cellSize}%`;
                    cell.style.height = `${cellSize}%`;
                    
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.dataset.state = 'unknown';
                    
                    // Add tooltip
                    cell.title = `Cell ${row},${col} - Click to classify`;
                    
                    cell.addEventListener('click', () => toggleCellState(cell));
                    
                    gridOverlay.appendChild(cell);
                    gridCells.push(cell);
                }
            }

            updateStats();
            console.log(`Generated ${gridSize}x${gridSize} grid (${gridCells.length} cells)`);
            
            // Show success message
            const originalText = event.target.textContent;
            event.target.textContent = `‚úÖ ${gridCells.length} cells created!`;
            setTimeout(() => {
                event.target.textContent = originalText;
            }, 2000);
        }

        function toggleCellState(cell) {
            const currentState = cell.dataset.state;
            let newState;
            
            // Cycle through states: unknown -> walkable -> non-walkable -> unknown
            switch (currentState) {
                case 'unknown':
                    newState = 'walkable';
                    break;
                case 'walkable':
                    newState = 'non-walkable';
                    break;
                case 'non-walkable':
                    newState = 'unknown';
                    break;
                default:
                    newState = 'unknown';
            }
            
            cell.dataset.state = newState;
            cell.className = `grid-cell ${newState}`;
            cell.title = `Cell ${cell.dataset.row},${cell.dataset.col} - ${newState.replace('-', ' ')}`;
            
            updateStats();

            // Visual feedback
            cell.style.transform = 'scale(1.1)';
            setTimeout(() => {
                cell.style.transform = '';
            }, 150);
        }

        function updateStats() {
            const walkable = gridCells.filter(cell => cell.dataset.state === 'walkable').length;
            const nonWalkable = gridCells.filter(cell => cell.dataset.state === 'non-walkable').length;
            const restricted = gridCells.filter(cell => cell.dataset.state === 'restricted').length;
            const unknown = gridCells.filter(cell => cell.dataset.state === 'unknown').length;
            const total = gridCells.length;
            
            const classified = walkable + nonWalkable + restricted;
            const coveragePercent = total > 0 ? Math.round((classified / total) * 100) : 0;
            
            document.getElementById('walkable-count').textContent = walkable;
            document.getElementById('non-walkable-count').textContent = nonWalkable;
            document.getElementById('restricted-count').textContent = restricted;
            document.getElementById('unknown-count').textContent = unknown;
            document.getElementById('coverage-percent').textContent = `${coveragePercent}%`;
        }

        function clearGrid() {
            if (gridCells.length === 0) {
                alert('No grid to clear. Generate a grid first!');
                return;
            }

            gridCells.forEach(cell => {
                cell.dataset.state = 'unknown';
                cell.className = 'grid-cell unknown';
                cell.title = `Cell ${cell.dataset.row},${cell.dataset.col} - Click to classify`;
            });
            updateStats();
            
            // Visual feedback
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = '‚úÖ Grid cleared!';
            setTimeout(() => {
                button.textContent = originalText;
            }, 1500);
        }

        // Auto-detect walkable areas using OpenStreetMap data
        async function autoDetectWalkable() {
            if (!map) {
                alert('Please load the map first!');
                return;
            }

            if (gridCells.length === 0) {
                alert('Please generate a grid first!');
                return;
            }

            const button = document.getElementById('autoDetectBtn');
            const originalText = button.textContent;
            button.textContent = 'üîç Analyzing area...';
            button.disabled = true;

            try {
                const center = map.getCenter();
                const radius = parseInt(document.getElementById('radius').value);
                
                console.log(`Querying walkable areas around ${center.lat}, ${center.lng} within ${radius}m`);
                
                // Query both walkable AND restricted areas
                const [walkableData, restrictedData] = await Promise.all([
                    queryWalkableAreas(center.lat, center.lng, radius),
                    queryRestrictedAreas(center.lat, center.lng, radius)
                ]);
                
                // Combine the data
                const combinedData = {
                    elements: [
                        ...(walkableData?.elements || []),
                        ...(restrictedData?.elements || [])
                    ]
                };
                
                // Apply the data to existing grid
                if (combinedData.elements.length > 0) {
                    classifyGridWithOSMData(combinedData);
                    button.textContent = '‚úÖ Detection complete!';
                } else {
                    button.textContent = '‚ùå No data found';
                }
                
            } catch (error) {
                console.error('Auto-detection error:', error);
                button.textContent = '‚ùå Detection failed';
            }
            
            setTimeout(() => {
                button.textContent = originalText;
                button.disabled = false;
            }, 3000);
        }

        // Query OpenStreetMap Overpass API for walkable areas
        async function queryWalkableAreas(lat, lng, radius) {
            const overpassUrl = 'https://overpass-api.de/api/interpreter';
            
            // Enhanced Overpass query for walkable areas with access restrictions
            const query = `
                [out:json][timeout:25];
                (
                  // Roads and highways (walkable, not private)
                  way["highway"~"^(primary|secondary|tertiary|residential|unclassified|service|footway|path|pedestrian|cycleway)$"]["access"!="private"]["access"!="no"](around:${radius},${lat},${lng});
                  
                  // Sidewalks specifically  
                  way["footway"="sidewalk"]["access"!="private"](around:${radius},${lat},${lng});
                  
                  // Parks and recreational areas (exclude fee-based and private)
                  way["leisure"~"^(park|playground|recreation_ground|garden)$"]["access"!="private"]["fee"!="yes"](around:${radius},${lat},${lng});
                  rel["leisure"~"^(park|playground|recreation_ground|garden)$"]["access"!="private"]["fee"!="yes"](around:${radius},${lat},${lng});
                  
                  // Public paths and trails (explicitly exclude private)
                  way["highway"="track"]["access"!="private"]["access"!="no"](around:${radius},${lat},${lng});
                );
                out geom;
            `;

            try {
                const response = await fetch(overpassUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: 'data=' + encodeURIComponent(query)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('OSM Data received:', data.elements?.length || 0, 'elements');
                return data;
                
            } catch (error) {
                console.error('Error querying OpenStreetMap:', error);
                return null;
            }
        }

        // Classify grid cells based on OSM data
        function classifyGridWithOSMData(osmData) {
            if (!osmData || !osmData.elements) {
                console.error('No OSM data to process');
                return;
            }

            const bounds = map.getBounds();
            const northeast = bounds.getNorthEast();
            const southwest = bounds.getSouthWest();
            
            let classifiedCount = 0;
            
            gridCells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const gridSize = parseInt(document.getElementById('grid-size').value);
                
                // Calculate the center lat/lng of this grid cell
                const latRange = northeast.lat - southwest.lat;
                const lngRange = northeast.lng - southwest.lng;
                
                const cellLat = southwest.lat + (latRange * (1 - (row + 0.5) / gridSize));
                const cellLng = southwest.lng + (lngRange * (col + 0.5) / gridSize);
                
                // Check if this grid cell intersects with any walkable areas
                const isWalkable = checkPointInWalkableAreas(cellLat, cellLng, osmData.elements);
                
                // Check for restricted areas
                const isRestricted = checkPointInRestrictedAreas(cellLat, cellLng, osmData.elements);
                
                // PRIORITY: Walkable areas take precedence over restricted areas
                // If there's any public walkable access, the cell is considered walkable
                if (isWalkable) {
                    cell.dataset.state = 'walkable';
                    cell.className = 'grid-cell walkable';
                    cell.title = `Cell ${row},${col} - walkable (auto-detected)`;
                    classifiedCount++;
                    console.log(`Cell ${row},${col} marked as WALKABLE at ${cellLat.toFixed(6)}, ${cellLng.toFixed(6)}`);
                } else if (isRestricted) {
                    cell.dataset.state = 'restricted';
                    cell.className = 'grid-cell restricted';
                    cell.title = `Cell ${row},${col} - restricted (auto-detected)`;
                    classifiedCount++;
                    console.log(`Cell ${row},${col} marked as RESTRICTED at ${cellLat.toFixed(6)}, ${cellLng.toFixed(6)}`);
                } else {
                    cell.dataset.state = 'non-walkable';
                    cell.className = 'grid-cell non-walkable';
                    cell.title = `Cell ${row},${col} - non-walkable (auto-detected)`;
                }
            });
            
            console.log(`Auto-classified ${classifiedCount} cells as walkable out of ${gridCells.length} total`);
            updateStats();
        }

        // Check if a point is within any walkable areas
        function checkPointInWalkableAreas(pointLat, pointLng, osmElements) {
            for (const element of osmElements) {
                if (element.type === 'way' && element.geometry) {
                    // Only check walkable elements (not restricted ones)
                    const tags = element.tags || {};
                    const isRestrictedElement = tags.fee === 'yes' || tags.access === 'private' || 
                                              tags.access === 'no' || tags.access === 'customers' ||
                                              tags.landuse === 'military' || tags.dog === 'no';
                    
                    if (!isRestrictedElement) {
                        // Check proximity to walkable infrastructure
                        for (const node of element.geometry) {
                            const distance = calculateDistance(pointLat, pointLng, node.lat, node.lon);
                            // If within 30 meters of a walkable way, consider it walkable
                            // (accounts for sidewalks, nearby roads, etc.)
                            if (distance < 30) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        // Check if a point is within any restricted areas
        function checkPointInRestrictedAreas(pointLat, pointLng, osmElements) {
            for (const element of osmElements) {
                if (element.type === 'way' && element.geometry) {
                    // Enhanced restricted element detection
                    const tags = element.tags || {};
                    const isRestrictedElement = 
                        tags.fee === 'yes' || 
                        tags.access === 'private' || 
                        tags.access === 'no' || 
                        tags.access === 'customers' ||
                        tags.landuse === 'military' || 
                        tags.dog === 'no' ||
                        // Additional fee-based attraction tags
                        tags.admission ||
                        (tags.leisure === 'garden' && tags.tourism) || // Botanical gardens that are tourist attractions
                        (tags.tourism === 'attraction' && tags.leisure === 'garden') ||
                        (tags.name && tags.name.toLowerCase().includes('botanical')) ||
                        (tags.name && tags.name.toLowerCase().includes('vandusen')) ||
                        // Common patterns for fee-based venues
                        (tags.tourism === 'zoo') ||
                        (tags.tourism === 'museum') ||
                        (tags.tourism === 'theme_park');
                    
                    if (isRestrictedElement) {
                        console.log(`Found restricted element: ${tags.name || 'Unnamed'} with tags:`, tags);
                        // Check proximity to restricted areas
                        for (const node of element.geometry) {
                            const distance = calculateDistance(pointLat, pointLng, node.lat, node.lon);
                            // If within 15 meters of a restricted area, consider it restricted
                            if (distance < 15) {
                                console.log(`Point ${pointLat.toFixed(6)}, ${pointLng.toFixed(6)} is ${distance.toFixed(1)}m from restricted area: ${tags.name || 'Unnamed'}`);
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        // Show restricted areas that are excluded from walkable detection
        async function showRestrictedAreas() {
            if (!map) {
                alert('Please load the map first!');
                return;
            }

            const button = document.getElementById('restrictedBtn');
            const originalText = button.textContent;
            button.textContent = 'üîç Finding restrictions...';
            button.disabled = true;

            try {
                const center = map.getCenter();
                const radius = parseInt(document.getElementById('radius').value);
                
                // Query for restricted areas
                const restrictedData = await queryRestrictedAreas(center.lat, center.lng, radius);
                
                if (restrictedData && restrictedData.elements && restrictedData.elements.length > 0) {
                    displayRestrictedAreasInfo(restrictedData.elements);
                    button.textContent = '‚úÖ Restrictions found!';
                } else {
                    alert('No specifically tagged restricted areas found in this area.\n\nThis could mean:\n‚Ä¢ Area has good public access\n‚Ä¢ OSM data may not have detailed access tags\n‚Ä¢ Your pay-to-enter garden might not be tagged with fee=yes');
                    button.textContent = 'ü§∑ No restrictions found';
                }
                
            } catch (error) {
                console.error('Error finding restricted areas:', error);
                button.textContent = '‚ùå Query failed';
            }
            
            setTimeout(() => {
                button.textContent = originalText;
                button.disabled = false;
            }, 3000);
        }

        // Query OpenStreetMap for restricted/fee-based areas
        async function queryRestrictedAreas(lat, lng, radius) {
            const overpassUrl = 'https://overpass-api.de/api/interpreter';
            
            const query = `
                [out:json][timeout:25];
                (
                  // Fee-based areas (like your pay-to-enter garden)
                  way["fee"="yes"](around:${radius},${lat},${lng});
                  rel["fee"="yes"](around:${radius},${lat},${lng});
                  
                  // Private access areas
                  way["access"="private"](around:${radius},${lat},${lng});
                  way["access"="no"](around:${radius},${lat},${lng});
                  
                  // Customer-only areas
                  way["access"="customers"](around:${radius},${lat},${lng});
                  rel["access"="customers"](around:${radius},${lat},${lng});
                  
                  // Military or restricted areas
                  way["landuse"="military"](around:${radius},${lat},${lng});
                  
                  // Dog-restricted areas
                  way["dog"="no"](around:${radius},${lat},${lng});
                );
                out geom;
            `;

            try {
                const response = await fetch(overpassUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: 'data=' + encodeURIComponent(query)
                });

                const data = await response.json();
                console.log('Restricted areas data:', data.elements?.length || 0, 'elements');
                return data;
                
            } catch (error) {
                console.error('Error querying restricted areas:', error);
                return null;
            }
        }

        // Display information about restricted areas found
        function displayRestrictedAreasInfo(restrictedElements) {
            let restrictionTypes = {};
            
            restrictedElements.forEach(element => {
                const tags = element.tags || {};
                
                if (tags.fee === 'yes') {
                    restrictionTypes['Fee-based (pay-to-enter)'] = (restrictionTypes['Fee-based (pay-to-enter)'] || 0) + 1;
                }
                if (tags.access === 'private') {
                    restrictionTypes['Private access'] = (restrictionTypes['Private access'] || 0) + 1;
                }
                if (tags.access === 'no') {
                    restrictionTypes['No access'] = (restrictionTypes['No access'] || 0) + 1;
                }
                if (tags.access === 'customers') {
                    restrictionTypes['Customers only'] = (restrictionTypes['Customers only'] || 0) + 1;
                }
                if (tags.landuse === 'military') {
                    restrictionTypes['Military/restricted'] = (restrictionTypes['Military/restricted'] || 0) + 1;
                }
                if (tags.dog === 'no') {
                    restrictionTypes['No dogs allowed'] = (restrictionTypes['No dogs allowed'] || 0) + 1;
                }
            });
            
            let message = `üö´ Found ${restrictedElements.length} restricted areas:\n\n`;
            
            for (const [type, count] of Object.entries(restrictionTypes)) {
                message += `‚Ä¢ ${type}: ${count}\n`;
            }
            
            message += `\nüí° These areas are excluded from walkable detection because they have access restrictions that matter for everyday dog walking.`;
            
            alert(message);
        }

        // Debug function to show all OSM data in the area
        async function debugOSMData() {
            if (!map) {
                alert('Please load the map first!');
                return;
            }

            const button = document.getElementById('debugBtn');
            const originalText = button.textContent;
            button.textContent = 'üîç Gathering data...';
            button.disabled = true;

            try {
                const center = map.getCenter();
                const radius = parseInt(document.getElementById('radius').value);
                
                // Query for ALL relevant areas (walkable AND restricted)
                const [walkableData, restrictedData] = await Promise.all([
                    queryWalkableAreas(center.lat, center.lng, radius),
                    queryRestrictedAreas(center.lat, center.lng, radius)
                ]);
                
                // Also query specifically for botanical gardens, museums, etc.
                const specialData = await querySpecialAreas(center.lat, center.lng, radius);
                
                // Combine and analyze
                const allElements = [
                    ...(walkableData?.elements || []),
                    ...(restrictedData?.elements || []),
                    ...(specialData?.elements || [])
                ];
                
                displayOSMDebugInfo(allElements);
                button.textContent = '‚úÖ Data analyzed!';
                
            } catch (error) {
                console.error('Debug error:', error);
                button.textContent = '‚ùå Debug failed';
            }
            
            setTimeout(() => {
                button.textContent = originalText;
                button.disabled = false;
            }, 3000);
        }

        // Query for special fee-based areas that might use different tags
        async function querySpecialAreas(lat, lng, radius) {
            const overpassUrl = 'https://overpass-api.de/api/interpreter';
            
            const query = `
                [out:json][timeout:25];
                (
                  // Botanical gardens, museums, attractions
                  way["leisure"="garden"](around:${radius},${lat},${lng});
                  way["tourism"~"^(attraction|museum|zoo|theme_park)$"](around:${radius},${lat},${lng});
                  rel["leisure"="garden"](around:${radius},${lat},${lng});
                  rel["tourism"~"^(attraction|museum|zoo|theme_park)$"](around:${radius},${lat},${lng});
                  
                  // Anything with admission fees using different tags
                  way["admission"](around:${radius},${lat},${lng});
                  rel["admission"](around:${radius},${lat},${lng});
                  
                  // Places with opening hours (often indicates restricted access)
                  way["opening_hours"](around:${radius},${lat},${lng});
                  rel["opening_hours"](around:${radius},${lat},${lng});
                );
                out geom;
            `;

            try {
                const response = await fetch(overpassUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: 'data=' + encodeURIComponent(query)
                });

                const data = await response.json();
                console.log('Special areas data:', data.elements?.length || 0, 'elements');
                return data;
                
            } catch (error) {
                console.error('Error querying special areas:', error);
                return null;
            }
        }

        // Display detailed OSM debug information
        function displayOSMDebugInfo(elements) {
            let debugInfo = `üîç OSM Debug Report\n\n`;
            debugInfo += `Found ${elements.length} total elements in your area:\n\n`;
            
            const categorizedElements = {
                'Botanical Gardens': [],
                'Tourism/Attractions': [],
                'Parks/Recreation': [],
                'Fee-based Areas': [],
                'Access Restricted': [],
                'Roads/Walkways': [],
                'Other': []
            };
            
            elements.forEach(element => {
                const tags = element.tags || {};
                const name = tags.name || 'Unnamed';
                
                if (tags.leisure === 'garden' || (tags.name && tags.name.toLowerCase().includes('garden'))) {
                    categorizedElements['Botanical Gardens'].push({name, tags, element});
                } else if (tags.tourism) {
                    categorizedElements['Tourism/Attractions'].push({name, tags, element});
                } else if (tags.fee === 'yes' || tags.admission) {
                    categorizedElements['Fee-based Areas'].push({name, tags, element});
                } else if (tags.access === 'private' || tags.access === 'no' || tags.access === 'customers') {
                    categorizedElements['Access Restricted'].push({name, tags, element});
                } else if (tags.leisure === 'park' || tags.landuse === 'recreation_ground') {
                    categorizedElements['Parks/Recreation'].push({name, tags, element});
                } else if (tags.highway) {
                    categorizedElements['Roads/Walkways'].push({name, tags, element});
                } else {
                    categorizedElements['Other'].push({name, tags, element});
                }
            });
            
            for (const [category, items] of Object.entries(categorizedElements)) {
                if (items.length > 0) {
                    debugInfo += `üìç ${category} (${items.length}):\n`;
                    items.slice(0, 5).forEach(item => { // Show first 5 items
                        debugInfo += `  ‚Ä¢ ${item.name}\n`;
                        debugInfo += `    Tags: ${Object.entries(item.tags).map(([k,v]) => `${k}=${v}`).join(', ')}\n`;
                    });
                    if (items.length > 5) {
                        debugInfo += `  ... and ${items.length - 5} more\n`;
                    }
                    debugInfo += `\n`;
                }
            }
            
            // Specific analysis for VanDusen Gardens
            const vandusenElements = elements.filter(el => 
                el.tags?.name && el.tags.name.toLowerCase().includes('vandusen')
            );
            
            if (vandusenElements.length > 0) {
                debugInfo += `üåø VanDusen Gardens Analysis:\n`;
                vandusenElements.forEach(el => {
                    debugInfo += `  ‚Ä¢ Name: ${el.tags.name}\n`;
                    debugInfo += `  ‚Ä¢ All tags: ${JSON.stringify(el.tags, null, 2)}\n`;
                });
                debugInfo += `\n`;
            }
            
            debugInfo += `üí° If VanDusen Gardens shows as green (walkable), it means OSM data doesn't include proper restriction tags like fee=yes or access=private.`;
            
            // Show in a scrollable dialog
            const textarea = document.createElement('textarea');
            textarea.value = debugInfo;
            textarea.style.width = '80vw';
            textarea.style.height = '60vh';
            textarea.style.fontFamily = 'monospace';
            textarea.style.fontSize = '12px';
            
            const modal = document.createElement('div');
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100%';
            modal.style.height = '100%';
            modal.style.backgroundColor = 'rgba(0,0,0,0.8)';
            modal.style.display = 'flex';
            modal.style.alignItems = 'center';
            modal.style.justifyContent = 'center';
            modal.style.zIndex = '10000';
            
            const container = document.createElement('div');
            container.style.backgroundColor = 'white';
            container.style.padding = '20px';
            container.style.borderRadius = '8px';
            container.style.maxWidth = '90vw';
            container.style.maxHeight = '90vh';
            container.style.overflow = 'auto';
            
            const closeButton = document.createElement('button');
            closeButton.textContent = '‚úï Close';
            closeButton.style.marginBottom = '10px';
            closeButton.onclick = () => document.body.removeChild(modal);
            
            container.appendChild(closeButton);
            container.appendChild(textarea);
            modal.appendChild(container);
            document.body.appendChild(modal);
        }

        // Calculate distance between two points in meters using Haversine formula
        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 6371e3; // Earth's radius in meters
            const œÜ1 = lat1 * Math.PI/180;
            const œÜ2 = lat2 * Math.PI/180;
            const ŒîœÜ = (lat2-lat1) * Math.PI/180;
            const ŒîŒª = (lng2-lng1) * Math.PI/180;

            const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
                      Math.cos(œÜ1) * Math.cos(œÜ2) *
                      Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c; // Distance in meters
        }

        // Keyboard shortcuts for easier testing
        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'c') {
                clearGrid();
                e.preventDefault();
            }
            if (e.key.toLowerCase() === 'g') {
                generateGrid();
                e.preventDefault();
            }
        });

        // Initialize with default coordinates
        document.getElementById('latitude').value = defaultCoords.lat;
        document.getElementById('longitude').value = defaultCoords.lng;

        // Welcome message
        console.log('üó∫Ô∏è Walkable Areas Grid Test loaded');
        console.log('');
        console.log('üìã Instructions:');
        console.log('1. Enter your coordinates or click "Use My Location"');
        console.log('2. Click "Load Map" to visualize your area');
        console.log('3. Click "Generate Grid" to create the test grid');
        console.log('4. Click grid cells to cycle through: Unknown ‚Üí Walkable ‚Üí Non-walkable');
        console.log('');
        console.log('‚å®Ô∏è Keyboard shortcuts: C=clear, G=generate');
        console.log('');
        console.log('This test simulates how your dog walking app would analyze walkable areas!');
    </script>
</body>
</html> 