<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Walkable Areas Grid Test</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        h1 {
            margin-bottom: 24px;
            color: #1f2937;
        }

        .controls {
            display: flex;
            gap: 16px;
            margin-bottom: 24px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        label {
            font-size: 14px;
            font-weight: 500;
            color: #374151;
        }

        input, select, button {
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
        }

        button {
            background: #4f46e5;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s;
        }

        button:hover {
            background: #4338ca;
        }

        .map-container {
            position: relative;
            width: 100%;
            height: 600px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            overflow: hidden;
            background: #f9fafb;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 1000;
        }

        .grid-cell {
            position: absolute;
            border: 2px solid rgba(79, 70, 229, 0.4);
            background: rgba(79, 70, 229, 0.15);
            transition: all 0.2s;
            cursor: pointer;
            pointer-events: auto;
        }

        .grid-cell.walkable {
            background: rgba(34, 197, 94, 0.6);
            border: 2px solid rgba(22, 163, 74, 0.9);
        }

        .grid-cell.non-walkable {
            background: rgba(239, 68, 68, 0.6);
            border: 2px solid rgba(220, 38, 38, 0.9);
        }

        .grid-cell.restricted {
            background: rgba(168, 85, 247, 0.6);
            border: 2px solid rgba(147, 51, 234, 0.9);
        }

        .grid-cell.unknown {
            background: rgba(156, 163, 175, 0.4);
            border: 2px solid rgba(107, 114, 128, 0.7);
        }

        .grid-cell:hover {
            opacity: 0.8;
            transform: scale(1.02);
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-top: 16px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.2);
        }

        .info-panel {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
            margin-top: 20px;
        }

        .info-panel h3 {
            margin-bottom: 8px;
            color: #1e293b;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 16px;
            margin-top: 12px;
        }

        .stat {
            text-align: center;
            padding: 12px;
            background: white;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #1e293b;
        }

        .stat-label {
            font-size: 12px;
            color: #64748b;
            margin-top: 4px;
        }

        .instructions {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 24px;
        }

        .instructions h3 {
            color: #92400e;
            margin-bottom: 8px;
        }

        .instructions ul {
            color: #92400e;
            margin-left: 20px;
        }

        .instructions li {
            margin-bottom: 4px;
        }

        .keyboard-shortcuts {
            background: #eff6ff;
            border: 1px solid #3b82f6;
            border-radius: 8px;
            padding: 12px;
            margin-top: 16px;
            font-size: 12px;
        }

        .keyboard-shortcuts strong {
            color: #1e40af;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .map-container {
                height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üó∫Ô∏è Walkable Areas Grid Test</h1>
        
        <div class="instructions">
            <h3>üìã How to Use This Test</h3>
            <ul>
                <li>Enter your coordinates or click "üìç Use My Location"</li>
                <li>Click "üó∫Ô∏è Load Map" to visualize your area</li>
                <li>Click "‚¨ú Generate Grid" to create the test grid</li>
                <li>Click grid cells to cycle through: Unknown ‚Üí Walkable ‚Üí Non-walkable</li>
                <li>Observe how coverage percentage changes as you classify areas</li>
            </ul>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="latitude">Your Latitude:</label>
                <input type="number" id="latitude" step="0.000001" placeholder="e.g., 40.7128" />
            </div>
            
            <div class="control-group">
                <label for="longitude">Your Longitude:</label>
                <input type="number" id="longitude" step="0.000001" placeholder="e.g., -74.0060" />
            </div>
            
            <div class="control-group">
                <label for="grid-size">Grid Size:</label>
                <select id="grid-size">
                    <option value="15">15x15</option>
                    <option value="20">20x20</option>
                    <option value="25" selected>25x25</option>
                    <option value="30">30x30</option>
                    <option value="40">40x40</option>
                    <option value="50">50x50</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="radius">Radius (meters):</label>
                <input type="number" id="radius" value="500" min="100" max="2000" step="50" />
            </div>
            
            <button onclick="getCurrentLocation()">üìç Use My Location</button>
            <button onclick="showLocationHelp()">‚ùì Need Coordinates?</button>
            <button onclick="loadMap()">üó∫Ô∏è Load Map</button>
            <button onclick="generateGrid()">‚¨ú Generate Grid</button>
            <button onclick="autoDetectWalkable()" id="autoDetectBtn">ü§ñ Auto-Detect Walkable Areas</button>
            <button onclick="showRestrictedAreas()" id="restrictedBtn">üö´ Show Restricted Areas</button>
            <button id="testWalkBtn" onclick="startTestWalk()">Start Test Walk</button>
            <button id="debugBtn" onclick="debugOSMData()">Debug OSM Data</button>
            <button onclick="toggleRawDataOverlay()" id="rawDataBtn">üìä Show Raw OSM Data</button>
            <button onclick="toggleEnhancedDetection()" id="enhancedBtn">üéØ Enhanced Detection</button>
            <button onclick="debugSpecificCell()" id="debugCellBtn">üî¨ Debug Cell Intersection</button>
            <button onclick="toggleSegmentMode()" id="segmentBtn">üõ£Ô∏è Segment Mode (Prototype)</button>
            <button id="gameBtn" onclick="toggleGameMode()" style="background: #9333ea; color: white;">üéÆ Simple Game Mode</button>
            <button onclick="clearGrid()">üßπ Clear Grid</button>
            <button id="clearBlocksBtn" onclick="clearBlockFills()" style="background-color: #dc2626; color: white; border: none; padding: 10px 15px; margin: 5px; border-radius: 5px; cursor: pointer;">üóëÔ∏è Clear Blocks</button>
            <button id="debugBlocksBtn" onclick="debugBlockDetection()" style="background-color: #8b5cf6; color: white; border: none; padding: 10px 15px; margin: 5px; border-radius: 5px; cursor: pointer;">üîç Debug Blocks</button>
        </div>

        <div class="map-container">
            <div id="map">
                <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #6b7280; font-size: 18px; text-align: center; flex-direction: column; gap: 16px;">
                    <div style="font-size: 48px;">üìç</div>
                    <div>Enter coordinates and click "Load Map" to begin</div>
                    <div style="font-size: 14px; color: #9ca3af;">This simulates how your dog walking app would analyze walkable areas</div>
                </div>
            </div>
            <div class="grid-overlay" id="grid-overlay"></div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(34, 197, 94, 0.3); border-color: rgba(34, 197, 94, 0.6);"></div>
                <span>Walkable (roads, sidewalks, parks)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(239, 68, 68, 0.3); border-color: rgba(239, 68, 68, 0.6);"></div>
                <span>Non-walkable (private property, buildings)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(156, 163, 175, 0.2); border-color: rgba(156, 163, 175, 0.4);"></div>
                <span>Unknown/Unclassified</span>
            </div>
        </div>

        <div class="info-panel">
            <h3>üìä Grid Analysis</h3>
            <p>Click on grid cells to classify areas. This simulates how the app would analyze walkable vs non-walkable areas in your residential neighborhood.</p>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(34, 197, 94, 0.6); border: 2px solid rgba(22, 163, 74, 0.9);"></div>
                    <span>Walkable Areas</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(239, 68, 68, 0.6); border: 2px solid rgba(220, 38, 38, 0.9);"></div>
                    <span>Non-walkable Areas</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(168, 85, 247, 0.6); border: 2px solid rgba(147, 51, 234, 0.9);"></div>
                    <span>Restricted Areas</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(156, 163, 175, 0.4); border: 2px solid rgba(107, 114, 128, 0.7);"></div>
                    <span>Unknown Areas</span>
                </div>
            </div>

            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="walkable-count">0</div>
                    <div class="stat-label">Walkable Cells</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="non-walkable-count">0</div>
                    <div class="stat-label">Non-walkable Cells</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="restricted-count">0</div>
                    <div class="stat-label">Restricted Cells</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="unknown-count">0</div>
                    <div class="stat-label">Unknown Cells</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="coverage-percent">0%</div>
                    <div class="stat-label">Area Coverage</div>
                </div>
            </div>

            <div class="keyboard-shortcuts">
                <strong>Keyboard Shortcuts:</strong> Press <strong>1</strong> then click = Walkable | <strong>2</strong> then click = Non-walkable | <strong>3</strong> then click = Unknown | <strong>C</strong> = Clear grid | <strong>G</strong> = Generate grid | <strong>R</strong> = Toggle raw OSM data | <strong>E</strong> = Enhanced detection
            </div>
        </div>
    </div>

    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        let map = null;
        let gridCells = [];
        let currentState = 'walkable'; // Current classification mode

        // Sample coordinates (New York City) - user will replace with their location
        const defaultCoords = { lat: 40.7128, lng: -74.0060 };

        function getCurrentLocation() {
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = 'üì° Getting location...';
            button.disabled = true;

            console.log('Attempting to get location...');

            if (!navigator.geolocation) {
                alert('Geolocation is not supported by this browser.');
                button.textContent = originalText;
                button.disabled = false;
                return;
            }

            // Check if page is served over HTTPS or localhost
            const isSecure = location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
            if (!isSecure) {
                alert('Geolocation requires HTTPS or localhost. Please enter coordinates manually or serve the page over HTTPS.');
                button.textContent = originalText;
                button.disabled = false;
                return;
            }

            const options = {
                enableHighAccuracy: true,
                timeout: 10000, // 10 seconds
                maximumAge: 60000 // 1 minute
            };

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    console.log('Location success:', position);
                    document.getElementById('latitude').value = position.coords.latitude.toFixed(6);
                    document.getElementById('longitude').value = position.coords.longitude.toFixed(6);
                    button.textContent = '‚úÖ Location found!';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.disabled = false;
                    }, 2000);
                    console.log(`Location obtained: ${position.coords.latitude}, ${position.coords.longitude}`);
                },
                (error) => {
                    console.error('Geolocation error:', error);
                    let errorMessage = 'Could not get your location. ';
                    
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                            errorMessage += 'Permission denied. Please allow location access and try again.';
                            break;
                        case error.POSITION_UNAVAILABLE:
                            errorMessage += 'Location information unavailable.';
                            break;
                        case error.TIMEOUT:
                            errorMessage += 'Location request timed out.';
                            break;
                        default:
                            errorMessage += 'An unknown error occurred.';
                            break;
                    }
                    
                    errorMessage += '\n\nPlease enter coordinates manually or try again.';
                    alert(errorMessage);
                    
                    button.textContent = '‚ùå Location failed';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.disabled = false;
                    }, 3000);
                },
                options
            );
        }

        function showLocationHelp() {
            const helpMessage = `üìç How to get your coordinates:

Method 1: Google Maps
‚Ä¢ Open maps.google.com
‚Ä¢ Right-click on your location
‚Ä¢ Click the coordinates that appear
‚Ä¢ Copy them here

Method 2: GPS Coordinates app
‚Ä¢ Search "GPS coordinates" in your app store
‚Ä¢ Use any GPS app on your phone

Method 3: Manual entry
‚Ä¢ If you know your approximate address, search online for "[your address] coordinates"

The format should be:
Latitude: Like 40.7128 (North/South)
Longitude: Like -74.0060 (East/West)`;

            alert(helpMessage);
        }

        function loadMap() {
            const lat = parseFloat(document.getElementById('latitude').value);
            const lng = parseFloat(document.getElementById('longitude').value);

            if (isNaN(lat) || isNaN(lng)) {
                alert('Please enter valid coordinates.');
                return;
            }

            // Validate coordinates are reasonable
            if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                alert('Please enter valid coordinates (latitude: -90 to 90, longitude: -180 to 180).');
                return;
            }

            // Clear the map div and create a new map
            const mapDiv = document.getElementById('map');
            mapDiv.innerHTML = '';
            
            // Destroy existing map if it exists
            if (map !== null) {
                map.remove();
                map = null;
            }

            // Create new Leaflet map
            map = L.map('map').setView([lat, lng], 16);

            // Add OpenStreetMap tiles
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            // Add a marker at the center location
            L.marker([lat, lng])
                .addTo(map)
                .bindPopup(`üìç Your Location<br>${lat.toFixed(4)}, ${lng.toFixed(4)}`)
                .openPopup();

            // Add a circle to show the radius
            const radius = parseInt(document.getElementById('radius').value);
            L.circle([lat, lng], {
                color: '#4f46e5',
                fillColor: '#4f46e5',
                fillOpacity: 0.1,
                radius: radius
            }).addTo(map).bindPopup(`Search radius: ${radius}m`);

            console.log(`Real map loaded for coordinates: ${lat}, ${lng} with ${radius}m radius`);
        }

        function generateGrid() {
            const gridSize = parseInt(document.getElementById('grid-size').value);
            const radius = parseInt(document.getElementById('radius').value);
            const gridOverlay = document.getElementById('grid-overlay');
            
            // Clear existing grid
            gridOverlay.innerHTML = '';
            gridCells = [];

            if (!map) {
                alert('Please load the map first!');
                return;
            }

            // Get the actual map container dimensions
            const mapContainer = map.getContainer();
            const containerWidth = mapContainer.clientWidth;
            const containerHeight = mapContainer.clientHeight;
            
            // Use the smaller dimension to ensure square cells that fit in the view
            const smallerDimension = Math.min(containerWidth, containerHeight);
            const cellPixelSize = smallerDimension / gridSize;
            
            // Calculate offsets to center the grid
            const leftOffset = (containerWidth - smallerDimension) / 2;
            const topOffset = (containerHeight - smallerDimension) / 2;

            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell unknown';
                    
                    // Position cells as perfect squares using pixel dimensions
                    cell.style.left = `${leftOffset + (col * cellPixelSize)}px`;
                    cell.style.top = `${topOffset + (row * cellPixelSize)}px`;
                    cell.style.width = `${cellPixelSize}px`;
                    cell.style.height = `${cellPixelSize}px`;
                    
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.dataset.state = 'unknown';
                    
                    // Add tooltip
                    cell.title = `Cell ${row},${col} - Click to classify`;
                    
                    cell.addEventListener('click', () => toggleCellState(cell));
                    
                    gridOverlay.appendChild(cell);
                    gridCells.push(cell);
                }
            }

            updateStats();
            console.log(`Generated ${gridSize}x${gridSize} SQUARE grid (${gridCells.length} cells, ${cellPixelSize.toFixed(1)}px each)`);
            
            // Show success message
            const originalText = event.target.textContent;
            event.target.textContent = `‚úÖ ${gridCells.length} square cells created!`;
            setTimeout(() => {
                event.target.textContent = originalText;
            }, 2000);
        }

        function toggleCellState(cell) {
            const currentState = cell.dataset.state;
            let newState;
            
            // Cycle through states: unknown -> walkable -> non-walkable -> restricted -> unknown
            switch (currentState) {
                case 'unknown':
                    newState = 'walkable';
                    break;
                case 'walkable':
                    newState = 'non-walkable';
                    break;
                case 'non-walkable':
                    newState = 'restricted';
                    break;
                case 'restricted':
                    newState = 'unknown';
                    break;
                default:
                    newState = 'unknown';
            }
            
            cell.dataset.state = newState;
            cell.className = `grid-cell ${newState}`;
            cell.title = `Cell ${cell.dataset.row},${cell.dataset.col} - ${newState.replace('-', ' ')}`;
            
            updateStats();

            // Visual feedback
            cell.style.transform = 'scale(1.1)';
            setTimeout(() => {
                cell.style.transform = '';
            }, 150);
        }

        function updateStats() {
            const walkable = gridCells.filter(cell => cell.dataset.state === 'walkable').length;
            const nonWalkable = gridCells.filter(cell => cell.dataset.state === 'non-walkable').length;
            const restricted = gridCells.filter(cell => cell.dataset.state === 'restricted').length;
            const unknown = gridCells.filter(cell => cell.dataset.state === 'unknown').length;
            const total = gridCells.length;
            
            const classified = walkable + nonWalkable + restricted;
            const coveragePercent = total > 0 ? Math.round((classified / total) * 100) : 0;
            
            document.getElementById('walkable-count').textContent = walkable;
            document.getElementById('non-walkable-count').textContent = nonWalkable;
            document.getElementById('restricted-count').textContent = restricted;
            document.getElementById('unknown-count').textContent = unknown;
            document.getElementById('coverage-percent').textContent = `${coveragePercent}%`;
        }

        function clearGrid() {
            if (gridCells.length === 0) {
                alert('No grid to clear. Generate a grid first!');
                return;
            }

            gridCells.forEach(cell => {
                cell.dataset.state = 'unknown';
                cell.className = 'grid-cell unknown';
                cell.title = `Cell ${cell.dataset.row},${cell.dataset.col} - Click to classify`;
            });
            updateStats();
            
            // Visual feedback
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = '‚úÖ Grid cleared!';
            setTimeout(() => {
                button.textContent = originalText;
            }, 1500);
        }

        // Auto-detect walkable areas using OpenStreetMap data
        async function autoDetectWalkable() {
            if (!map) {
                alert('Please load the map first!');
                return;
            }

            if (gridCells.length === 0) {
                alert('Please generate a grid first!');
                return;
            }

            const button = document.getElementById('autoDetectBtn');
            const originalText = button.textContent;
            button.textContent = 'üîç Analyzing area...';
            button.disabled = true;

            try {
                const center = map.getCenter();
                const radius = parseInt(document.getElementById('radius').value);
                
                console.log(`Querying walkable areas around ${center.lat}, ${center.lng} within ${radius}m`);
                
                // Query both walkable AND restricted areas
                const [walkableData, restrictedData] = await Promise.all([
                    queryWalkableAreas(center.lat, center.lng, radius),
                    queryRestrictedAreas(center.lat, center.lng, radius)
                ]);
                
                // Combine the data
                const combinedData = {
                    elements: [
                        ...(walkableData?.elements || []),
                        ...(restrictedData?.elements || [])
                    ]
                };
                
                // Apply the data to existing grid
                if (combinedData.elements.length > 0) {
                    classifyGridWithOSMData(combinedData);
                    button.textContent = '‚úÖ Detection complete!';
                } else {
                    button.textContent = '‚ùå No data found';
                }
                
            } catch (error) {
                console.error('Auto-detection error:', error);
                button.textContent = '‚ùå Detection failed';
            }
            
            setTimeout(() => {
                button.textContent = originalText;
                button.disabled = false;
            }, 3000);
        }

        // Query OpenStreetMap Overpass API for walkable areas
        async function queryWalkableAreas(lat, lng, radius) {
            const overpassUrl = 'https://overpass-api.de/api/interpreter';
            
            // Enhanced Overpass query for walkable areas with access restrictions
            const query = `
                [out:json][timeout:25];
                (
                  // Roads and highways (walkable, not private)
                  way["highway"~"^(primary|secondary|tertiary|residential|unclassified|service|footway|path|pedestrian|cycleway)$"]["access"!="private"]["access"!="no"](around:${radius},${lat},${lng});
                  
                  // Sidewalks specifically  
                  way["footway"="sidewalk"]["access"!="private"](around:${radius},${lat},${lng});
                  
                  // Parks and recreational areas (exclude fee-based and private)
                  way["leisure"~"^(park|playground|recreation_ground|garden)$"]["access"!="private"]["fee"!="yes"](around:${radius},${lat},${lng});
                  rel["leisure"~"^(park|playground|recreation_ground|garden)$"]["access"!="private"]["fee"!="yes"](around:${radius},${lat},${lng});
                  
                  // Public paths and trails (explicitly exclude private)
                  way["highway"="track"]["access"!="private"]["access"!="no"](around:${radius},${lat},${lng});
                );
                out geom;
            `;

            try {
                const response = await fetch(overpassUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: 'data=' + encodeURIComponent(query)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('OSM Data received:', data.elements?.length || 0, 'elements');
                return data;
                
            } catch (error) {
                console.error('Error querying OpenStreetMap:', error);
                return null;
            }
        }

        // Classify grid cells based on OSM data
        function classifyGridWithOSMData(osmData) {
            if (!osmData || !osmData.elements) {
                console.error('No OSM data to process');
                return;
            }

            const bounds = map.getBounds();
            const gridSize = parseInt(document.getElementById('grid-size').value);
            
            let classifiedCount = 0;
            
            console.log(`\nüîç Classification Method: ${enhancedDetectionEnabled ? 'ENHANCED GEOMETRIC INTERSECTION' : 'CENTER-POINT + RADIUS'}`);
            
            gridCells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                
                let isWalkable, isRestricted, detectionInfo = '';
                
                if (enhancedDetectionEnabled) {
                    // ENHANCED: Use geometric intersection with grid cell boundaries
                    const cellBounds = getGridCellBounds(row, col, gridSize, bounds);
                    
                    const walkableResult = checkGridCellIntersectsWalkableAreas(cellBounds, osmData.elements);
                    const restrictedResult = checkGridCellIntersectsRestrictedAreas(cellBounds, osmData.elements);
                    
                    isWalkable = walkableResult.intersects;
                    isRestricted = restrictedResult.intersects;
                    
                    if (walkableResult.intersects) {
                        detectionInfo = ` - intersects with ${walkableResult.feature} (${walkableResult.type})`;
                    } else if (restrictedResult.intersects) {
                        detectionInfo = ` - intersects with ${restrictedResult.feature} (${restrictedResult.type})`;
                    }
                    
                } else {
                    // ORIGINAL: Use center point + radius detection
                    const latRange = bounds.getNorthEast().lat - bounds.getSouthWest().lat;
                    const lngRange = bounds.getNorthEast().lng - bounds.getSouthWest().lng;
                    
                    const cellLat = bounds.getSouthWest().lat + (latRange * (1 - (row + 0.5) / gridSize));
                    const cellLng = bounds.getSouthWest().lng + (lngRange * (col + 0.5) / gridSize);
                    
                    isWalkable = checkPointInWalkableAreas(cellLat, cellLng, osmData.elements);
                    isRestricted = checkPointInRestrictedAreas(cellLat, cellLng, osmData.elements);
                    
                    detectionInfo = ` - center point at ${cellLat.toFixed(6)}, ${cellLng.toFixed(6)}`;
                }
                
                // PRIORITY: Walkable areas take precedence over restricted areas
                // If there's any public walkable access, the cell is considered walkable
                if (isWalkable) {
                    cell.dataset.state = 'walkable';
                    cell.className = 'grid-cell walkable';
                    cell.title = `Cell ${row},${col} - walkable (${enhancedDetectionEnabled ? 'geometric' : 'radius'} detection)${detectionInfo}`;
                    classifiedCount++;
                    console.log(`Cell ${row},${col} marked as WALKABLE${detectionInfo}`);
                } else if (isRestricted) {
                    cell.dataset.state = 'restricted';
                    cell.className = 'grid-cell restricted';
                    cell.title = `Cell ${row},${col} - restricted (${enhancedDetectionEnabled ? 'geometric' : 'radius'} detection)${detectionInfo}`;
                    classifiedCount++;
                    console.log(`Cell ${row},${col} marked as RESTRICTED${detectionInfo}`);
                } else {
                    cell.dataset.state = 'non-walkable';
                    cell.className = 'grid-cell non-walkable';
                    cell.title = `Cell ${row},${col} - non-walkable (${enhancedDetectionEnabled ? 'geometric' : 'radius'} detection)`;
                }
            });
            
            console.log(`\nüìä Auto-classified ${classifiedCount} cells as walkable/restricted out of ${gridCells.length} total using ${enhancedDetectionEnabled ? 'GEOMETRIC' : 'CENTER-POINT'} detection`);
            updateStats();
        }

        // Check if a point is within any walkable areas
        function checkPointInWalkableAreas(pointLat, pointLng, osmElements) {
            // First, find all restricted areas for proximity checking
            const restrictedAreas = osmElements.filter(element => {
                const tags = element.tags || {};
                return tags.fee === 'yes' || 
                       tags.access === 'private' || 
                       tags.access === 'no' || 
                       tags.access === 'customers' ||
                       tags.landuse === 'military' || 
                       tags.dog === 'no' ||
                       tags.admission ||
                       (tags.leisure === 'garden' && tags.tourism) ||
                       (tags.tourism === 'attraction' && tags.leisure === 'garden') ||
                       (tags.name && tags.name.toLowerCase().includes('botanical')) ||
                       (tags.name && tags.name.toLowerCase().includes('vandusen')) ||
                       (tags.tourism === 'zoo') ||
                       (tags.tourism === 'museum') ||
                       (tags.tourism === 'theme_park');
            });
            
            for (const element of osmElements) {
                if (element.type === 'way' && element.geometry) {
                    // Only check walkable elements (not restricted ones)
                    const tags = element.tags || {};
                    const isRestrictedElement = tags.fee === 'yes' || tags.access === 'private' || 
                                              tags.access === 'no' || tags.access === 'customers' ||
                                              tags.landuse === 'military' || tags.dog === 'no';
                    
                    if (!isRestrictedElement) {
                        // Check if this path is inside or very close to a restricted area
                        const isNearRestrictedArea = checkIfPathNearRestrictedAreas(element, restrictedAreas);
                        
                        if (!isNearRestrictedArea) {
                            // Check proximity to walkable infrastructure
                            for (const node of element.geometry) {
                                const distance = calculateDistance(pointLat, pointLng, node.lat, node.lon);
                                
                                // Different detection radii based on infrastructure type
                                let detectionRadius = 30; // Default 30m
                                
                                if (tags.highway === 'footway' || tags.highway === 'pedestrian') {
                                    detectionRadius = 20; // Footways and pedestrian areas
                                } else if (tags.highway === 'residential' || tags.highway === 'service') {
                                    detectionRadius = 50; // Residential streets (likely have sidewalks)
                                } else if (tags.highway && tags.highway.match(/^(primary|secondary|tertiary)$/)) {
                                    detectionRadius = 60; // Major roads (wider with sidewalks)
                                } else if (tags.leisure === 'park') {
                                    detectionRadius = 40; // Parks
                                }
                                
                                if (distance < detectionRadius) {
                                    console.log(`Found walkable: ${tags.name || tags.highway || 'unnamed'} at ${distance.toFixed(1)}m (radius: ${detectionRadius}m)`);
                                    return true;
                                }
                            }
                        } else {
                            console.log(`Skipping path near restricted area: ${tags.name || tags.highway || 'unnamed'}`);
                        }
                    }
                }
            }
            return false;
        }

        // Check if a point is within any restricted areas
        function checkPointInRestrictedAreas(pointLat, pointLng, osmElements) {
            for (const element of osmElements) {
                if (element.type === 'way' && element.geometry) {
                    // Enhanced restricted element detection
                    const tags = element.tags || {};
                    const isRestrictedElement = 
                        tags.fee === 'yes' || 
                        tags.access === 'private' || 
                        tags.access === 'no' || 
                        tags.access === 'customers' ||
                        tags.landuse === 'military' || 
                        tags.dog === 'no' ||
                        // Additional fee-based attraction tags
                        tags.admission ||
                        (tags.leisure === 'garden' && tags.tourism) || // Botanical gardens that are tourist attractions
                        (tags.tourism === 'attraction' && tags.leisure === 'garden') ||
                        (tags.name && tags.name.toLowerCase().includes('botanical')) ||
                        (tags.name && tags.name.toLowerCase().includes('vandusen')) ||
                        // Common patterns for fee-based venues
                        (tags.tourism === 'zoo') ||
                        (tags.tourism === 'museum') ||
                        (tags.tourism === 'theme_park');
                    
                    if (isRestrictedElement) {
                        console.log(`Found restricted element: ${tags.name || 'Unnamed'} with tags:`, tags);
                        // Check proximity to restricted areas
                        for (const node of element.geometry) {
                            const distance = calculateDistance(pointLat, pointLng, node.lat, node.lon);
                            // If within 15 meters of a restricted area, consider it restricted
                            if (distance < 15) {
                                console.log(`Point ${pointLat.toFixed(6)}, ${pointLng.toFixed(6)} is ${distance.toFixed(1)}m from restricted area: ${tags.name || 'Unnamed'}`);
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        // Show restricted areas that are excluded from walkable detection
        async function showRestrictedAreas() {
            if (!map) {
                alert('Please load the map first!');
                return;
            }

            const button = document.getElementById('restrictedBtn');
            const originalText = button.textContent;
            button.textContent = 'üîç Finding restrictions...';
            button.disabled = true;

            try {
                const center = map.getCenter();
                const radius = parseInt(document.getElementById('radius').value);
                
                // Query for restricted areas
                const restrictedData = await queryRestrictedAreas(center.lat, center.lng, radius);
                
                if (restrictedData && restrictedData.elements && restrictedData.elements.length > 0) {
                    displayRestrictedAreasInfo(restrictedData.elements);
                    button.textContent = '‚úÖ Restrictions found!';
                } else {
                    alert('No specifically tagged restricted areas found in this area.\n\nThis could mean:\n‚Ä¢ Area has good public access\n‚Ä¢ OSM data may not have detailed access tags\n‚Ä¢ Your pay-to-enter garden might not be tagged with fee=yes');
                    button.textContent = 'ü§∑ No restrictions found';
                }
                
            } catch (error) {
                console.error('Error finding restricted areas:', error);
                button.textContent = '‚ùå Query failed';
            }
            
            setTimeout(() => {
                button.textContent = originalText;
                button.disabled = false;
            }, 3000);
        }

        // Query OpenStreetMap for restricted/fee-based areas
        async function queryRestrictedAreas(lat, lng, radius) {
            const overpassUrl = 'https://overpass-api.de/api/interpreter';
            
            const query = `
                [out:json][timeout:25];
                (
                  // Fee-based areas (like your pay-to-enter garden)
                  way["fee"="yes"](around:${radius},${lat},${lng});
                  rel["fee"="yes"](around:${radius},${lat},${lng});
                  
                  // Private access areas
                  way["access"="private"](around:${radius},${lat},${lng});
                  way["access"="no"](around:${radius},${lat},${lng});
                  
                  // Customer-only areas
                  way["access"="customers"](around:${radius},${lat},${lng});
                  rel["access"="customers"](around:${radius},${lat},${lng});
                  
                  // Military or restricted areas
                  way["landuse"="military"](around:${radius},${lat},${lng});
                  
                  // Dog-restricted areas
                  way["dog"="no"](around:${radius},${lat},${lng});
                );
                out geom;
            `;

            try {
                const response = await fetch(overpassUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: 'data=' + encodeURIComponent(query)
                });

                const data = await response.json();
                console.log('Restricted areas data:', data.elements?.length || 0, 'elements');
                return data;
                
            } catch (error) {
                console.error('Error querying restricted areas:', error);
                return null;
            }
        }

        // Display information about restricted areas found
        function displayRestrictedAreasInfo(restrictedElements) {
            let restrictionTypes = {};
            
            restrictedElements.forEach(element => {
                const tags = element.tags || {};
                
                if (tags.fee === 'yes') {
                    restrictionTypes['Fee-based (pay-to-enter)'] = (restrictionTypes['Fee-based (pay-to-enter)'] || 0) + 1;
                }
                if (tags.access === 'private') {
                    restrictionTypes['Private access'] = (restrictionTypes['Private access'] || 0) + 1;
                }
                if (tags.access === 'no') {
                    restrictionTypes['No access'] = (restrictionTypes['No access'] || 0) + 1;
                }
                if (tags.access === 'customers') {
                    restrictionTypes['Customers only'] = (restrictionTypes['Customers only'] || 0) + 1;
                }
                if (tags.landuse === 'military') {
                    restrictionTypes['Military/restricted'] = (restrictionTypes['Military/restricted'] || 0) + 1;
                }
                if (tags.dog === 'no') {
                    restrictionTypes['No dogs allowed'] = (restrictionTypes['No dogs allowed'] || 0) + 1;
                }
            });
            
            let message = `üö´ Found ${restrictedElements.length} restricted areas:\n\n`;
            
            for (const [type, count] of Object.entries(restrictionTypes)) {
                message += `‚Ä¢ ${type}: ${count}\n`;
            }
            
            message += `\nüí° These areas are excluded from walkable detection because they have access restrictions that matter for everyday dog walking.`;
            
            alert(message);
        }

        // Debug function to show all OSM data in the area
        async function debugOSMData() {
            if (!map) {
                alert('Please load the map first!');
                return;
            }

            const button = document.getElementById('debugBtn');
            const originalText = button.textContent;
            button.textContent = 'üîç Gathering data...';
            button.disabled = true;

            try {
                const center = map.getCenter();
                const radius = parseInt(document.getElementById('radius').value);
                
                // Query for ALL relevant areas (walkable AND restricted)
                const [walkableData, restrictedData] = await Promise.all([
                    queryWalkableAreas(center.lat, center.lng, radius),
                    queryRestrictedAreas(center.lat, center.lng, radius)
                ]);
                
                // Also query specifically for botanical gardens, museums, etc.
                const specialData = await querySpecialAreas(center.lat, center.lng, radius);
                
                // Combine and analyze
                const allElements = [
                    ...(walkableData?.elements || []),
                    ...(restrictedData?.elements || []),
                    ...(specialData?.elements || [])
                ];
                
                displayOSMDebugInfo(allElements);
                button.textContent = '‚úÖ Data analyzed!';
                
            } catch (error) {
                console.error('Debug error:', error);
                button.textContent = '‚ùå Debug failed';
            }
            
            setTimeout(() => {
                button.textContent = originalText;
                button.disabled = false;
            }, 3000);
        }

        // Query for special fee-based areas that might use different tags
        async function querySpecialAreas(lat, lng, radius) {
            const overpassUrl = 'https://overpass-api.de/api/interpreter';
            
            const query = `
                [out:json][timeout:25];
                (
                  // Botanical gardens, museums, attractions
                  way["leisure"="garden"](around:${radius},${lat},${lng});
                  way["tourism"~"^(attraction|museum|zoo|theme_park)$"](around:${radius},${lat},${lng});
                  rel["leisure"="garden"](around:${radius},${lat},${lng});
                  rel["tourism"~"^(attraction|museum|zoo|theme_park)$"](around:${radius},${lat},${lng});
                  
                  // Anything with admission fees using different tags
                  way["admission"](around:${radius},${lat},${lng});
                  rel["admission"](around:${radius},${lat},${lng});
                  
                  // Places with opening hours (often indicates restricted access)
                  way["opening_hours"](around:${radius},${lat},${lng});
                  rel["opening_hours"](around:${radius},${lat},${lng});
                );
                out geom;
            `;

            try {
                const response = await fetch(overpassUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: 'data=' + encodeURIComponent(query)
                });

                const data = await response.json();
                console.log('Special areas data:', data.elements?.length || 0, 'elements');
                return data;
                
            } catch (error) {
                console.error('Error querying special areas:', error);
                return null;
            }
        }

        // Display detailed OSM debug information
        function displayOSMDebugInfo(elements) {
            let debugInfo = `üîç OSM Debug Report\n\n`;
            debugInfo += `Found ${elements.length} total elements in your area:\n\n`;
            
            const categorizedElements = {
                'Botanical Gardens': [],
                'Tourism/Attractions': [],
                'Parks/Recreation': [],
                'Fee-based Areas': [],
                'Access Restricted': [],
                'Roads/Walkways': [],
                'Other': []
            };
            
            elements.forEach(element => {
                const tags = element.tags || {};
                const name = tags.name || 'Unnamed';
                
                if (tags.leisure === 'garden' || (tags.name && tags.name.toLowerCase().includes('garden'))) {
                    categorizedElements['Botanical Gardens'].push({name, tags, element});
                } else if (tags.tourism) {
                    categorizedElements['Tourism/Attractions'].push({name, tags, element});
                } else if (tags.fee === 'yes' || tags.admission) {
                    categorizedElements['Fee-based Areas'].push({name, tags, element});
                } else if (tags.access === 'private' || tags.access === 'no' || tags.access === 'customers') {
                    categorizedElements['Access Restricted'].push({name, tags, element});
                } else if (tags.leisure === 'park' || tags.landuse === 'recreation_ground') {
                    categorizedElements['Parks/Recreation'].push({name, tags, element});
                } else if (tags.highway) {
                    categorizedElements['Roads/Walkways'].push({name, tags, element});
                } else {
                    categorizedElements['Other'].push({name, tags, element});
                }
            });
            
            for (const [category, items] of Object.entries(categorizedElements)) {
                if (items.length > 0) {
                    debugInfo += `üìç ${category} (${items.length}):\n`;
                    items.slice(0, 5).forEach(item => { // Show first 5 items
                        debugInfo += `  ‚Ä¢ ${item.name}\n`;
                        debugInfo += `    Tags: ${Object.entries(item.tags).map(([k,v]) => `${k}=${v}`).join(', ')}\n`;
                    });
                    if (items.length > 5) {
                        debugInfo += `  ... and ${items.length - 5} more\n`;
                    }
                    debugInfo += `\n`;
                }
            }
            
            // Specific analysis for VanDusen Gardens
            const vandusenElements = elements.filter(el => 
                el.tags?.name && el.tags.name.toLowerCase().includes('vandusen')
            );
            
            if (vandusenElements.length > 0) {
                debugInfo += `üåø VanDusen Gardens Analysis:\n`;
                vandusenElements.forEach(el => {
                    debugInfo += `  ‚Ä¢ Name: ${el.tags.name}\n`;
                    debugInfo += `  ‚Ä¢ All tags: ${JSON.stringify(el.tags, null, 2)}\n`;
                });
                debugInfo += `\n`;
            }
            
            debugInfo += `üí° If VanDusen Gardens shows as green (walkable), it means OSM data doesn't include proper restriction tags like fee=yes or access=private.`;
            
            // Show in a scrollable dialog
            const textarea = document.createElement('textarea');
            textarea.value = debugInfo;
            textarea.style.width = '80vw';
            textarea.style.height = '60vh';
            textarea.style.fontFamily = 'monospace';
            textarea.style.fontSize = '12px';
            
            const modal = document.createElement('div');
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100%';
            modal.style.height = '100%';
            modal.style.backgroundColor = 'rgba(0,0,0,0.8)';
            modal.style.display = 'flex';
            modal.style.alignItems = 'center';
            modal.style.justifyContent = 'center';
            modal.style.zIndex = '10000';
            
            const container = document.createElement('div');
            container.style.backgroundColor = 'white';
            container.style.padding = '20px';
            container.style.borderRadius = '8px';
            container.style.maxWidth = '90vw';
            container.style.maxHeight = '90vh';
            container.style.overflow = 'auto';
            
            const closeButton = document.createElement('button');
            closeButton.textContent = '‚úï Close';
            closeButton.style.marginBottom = '10px';
            closeButton.onclick = () => document.body.removeChild(modal);
            
            container.appendChild(closeButton);
            container.appendChild(textarea);
            modal.appendChild(container);
            document.body.appendChild(modal);
        }

        // Calculate distance between two points in meters using Haversine formula
        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 6371e3; // Earth's radius in meters
            const œÜ1 = lat1 * Math.PI/180;
            const œÜ2 = lat2 * Math.PI/180;
            const ŒîœÜ = (lat2-lat1) * Math.PI/180;
            const ŒîŒª = (lng2-lng1) * Math.PI/180;

            const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
                      Math.cos(œÜ1) * Math.cos(œÜ2) *
                      Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c; // Distance in meters
        }

        // Variables to store raw data overlays
        let rawDataLayers = [];
        let rawDataVisible = false;
        let enhancedDetectionEnabled = false;
        
        // Segment mode variables
        let segmentMode = false;
        let segmentLayers = [];
        let walkedSegments = new Map(); // segmentId -> {progress: 0-100, completed: false}
        let subSegments = []; // Store subdivided segments for granular tracking
        
        // Test walk variables
        let isTestWalking = false;
        let testWalkMarker = null;
        let testWalkPath = [];
        let testWalkTimer = null;
        let testWalkIndex = 0;
        let testWalker = null;
        let isWalking = false;

        // Gamification tracking
        let discoveredParks = new Set(); // Park IDs that have been visited
        let completedBlocks = new Set(); // Block IDs that have been completed (walked around)
        let parkMarkers = []; // Park discovery markers
        let blockPolygons = []; // Completed block polygons

        // Toggle raw OSM data overlay on the map
        async function toggleRawDataOverlay() {
            if (!map) {
                alert('Please load the map first!');
                return;
            }

            const button = document.getElementById('rawDataBtn');
            
            if (rawDataVisible) {
                // Remove existing overlays
                clearRawDataOverlays();
                button.textContent = 'üìä Show Raw OSM Data';
                rawDataVisible = false;
                return;
            }

            const originalText = button.textContent;
            button.textContent = 'üîç Loading OSM data...';
            button.disabled = true;

            try {
                const center = map.getCenter();
                const radius = parseInt(document.getElementById('radius').value);
                
                console.log('Loading raw OSM data for visualization...');
                
                // Get both walkable and restricted areas data
                const [walkableData, restrictedData, specialData] = await Promise.all([
                    queryWalkableAreas(center.lat, center.lng, radius),
                    queryRestrictedAreas(center.lat, center.lng, radius),
                    querySpecialAreas(center.lat, center.lng, radius)
                ]);
                
                // Create overlays for different types of data
                if (walkableData?.elements) {
                    createDataOverlay(walkableData.elements, 'walkable', '#22c55e', 'Walkable areas from OSM');
                }
                
                if (restrictedData?.elements) {
                    createDataOverlay(restrictedData.elements, 'restricted', '#ef4444', 'Restricted areas from OSM');
                }
                
                if (specialData?.elements) {
                    createDataOverlay(specialData.elements, 'special', '#a855f7', 'Special areas (gardens, tourism)');
                }
                
                button.textContent = '‚úÖ Raw data visible';
                rawDataVisible = true;
                
                // Add legend for raw data
                showRawDataLegend();
                
            } catch (error) {
                console.error('Error loading raw data:', error);
                button.textContent = '‚ùå Failed to load';
            }
            
            setTimeout(() => {
                if (rawDataVisible) {
                    button.textContent = 'üóëÔ∏è Hide Raw OSM Data';
                }
                button.disabled = false;
            }, 2000);
        }

        // Create overlay for specific data type
        function createDataOverlay(elements, type, color, description) {
            const layerGroup = L.layerGroup();
            let addedFeatures = 0;
            
            elements.forEach((element, index) => {
                if (element.type === 'way' && element.geometry) {
                    const coordinates = element.geometry.map(node => [node.lat, node.lon]);
                    
                    if (coordinates.length >= 2) {
                        const tags = element.tags || {};
                        const name = tags.name || `Unnamed ${type} feature`;
                        
                        // Create polyline for ways
                        const polyline = L.polyline(coordinates, {
                            color: color,
                            weight: 3,
                            opacity: 0.7
                        });
                        
                        // Create popup with detailed information
                        const tagsList = Object.entries(tags)
                            .map(([key, value]) => `<strong>${key}:</strong> ${value}`)
                            .join('<br>');
                        
                        polyline.bindPopup(`
                            <div style="max-width: 300px;">
                                <h4 style="margin: 0 0 8px 0; color: ${color};">${name}</h4>
                                <p style="margin: 0 0 8px 0; font-size: 12px; color: #666;">
                                    ${description} ‚Ä¢ ID: ${element.id}
                                </p>
                                <div style="max-height: 200px; overflow-y: auto; font-size: 11px;">
                                    ${tagsList}
                                </div>
                            </div>
                        `);
                        
                        layerGroup.addLayer(polyline);
                        addedFeatures++;
                    }
                } else if (element.type === 'relation' && element.members) {
                    // Handle relations (like parks that are relations)
                    const tags = element.tags || {};
                    const name = tags.name || `Unnamed ${type} relation`;
                    
                    // For relations, we'll just show a marker at the center if we can calculate it
                    // This is simplified - in reality, you'd need to resolve the relation members
                    if (element.center) {
                        const marker = L.circleMarker([element.center.lat, element.center.lon], {
                            color: color,
                            fillColor: color,
                            fillOpacity: 0.5,
                            radius: 8
                        });
                        
                        const tagsList = Object.entries(tags)
                            .map(([key, value]) => `<strong>${key}:</strong> ${value}`)
                            .join('<br>');
                        
                        marker.bindPopup(`
                            <div style="max-width: 300px;">
                                <h4 style="margin: 0 0 8px 0; color: ${color};">${name}</h4>
                                <p style="margin: 0 0 8px 0; font-size: 12px; color: #666;">
                                    ${description} (Relation) ‚Ä¢ ID: ${element.id}
                                </p>
                                <div style="max-height: 200px; overflow-y: auto; font-size: 11px;">
                                    ${tagsList}
                                </div>
                            </div>
                        `);
                        
                        layerGroup.addLayer(marker);
                        addedFeatures++;
                    }
                }
            });
            
            if (addedFeatures > 0) {
                layerGroup.addTo(map);
                rawDataLayers.push(layerGroup);
                console.log(`Added ${addedFeatures} ${type} features to map`);
            } else {
                console.log(`No ${type} features found to display`);
            }
        }

        // Clear all raw data overlays
        function clearRawDataOverlays() {
            rawDataLayers.forEach(layer => {
                map.removeLayer(layer);
            });
            rawDataLayers = [];
            hideRawDataLegend();
        }

        // Show legend for raw data overlays
        function showRawDataLegend() {
            // Remove existing raw data legend if it exists
            hideRawDataLegend();
            
            const legendDiv = document.createElement('div');
            legendDiv.id = 'raw-data-legend';
            legendDiv.innerHTML = `
                <div style="position: absolute; top: 10px; right: 10px; background: white; padding: 12px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.3); z-index: 1000; font-size: 12px; min-width: 200px;">
                    <h4 style="margin: 0 0 8px 0; color: #1f2937;">üó∫Ô∏è Raw OSM Data</h4>
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                        <div style="width: 16px; height: 3px; background: #22c55e;"></div>
                        <span>Walkable areas</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                        <div style="width: 16px; height: 3px; background: #ef4444;"></div>
                        <span>Restricted areas</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                        <div style="width: 16px; height: 3px; background: #a855f7;"></div>
                        <span>Special areas</span>
                    </div>
                    <div style="font-size: 10px; color: #666; border-top: 1px solid #eee; padding-top: 6px;">
                        Click any line/marker for details
                    </div>
                </div>
            `;
            
            document.querySelector('.map-container').appendChild(legendDiv);
        }

        // Hide raw data legend
        function hideRawDataLegend() {
            const legend = document.getElementById('raw-data-legend');
            if (legend) {
                legend.remove();
            }
        }

        // Toggle enhanced geometric detection
        function toggleEnhancedDetection() {
            enhancedDetectionEnabled = !enhancedDetectionEnabled;
            const button = document.getElementById('enhancedBtn');
            
            if (enhancedDetectionEnabled) {
                button.textContent = 'üéØ Enhanced: ON';
                button.style.background = '#22c55e';
                console.log('‚úÖ Enhanced geometric detection enabled - will check grid cell boundaries vs OSM geometry');
            } else {
                button.textContent = 'üéØ Enhanced Detection';
                button.style.background = '#4f46e5';
                console.log('‚ùå Enhanced detection disabled - using center-point method');
            }
        }

        // Calculate grid cell boundary coordinates - FIXED to match visual grid positioning
        function getGridCellBounds(row, col, gridSize, bounds) {
            const northeast = bounds.getNorthEast();
            const southwest = bounds.getSouthWest();
            
            const latRange = northeast.lat - southwest.lat;
            const lngRange = northeast.lng - southwest.lng;
            
            // Get the map container dimensions (same as visual grid calculation)
            const mapContainer = map.getContainer();
            const containerWidth = mapContainer.clientWidth;
            const containerHeight = mapContainer.clientHeight;
            
            // Use the smaller dimension to match visual grid (creates square cells)
            const smallerDimension = Math.min(containerWidth, containerHeight);
            
            // Calculate how much of the map bounds the grid actually covers
            const gridWidthRatio = smallerDimension / containerWidth;
            const gridHeightRatio = smallerDimension / containerHeight;
            
            // Calculate the actual lat/lng range covered by the grid (not full bounds)
            const gridLatRange = latRange * gridHeightRatio;
            const gridLngRange = lngRange * gridWidthRatio;
            
            // Calculate centering offsets in geographic coordinates
            const latOffset = (latRange - gridLatRange) / 2;
            const lngOffset = (lngRange - gridLngRange) / 2;
            
            // Calculate the southwest corner of the grid area (not the map bounds)
            const gridSouthwest = {
                lat: southwest.lat + latOffset,
                lng: southwest.lng + lngOffset
            };
            
            // Calculate cell boundaries within the actual grid area
            const cellLatMin = gridSouthwest.lat + (gridLatRange * (1 - (row + 1) / gridSize));
            const cellLatMax = gridSouthwest.lat + (gridLatRange * (1 - row / gridSize));
            const cellLngMin = gridSouthwest.lng + (gridLngRange * col / gridSize);
            const cellLngMax = gridSouthwest.lng + (gridLngRange * (col + 1) / gridSize);
            
            return {
                north: cellLatMax,
                south: cellLatMin,
                east: cellLngMax,
                west: cellLngMin,
                center: {
                    lat: (cellLatMin + cellLatMax) / 2,
                    lng: (cellLngMin + cellLngMax) / 2
                },
                // Debug info
                debug: {
                    gridWidthRatio: gridWidthRatio.toFixed(3),
                    gridHeightRatio: gridHeightRatio.toFixed(3),
                    containerDimensions: `${containerWidth}x${containerHeight}`,
                    smallerDimension: smallerDimension
                }
            };
        }

        // Check if a line segment intersects with a rectangle (grid cell)
        function lineIntersectsRect(x1, y1, x2, y2, rectWest, rectSouth, rectEast, rectNorth) {
            // Check if line is completely inside rectangle
            if (pointInRect(x1, y1, rectWest, rectSouth, rectEast, rectNorth) || 
                pointInRect(x2, y2, rectWest, rectSouth, rectEast, rectNorth)) {
                return true;
            }
            
            // Check line intersection with each edge of rectangle
            return (
                lineIntersectsLine(x1, y1, x2, y2, rectWest, rectSouth, rectEast, rectSouth) || // bottom edge
                lineIntersectsLine(x1, y1, x2, y2, rectEast, rectSouth, rectEast, rectNorth) || // right edge
                lineIntersectsLine(x1, y1, x2, y2, rectEast, rectNorth, rectWest, rectNorth) || // top edge
                lineIntersectsLine(x1, y1, x2, y2, rectWest, rectNorth, rectWest, rectSouth)    // left edge
            );
        }

        // Check if point is inside rectangle
        function pointInRect(x, y, west, south, east, north) {
            return x >= west && x <= east && y >= south && y <= north;
        }

        // Check if two line segments intersect
        function lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) {
            const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (Math.abs(denom) < 1e-10) return false; // parallel lines
            
            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
            
            return t >= 0 && t <= 1 && u >= 0 && u <= 1;
        }

        // Enhanced check for walkable areas using geometric intersection
        function checkGridCellIntersectsWalkableAreas(cellBounds, osmElements) {
            // First, find all restricted areas for proximity checking
            const restrictedAreas = osmElements.filter(element => {
                const tags = element.tags || {};
                return tags.fee === 'yes' || 
                       tags.access === 'private' || 
                       tags.access === 'no' || 
                       tags.access === 'customers' ||
                       tags.landuse === 'military' || 
                       tags.dog === 'no' ||
                       tags.admission ||
                       (tags.leisure === 'garden' && tags.tourism) ||
                       (tags.tourism === 'attraction' && tags.leisure === 'garden') ||
                       (tags.name && tags.name.toLowerCase().includes('botanical')) ||
                       (tags.name && tags.name.toLowerCase().includes('vandusen')) ||
                       (tags.tourism === 'zoo') ||
                       (tags.tourism === 'museum') ||
                       (tags.tourism === 'theme_park');
            });
            
            for (const element of osmElements) {
                if (element.type === 'way' && element.geometry && element.geometry.length >= 2) {
                    const tags = element.tags || {};
                    const isRestrictedElement = tags.fee === 'yes' || tags.access === 'private' || 
                                              tags.access === 'no' || tags.access === 'customers' ||
                                              tags.landuse === 'military' || tags.dog === 'no';
                    
                    if (!isRestrictedElement) {
                        // Check if this path is inside or very close to a restricted area
                        const isNearRestrictedArea = checkIfPathNearRestrictedAreas(element, restrictedAreas);
                        
                        if (!isNearRestrictedArea) {
                            // Check if any segment of this OSM way intersects with the grid cell
                            for (let i = 0; i < element.geometry.length - 1; i++) {
                                const node1 = element.geometry[i];
                                const node2 = element.geometry[i + 1];
                                
                                if (lineIntersectsRect(
                                    node1.lon, node1.lat, 
                                    node2.lon, node2.lat,
                                    cellBounds.west, cellBounds.south, 
                                    cellBounds.east, cellBounds.north
                                )) {
                                    console.log(`Geometric intersection found: ${tags.name || tags.highway || 'unnamed'} crosses grid cell`);
                                    return {
                                        intersects: true,
                                        feature: tags.name || tags.highway || 'unnamed feature',
                                        type: tags.highway || tags.leisure || 'unknown'
                                    };
                                }
                            }
                            
                            // Also check if any nodes are within the cell bounds
                            for (const node of element.geometry) {
                                if (pointInRect(node.lon, node.lat, cellBounds.west, cellBounds.south, cellBounds.east, cellBounds.north)) {
                                    console.log(`Point intersection found: ${tags.name || tags.highway || 'unnamed'} has nodes in grid cell`);
                                    return {
                                        intersects: true,
                                        feature: tags.name || tags.highway || 'unnamed feature',
                                        type: tags.highway || tags.leisure || 'unknown'
                                    };
                                }
                            }
                        } else {
                            console.log(`Skipping path near restricted area: ${tags.name || tags.highway || 'unnamed'}`);
                        }
                    }
                }
            }
            return { intersects: false };
        }

        // Check if a path is near any restricted areas (to exclude VanDusen internal paths)
        function checkIfPathNearRestrictedAreas(pathElement, restrictedAreas) {
            if (!pathElement.geometry || restrictedAreas.length === 0) return false;
            
            const pathTags = pathElement.tags || {};
            
            // Special handling for paths that might be inside fee-based attractions
            for (const restrictedArea of restrictedAreas) {
                if (!restrictedArea.geometry) continue;
                
                const restrictedTags = restrictedArea.tags || {};
                
                // Check if any point of the path is close to the restricted area
                for (const pathNode of pathElement.geometry) {
                    for (const restrictedNode of restrictedArea.geometry) {
                        const distance = calculateDistance(
                            pathNode.lat, pathNode.lon,
                            restrictedNode.lat, restrictedNode.lon
                        );
                        
                        // If path is within 50m of a restricted area, consider it part of that area
                        if (distance < 50) {
                            console.log(`Path ${pathTags.name || pathTags.highway || 'unnamed'} is ${distance.toFixed(1)}m from restricted area ${restrictedTags.name || 'unnamed'}`);
                            return true;
                        }
                    }
                }
            }
            
            return false;
        }

        // Enhanced check for restricted areas using geometric intersection
        function checkGridCellIntersectsRestrictedAreas(cellBounds, osmElements) {
            for (const element of osmElements) {
                if (element.type === 'way' && element.geometry && element.geometry.length >= 2) {
                    const tags = element.tags || {};
                    const isRestrictedElement = 
                        tags.fee === 'yes' || 
                        tags.access === 'private' || 
                        tags.access === 'no' || 
                        tags.access === 'customers' ||
                        tags.landuse === 'military' || 
                        tags.dog === 'no' ||
                        tags.admission ||
                        (tags.leisure === 'garden' && tags.tourism) ||
                        (tags.tourism === 'attraction' && tags.leisure === 'garden') ||
                        (tags.name && tags.name.toLowerCase().includes('botanical')) ||
                        (tags.name && tags.name.toLowerCase().includes('vandusen')) ||
                        (tags.tourism === 'zoo') ||
                        (tags.tourism === 'museum') ||
                        (tags.tourism === 'theme_park');
                    
                    if (isRestrictedElement) {
                        // Check geometric intersection
                        for (let i = 0; i < element.geometry.length - 1; i++) {
                            const node1 = element.geometry[i];
                            const node2 = element.geometry[i + 1];
                            
                            if (lineIntersectsRect(
                                node1.lon, node1.lat, 
                                node2.lon, node2.lat,
                                cellBounds.west, cellBounds.south, 
                                cellBounds.east, cellBounds.north
                            )) {
                                console.log(`Restricted area intersection found: ${tags.name || 'unnamed'} crosses grid cell`);
                                return {
                                    intersects: true,
                                    feature: tags.name || 'unnamed restricted area',
                                    type: tags.tourism || tags.leisure || 'restricted'
                                };
                            }
                        }
                        
                        // Check if any nodes are within the cell bounds
                        for (const node of element.geometry) {
                            if (pointInRect(node.lon, node.lat, cellBounds.west, cellBounds.south, cellBounds.east, cellBounds.north)) {
                                console.log(`Restricted area point found: ${tags.name || 'unnamed'} has nodes in grid cell`);
                                return {
                                    intersects: true,
                                    feature: tags.name || 'unnamed restricted area',
                                    type: tags.tourism || tags.leisure || 'restricted'
                                };
                            }
                        }
                    }
                }
            }
            return { intersects: false };
        }

        // Debug specific cell intersection
        async function debugSpecificCell() {
            if (!map || gridCells.length === 0) {
                alert('Please load map and generate grid first!');
                return;
            }

            const button = document.getElementById('debugCellBtn');
            const originalText = button.textContent;
            button.textContent = 'üî¨ Click a cell to debug...';
            button.style.background = '#f59e0b';

            // Add temporary click handler to grid cells
            const debugClickHandler = async (event) => {
                const cell = event.target;
                if (!cell.classList.contains('grid-cell')) return;

                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const gridSize = parseInt(document.getElementById('grid-size').value);

                console.log(`\nüî¨ DEBUGGING CELL ${row},${col}`);
                
                // Get cell bounds
                const bounds = map.getBounds();
                const cellBounds = getGridCellBounds(row, col, gridSize, bounds);
                
                console.log('Cell Bounds:', cellBounds);
                console.log('Grid Scaling Debug:', cellBounds.debug);
                
                // Get fresh OSM data for this area
                try {
                    button.textContent = 'üîç Analyzing intersection...';
                    
                    const center = map.getCenter();
                    const radius = parseInt(document.getElementById('radius').value);
                    const osmData = await queryWalkableAreas(center.lat, center.lng, radius);
                    
                    console.log(`Found ${osmData?.elements?.length || 0} OSM elements total`);
                    
                    // Check each OSM element against this specific cell
                    let intersectionCount = 0;
                    let walkableIntersections = [];
                    
                    if (osmData?.elements) {
                        osmData.elements.forEach((element, idx) => {
                            if (element.type === 'way' && element.geometry && element.geometry.length >= 2) {
                                const tags = element.tags || {};
                                const featureName = tags.name || tags.highway || `Element-${idx}`;
                                
                                // Check each line segment
                                for (let i = 0; i < element.geometry.length - 1; i++) {
                                    const node1 = element.geometry[i];
                                    const node2 = element.geometry[i + 1];
                                    
                                    const intersects = lineIntersectsRect(
                                        node1.lon, node1.lat, 
                                        node2.lon, node2.lat,
                                        cellBounds.west, cellBounds.south, 
                                        cellBounds.east, cellBounds.north
                                    );
                                    
                                    if (intersects) {
                                        intersectionCount++;
                                        walkableIntersections.push({
                                            feature: featureName,
                                            segment: i,
                                            from: `${node1.lat.toFixed(6)}, ${node1.lon.toFixed(6)}`,
                                            to: `${node2.lat.toFixed(6)}, ${node2.lon.toFixed(6)}`,
                                            tags: tags
                                        });
                                        console.log(`‚úÖ INTERSECTION ${intersectionCount}: ${featureName} segment ${i}`);
                                        console.log(`   From: ${node1.lat.toFixed(6)}, ${node1.lon.toFixed(6)}`);
                                        console.log(`   To: ${node2.lat.toFixed(6)}, ${node2.lon.toFixed(6)}`);
                                        console.log(`   Tags:`, tags);
                                    }
                                }
                            }
                        });
                    }
                    
                    // Show results
                    const currentState = cell.dataset.state;
                    console.log(`\nüìä CELL ${row},${col} ANALYSIS:`);
                    console.log(`   Current state: ${currentState}`);
                    console.log(`   Found ${intersectionCount} intersections with walkable features`);
                    console.log(`   Cell bounds: ${cellBounds.south.toFixed(6)} to ${cellBounds.north.toFixed(6)} lat, ${cellBounds.west.toFixed(6)} to ${cellBounds.east.toFixed(6)} lng`);
                    
                    if (intersectionCount > 0 && currentState !== 'walkable') {
                        console.log(`‚ö†Ô∏è  MISMATCH: Cell has ${intersectionCount} walkable intersections but is marked as "${currentState}"`);
                        
                        // Create detailed alert
                        let alertMessage = `üî¨ CELL ${row},${col} DEBUG RESULTS:\n\n`;
                        alertMessage += `Current state: ${currentState}\n`;
                        alertMessage += `Found ${intersectionCount} walkable intersections!\n\n`;
                        
                        if (walkableIntersections.length > 0) {
                            alertMessage += `Intersecting features:\n`;
                            walkableIntersections.slice(0, 3).forEach((intersection, idx) => {
                                alertMessage += `${idx + 1}. ${intersection.feature}\n`;
                            });
                            if (walkableIntersections.length > 3) {
                                alertMessage += `... and ${walkableIntersections.length - 3} more\n`;
                            }
                        }
                        
                        alertMessage += `\nThis suggests the intersection detection isn't working properly for this cell.`;
                        alert(alertMessage);
                    } else if (intersectionCount === 0 && currentState === 'walkable') {
                        alert(`üî¨ CELL ${row},${col}: No intersections found but marked as walkable.\nThis could be from center-point detection or restricted area logic.`);
                    } else {
                        alert(`üî¨ CELL ${row},${col}: ${intersectionCount} intersections found, state "${currentState}" appears correct.`);
                    }
                    
                } catch (error) {
                    console.error('Debug error:', error);
                    alert('Debug failed: ' + error.message);
                }
                
                // Remove click handlers and reset button
                gridCells.forEach(c => c.removeEventListener('click', debugClickHandler));
                button.textContent = originalText;
                button.style.background = '#4f46e5';
            };

            // Add click handlers to all grid cells
            gridCells.forEach(cell => {
                cell.addEventListener('click', debugClickHandler);
            });

            // Reset button after 30 seconds
            setTimeout(() => {
                gridCells.forEach(cell => cell.removeEventListener('click', debugClickHandler));
                if (button.textContent.includes('Click a cell')) {
                    button.textContent = originalText;
                    button.style.background = '#4f46e5';
                }
            }, 30000);
        }

        // Toggle segment visualization mode (Strava-style)
        async function toggleSegmentMode() {
            if (!map) {
                alert('Please load the map first!');
                return;
            }

            const button = document.getElementById('segmentBtn');
            
            if (segmentMode) {
                // Turn off segment mode
                clearSegmentOverlays();
                segmentMode = false;
                button.textContent = 'üõ£Ô∏è Segment Mode (Prototype)';
                button.style.background = '';
                console.log('‚ùå Segment mode disabled');
            } else {
                // Turn on segment mode
                segmentMode = true;
                button.textContent = 'üõ£Ô∏è Segment Mode: ON';
                button.style.background = '#3b82f6';
                button.disabled = true;
                
                console.log('‚úÖ Segment mode enabled - Loading walkable segments...');
                
                try {
                    await renderWalkableSegments();
                    button.disabled = false;
                    console.log('‚úÖ Segment visualization ready! Click segments to mark as walked.');
                } catch (error) {
                    console.error('‚ùå Error loading segments:', error);
                    button.disabled = false;
                    button.textContent = 'üõ£Ô∏è Segment Mode (ERROR)';
                    button.style.background = '#ef4444';
                }
            }
        }

        // Get the actual radius from the input field (in meters)
        function getRadiusFromInput() {
            const radiusInput = document.getElementById('radius');
            return parseInt(radiusInput.value) || 500; // Default to 500m if invalid
        }

        // Render all walkable segments as interactive polylines
        async function renderWalkableSegments() {
            const center = map.getCenter();
            const radius = getRadiusFromInput(); // Use actual input radius instead of map bounds
            
            console.log(`Loading walkable segments within ${radius}m of ${center.lat.toFixed(6)}, ${center.lng.toFixed(6)}`);
            
            // Get OSM data for walkable areas
            const osmData = await queryWalkableAreas(center.lat, center.lng, radius);
            if (!osmData || !osmData.elements) {
                throw new Error('Failed to load OSM data - no elements received');
            }
            
            console.log(`Received ${osmData.elements.length} OSM elements for segment processing`);
            
            // Clear existing segment overlays
            clearSegmentOverlays();
            
            // First pass: identify intersections and map sidewalks/roads more precisely
            const intersections = new Set();
            const allSidewalks = [];
            const allRoads = [];
            
            // Find intersections (nodes shared by multiple ways)
            const nodeUsage = new Map(); // nodeId -> count
            for (const element of osmData.elements) {
                if (element.type === 'way' && element.geometry) {
                    for (const node of element.geometry) {
                        const nodeId = `${node.lat.toFixed(6)},${node.lon.toFixed(6)}`;
                        nodeUsage.set(nodeId, (nodeUsage.get(nodeId) || 0) + 1);
                    }
                }
            }
            
            // Mark intersections (nodes used by 2+ ways)
            for (const [nodeId, count] of nodeUsage) {
                if (count >= 2) {
                    intersections.add(nodeId);
                }
            }
            
            // Collect all sidewalks and roads for better proximity detection
            for (const element of osmData.elements) {
                if (element.type === 'way' && element.geometry && element.geometry.length >= 2) {
                    const tags = element.tags || {};
                    
                    // Skip restricted elements
                    const isRestrictedElement = tags.fee === 'yes' || tags.access === 'private' || 
                                              tags.access === 'no' || tags.access === 'customers' ||
                                              tags.landuse === 'military' || tags.dog === 'no';
                    if (isRestrictedElement) continue;
                    
                    const isRoad = tags.highway && tags.highway.match(/^(primary|secondary|tertiary|residential|unclassified)$/);
                    const isSidewalk = tags.highway === 'footway' || tags.highway === 'sidewalk';
                    
                    if (isSidewalk) {
                        allSidewalks.push(element);
                    } else if (isRoad) {
                        allRoads.push(element);
                    }
                }
            }
            
            // Create segment overlays
            let segmentCount = 0;
            let filteredCount = 0;
            const restrictedAreas = osmData.elements.filter(element => {
                const tags = element.tags || {};
                return tags.fee === 'yes' || tags.access === 'private' || tags.access === 'no' || 
                       tags.access === 'customers' || tags.landuse === 'military' || tags.dog === 'no' ||
                       tags.admission || (tags.leisure === 'garden' && tags.tourism) ||
                       (tags.tourism === 'attraction' && tags.leisure === 'garden') ||
                       (tags.name && tags.name.toLowerCase().includes('botanical')) ||
                       (tags.name && tags.name.toLowerCase().includes('vandusen')) ||
                       (tags.tourism === 'zoo') || (tags.tourism === 'museum') || (tags.tourism === 'theme_park') ||
                       // Add business filtering
                       tags.amenity === 'fuel' || tags.amenity === 'gas_station' ||
                       tags.shop || tags.amenity === 'restaurant' || tags.amenity === 'fast_food' ||
                       tags.amenity === 'cafe' || tags.amenity === 'bank' || tags.amenity === 'pharmacy' ||
                       tags.building === 'commercial' || tags.landuse === 'commercial' ||
                       tags.landuse === 'retail' || tags.landuse === 'industrial' ||
                       // Gas station specific filtering
                       (tags.highway === 'service' && tags.service === 'driveway') ||
                       (tags.highway === 'service' && tags.service === 'parking_aisle') ||
                       (tags.highway === 'service' && tags.amenity) ||
                       (tags.highway === 'service' && tags.shop);
            });
            
            // Helper function to check if a road has a nearby sidewalk
            function hasNearbySidewalk(roadElement) {
                const roadCoords = roadElement.geometry.map(node => [node.lat, node.lon]);
                
                for (const sidewalk of allSidewalks) {
                    const sidewalkCoords = sidewalk.geometry.map(node => [node.lat, node.lon]);
                    
                    // Check if any point on the road is within 20m of any point on a sidewalk
                    // Reduced from 25m to be less aggressive near commercial areas
                    for (const roadCoord of roadCoords) {
                        for (const sidewalkCoord of sidewalkCoords) {
                            const distance = calculateDistance(
                                roadCoord[0], roadCoord[1],
                                sidewalkCoord[0], sidewalkCoord[1]
                            );
                            if (distance <= 20) { // Reduced proximity threshold
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            // Process each way individually
            for (const element of osmData.elements) {
                try {
                    if (element.type === 'way' && element.geometry && element.geometry.length >= 2) {
                        const tags = element.tags || {};
                        
                        // Skip restricted elements and businesses (more targeted filtering)
                        const isRestrictedElement = tags.fee === 'yes' || tags.access === 'private' || 
                                                  tags.access === 'no' || tags.access === 'customers' ||
                                                  tags.landuse === 'military' || tags.dog === 'no' ||
                                                  // Only filter actual business properties, not nearby roads
                                                  (tags.amenity === 'fuel' || tags.amenity === 'gas_station') ||
                                                  (tags.building === 'commercial' && !tags.highway) || // Commercial buildings only
                                                  (tags.landuse === 'commercial' && !tags.highway) || // Commercial land use only
                                                  (tags.landuse === 'retail' && !tags.highway) || // Retail land use only
                                                  (tags.landuse === 'industrial' && !tags.highway) || // Industrial land use only
                                                  // Gas station specific filtering - only service roads with direct business connection
                                                  (tags.highway === 'service' && tags.service === 'driveway') ||
                                                  (tags.highway === 'service' && tags.service === 'parking_aisle') ||
                                                  (tags.highway === 'service' && tags.amenity) || // Service road with any amenity
                                                  (tags.highway === 'service' && tags.shop); // Service road with any shop
                        
                        if (isRestrictedElement) continue;
                        
                        // Skip paths near restricted areas
                        const isNearRestrictedArea = checkIfPathNearRestrictedAreas(element, restrictedAreas);
                        if (isNearRestrictedArea) continue;
                        
                        // Initial check - only exclude ways that are completely outside radius
                        const coordinates = element.geometry.map(node => [node.lat, node.lon]);
                        const hasAnyPointInRadius = coordinates.some(coord => {
                            const distance = calculateDistance(center.lat, center.lng, coord[0], coord[1]);
                            return distance <= radius * 1.5; // Large buffer for initial filtering
                        });
                        
                        if (!hasAnyPointInRadius) {
                            filteredCount++;
                            continue;
                        }
                        
                        // Categorize walkable ways
                        const isRoad = tags.highway && tags.highway.match(/^(primary|secondary|tertiary|residential|unclassified)$/);
                        const isSidewalk = tags.highway === 'footway' || tags.highway === 'sidewalk';
                        const isPath = tags.highway === 'path' || tags.highway === 'pedestrian';
                        const isPark = tags.leisure === 'park';
                        
                        // Only include service roads that are genuine public laneways, not commercial driveways
                        const isService = tags.highway === 'service' && 
                                        !tags.access && // Must be public access
                                        tags.service !== 'driveway' && // Not a driveway
                                        tags.service !== 'parking_aisle' && // Not parking lot
                                        !tags.amenity && // Not associated with amenities like gas stations
                                        !tags.shop && // Not associated with shops
                                        (!tags.service || tags.service === 'alley'); // Only alleys or unspecified service roads
                        
                        if (!isRoad && !isSidewalk && !isPath && !isPark && !isService) continue;
                        
                        // Skip roads if there are sidewalks nearby (improved detection)
                        if (isRoad && hasNearbySidewalk(element)) {
                            console.log(`üö´ Skipping road ${tags.name || 'unnamed'} - sidewalk nearby`);
                            continue;
                        }
                        
                        // Split segments at intersections for visual appeal
                        const segmentChunks = splitAtIntersections(coordinates, intersections);
                        
                        // Further subdivide long segments (max 30m for better granularity) and merge tiny ones
                        const finalSegments = [];
                        for (const chunk of segmentChunks) {
                            const subChunks = subdivideSegmentByDistance(chunk, 30); // Smaller max length
                            finalSegments.push(...subChunks);
                        }
                        
                        // Merge tiny segments with adjacent ones
                        const mergedSegments = mergeTinySegments(finalSegments, 6); // Merge segments under 6m
                        
                        // Create polylines for each segment - now filter by radius AFTER subdivision
                        for (let chunkIndex = 0; chunkIndex < mergedSegments.length; chunkIndex++) {
                            const chunkCoords = mergedSegments[chunkIndex];
                            const segmentId = `segment_${element.id}_${chunkIndex}`;
                            
                            if (chunkCoords.length < 2) continue;
                            
                            // Check if this individual segment is within radius (after subdivision)
                            const segmentInRadius = chunkCoords.some(coord => {
                                const distance = calculateDistance(center.lat, center.lng, coord[0], coord[1]);
                                return distance <= radius;
                            });
                            
                            if (!segmentInRadius) continue; // Skip segments outside radius
                            
                            // Calculate actual segment length
                            let segmentLength = 0;
                            for (let i = 1; i < chunkCoords.length; i++) {
                                segmentLength += calculateDistance(
                                    chunkCoords[i-1][0], chunkCoords[i-1][1],
                                    chunkCoords[i][0], chunkCoords[i][1]
                                );
                            }
                            
                            // Skip very short segments (less than 5m after merging)
                            if (segmentLength < 5) continue;
                            
                            // Determine visual style
                            let color = '#94a3b8'; // Default gray (not walked)
                            let weight = 5; // Default weight
                            
                            if (isSidewalk || isRoad) {
                                weight = 7; // Thicker for main walkways
                            } else if (isPath || isPark) {
                                weight = 5; // Normal for paths/parks
                            } else if (isService) {
                                weight = 6; // Medium for service roads
                            }
                            
                            let opacity = 0.8;
                            
                            const walkData = walkedSegments.get(segmentId);
                            if (walkData && walkData.completed) {
                                // This segment has been completed
                                if (isSidewalk || isRoad || isService) {
                                    color = '#3b82f6'; // Blue for roads/sidewalks
                                } else if (isPath) {
                                    color = '#22c55e'; // Green for paths
                                } else if (isPark) {
                                    color = '#10b981'; // Emerald for parks
                                }
                                weight = weight + 2; // Even thicker when completed
                                opacity = 1.0;
                            }
                            
                            const polyline = L.polyline(chunkCoords, {
                                color: color,
                                weight: weight,
                                opacity: opacity,
                                lineJoin: 'round',
                                lineCap: 'round',
                                segmentId: segmentId,
                                segmentLength: segmentLength
                            });
                            
                            // Add click handler to mark as walked
                            polyline.on('click', () => {
                                markSegmentAsWalkedWithBlockCheck(segmentId, polyline, tags);
                            });
                            
                            // Add tooltip
                            const wayType = isSidewalk ? 'sidewalk' : isRoad ? 'road' : isPath ? 'path' : isPark ? 'park' : isService ? 'service' : 'walkway';
                            const name = tags.name || wayType;
                            const lengthText = `${Math.round(segmentLength)}m`;
                            const walkInfo = walkData ? 
                                (walkData.completed ? ' (COMPLETED)' : ` (${Math.round(walkData.progress)}% walked)`) : 
                                ' (not walked)';
                            
                            polyline.bindTooltip(`${name} [${lengthText}]${walkInfo}`, {
                                sticky: true,
                                direction: 'top'
                            });
                            
                            polyline.addTo(map);
                            segmentLayers.push(polyline);
                            segmentCount++;
                        }
                    }
                } catch (segmentError) {
                    console.log(`Error processing segment ${element.id}:`, segmentError);
                }
            }
            
            console.log(`‚úÖ Rendered ${segmentCount} walkable segments within ${radius}m radius`);
            console.log(`üö´ Filtered out ${filteredCount} segments outside radius`);
            console.log(`üîÑ Found ${intersections.size} intersections for segment splitting`);
            console.log(`üö∂ Prioritized ${allSidewalks.length} sidewalks over ${allRoads.length} roads`);
            console.log(`üè™ Filtered out businesses and commercial areas`);
            updateSegmentStats();
        }

        // Merge tiny segments with adjacent ones to reduce intersection artifacts
        function mergeTinySegments(segments, minLength) {
            if (segments.length <= 1) return segments;
            
            const merged = [];
            let currentSegment = segments[0];
            
            for (let i = 1; i < segments.length; i++) {
                const nextSegment = segments[i];
                
                // Calculate length of current segment
                let currentLength = 0;
                for (let j = 1; j < currentSegment.length; j++) {
                    currentLength += calculateDistance(
                        currentSegment[j-1][0], currentSegment[j-1][1],
                        currentSegment[j][0], currentSegment[j][1]
                    );
                }
                
                // If current segment is too short, merge with next
                if (currentLength < minLength && i < segments.length) {
                    // Merge currentSegment with nextSegment
                    // Remove duplicate connection point
                    const mergedCoords = [...currentSegment];
                    if (nextSegment.length > 1) {
                        mergedCoords.push(...nextSegment.slice(1));
                    }
                    currentSegment = mergedCoords;
                } else {
                    // Current segment is good, add it and move to next
                    merged.push(currentSegment);
                    currentSegment = nextSegment;
                }
            }
            
            // Add the final segment
            merged.push(currentSegment);
            
            return merged;
        }

        // Split segments at intersections for better visual appeal
        function splitAtIntersections(coordinates, intersections) {
            const segments = [];
            let currentSegment = [coordinates[0]];
            
            for (let i = 1; i < coordinates.length; i++) {
                const coord = coordinates[i];
                const nodeId = `${coord[0].toFixed(6)},${coord[1].toFixed(6)}`;
                
                currentSegment.push(coord);
                
                // If this is an intersection and we have a meaningful segment, split here
                if (intersections.has(nodeId) && currentSegment.length > 1) {
                    segments.push([...currentSegment]);
                    currentSegment = [coord]; // Start new segment with intersection point
                }
            }
            
            // Add the final segment if it has multiple points
            if (currentSegment.length > 1) {
                segments.push(currentSegment);
            }
            
            return segments.length > 0 ? segments : [coordinates];
        }

        // Subdivide segment by actual distance rather than coordinate count
        function subdivideSegmentByDistance(coordinates, maxDistanceMeters) {
            if (coordinates.length < 2) return [coordinates];
            
            const subSegments = [];
            let currentSegment = [coordinates[0]];
            let currentDistance = 0;
            
            for (let i = 1; i < coordinates.length; i++) {
                const prevPoint = coordinates[i - 1];
                const currentPoint = coordinates[i];
                
                // Calculate distance between consecutive points
                const stepDistance = calculateDistance(
                    prevPoint[0], prevPoint[1],
                    currentPoint[0], currentPoint[1]
                );
                
                currentDistance += stepDistance;
                currentSegment.push(currentPoint);
                
                // If we've exceeded max distance, start a new segment
                if (currentDistance >= maxDistanceMeters && currentSegment.length > 1) {
                    subSegments.push([...currentSegment]);
                    currentSegment = [currentPoint]; // Start new segment with this point
                    currentDistance = 0;
                }
            }
            
            // Add the final segment if it has multiple points
            if (currentSegment.length > 1) {
                subSegments.push(currentSegment);
            }
            
            return subSegments.length > 0 ? subSegments : [coordinates];
        }

        // Mark a segment as walked with persistence tracking
        function markSegmentAsWalked(segmentId, polyline, tags) {
            const walkData = walkedSegments.get(segmentId);
            
            if (walkData && walkData.completed) {
                // Unmark as walked
                walkedSegments.delete(segmentId);
                polyline.setStyle({
                    color: '#94a3b8', // Gray
                    weight: 6,
                    opacity: 0.8
                });
                console.log(`‚ùå Unmarked segment: ${tags.name || tags.highway || 'unnamed'}`);
            } else {
                // Mark as walked (manual click = instant completion)
                walkedSegments.set(segmentId, {
                    progress: 100,
                    completed: true,
                    touchPoints: [],
                    method: 'manual'
                });
                
                // Set color based on type
                let color = '#8b5cf6'; // Default purple
                if (tags.highway && tags.highway.match(/^(primary|secondary|tertiary|residential)/)) {
                    color = '#3b82f6'; // Blue for roads (includes sidewalks)
                } else if (tags.highway === 'footway' || tags.highway === 'path' || tags.highway === 'pedestrian') {
                    color = '#22c55e'; // Green for paths
                } else if (tags.leisure === 'park') {
                    color = '#10b981'; // Emerald for parks
                }
                
                polyline.setStyle({
                    color: color,
                    weight: 8,
                    opacity: 1.0
                });
                console.log(`‚úÖ Manually marked segment as completed: ${tags.name || tags.highway || 'unnamed'}`);
            }
            
            // Update tooltip
            const name = tags.name || tags.highway || 'Unnamed segment';
            const segmentLength = Math.round(polyline.options.segmentLength || 0);
            const walkInfo = walkedSegments.get(segmentId) ? ' (COMPLETED)' : ' (not walked)';
            polyline.setTooltipContent(`${name} [${segmentLength}m]${walkInfo}`);
            
            updateSegmentStats();
        }

        // Track GPS position along a segment for persistence
        function trackSegmentProgress(segmentId, polyline, userLat, userLng, tags) {
            const walkData = walkedSegments.get(segmentId) || {
                progress: 0, 
                completed: false, 
                touchPoints: [],
                method: 'gps'
            };
            
            if (walkData.completed) return; // Already completed
            
            const segmentLength = polyline.options.segmentLength || 0;
            const requiredDistance = Math.max(10, segmentLength * 0.10); // Need 10% of segment or minimum 10m
            
            // Add this GPS point to touch history
            walkData.touchPoints.push({lat: userLat, lng: userLng, timestamp: Date.now()});
            
            // Keep only recent touch points (last 30 seconds)
            const thirtySecondsAgo = Date.now() - 30000;
            walkData.touchPoints = walkData.touchPoints.filter(point => point.timestamp > thirtySecondsAgo);
            
            // Calculate total distance covered along this segment
            let totalDistance = 0;
            for (let i = 1; i < walkData.touchPoints.length; i++) {
                const prev = walkData.touchPoints[i-1];
                const curr = walkData.touchPoints[i];
                totalDistance += calculateDistance(prev.lat, prev.lng, curr.lat, curr.lng);
            }
            
            // Update progress
            walkData.progress = Math.min(100, (totalDistance / requiredDistance) * 100);
            
            // Check if segment is now completed
            if (walkData.progress >= 100 && !walkData.completed) {
                walkData.completed = true;
                
                // Update visual style to completed
                let color = '#22c55e'; // Default green for auto-completed
                if (tags.highway && tags.highway.match(/^(primary|secondary|tertiary|residential)/)) {
                    color = '#3b82f6'; // Blue for roads
                } else if (tags.leisure === 'park') {
                    color = '#10b981'; // Emerald for parks
                }
                
                polyline.setStyle({
                    color: color,
                    weight: 8,
                    opacity: 1.0
                });
                
                // Update tooltip
                const name = tags.name || tags.highway || 'Unnamed segment';
                const segmentLength = Math.round(polyline.options.segmentLength || 0);
                polyline.setTooltipContent(`${name} [${segmentLength}m] (COMPLETED)`);
                
                console.log(`üéâ Auto-completed segment: ${segmentId} (${Math.round(totalDistance)}m walked of ${Math.round(requiredDistance)}m required)`);
                updateSegmentStats();
            }
            
            walkedSegments.set(segmentId, walkData);
        }

        // Update segment statistics
        function updateSegmentStats() {
            const totalSegments = segmentLayers.length;
            const completedCount = Array.from(walkedSegments.values()).filter(data => data.completed).length;
            const inProgressCount = Array.from(walkedSegments.values()).filter(data => !data.completed && data.progress > 0).length;
            const percentage = totalSegments > 0 ? ((completedCount / totalSegments) * 100).toFixed(1) : 0;
            
            console.log(`üìä Segment Progress: ${completedCount}/${totalSegments} completed (${percentage}%), ${inProgressCount} in progress`);
            
            // Update UI if we have a stats div
            const statsDiv = document.querySelector('.stats');
            if (statsDiv && segmentMode) {
                statsDiv.innerHTML = `
                    <div><strong>Segment Coverage:</strong> ${completedCount}/${totalSegments} completed (${percentage}%)</div>
                    <div><strong>In Progress:</strong> ${inProgressCount} segments partially walked</div>
                    <div><strong>Mode:</strong> Individual 40m segments with persistence tracking</div>
                    <div><strong>Requirement:</strong> Walk 10% of segment length to complete</div>
                `;
            }
        }

        // Clear all segment overlays
        function clearSegmentOverlays() {
            segmentLayers.forEach(layer => {
                map.removeLayer(layer);
            });
            segmentLayers = [];
        }

        // Start the test walk simulation
        function startTestWalk() {
            if (isTestWalking) {
                // Stop current walk
                clearInterval(testWalkTimer);
                isTestWalking = false;
                testWalkIndex = 0;
                
                if (testWalkMarker) {
                    map.removeLayer(testWalkMarker);
                    testWalkMarker = null;
                }
                
                document.getElementById('testWalkBtn').textContent = 'Start Test Walk';
                document.getElementById('testWalkBtn').style.backgroundColor = '#22c55e';
                console.log('Test walk stopped');
                return;
            }
            
            // Start new walk
            testWalkPath = createTestWalkRoute();
            
            if (!testWalkPath || testWalkPath.length === 0) {
                console.log('No test route available');
                return;
            }
            
            isTestWalking = true;
            testWalkIndex = 0;
            
            document.getElementById('testWalkBtn').textContent = 'Stop Test Walk';
            document.getElementById('testWalkBtn').style.backgroundColor = '#ef4444';
            
            console.log(`Starting test walk with ${testWalkPath.length} waypoints`);
            
            // Start the walk animation
            testWalkTimer = setInterval(() => {
                if (testWalkIndex >= testWalkPath.length) {
                    // Walk completed
                    clearInterval(testWalkTimer);
                    isTestWalking = false;
                    document.getElementById('testWalkBtn').textContent = 'Start Test Walk';
                    document.getElementById('testWalkBtn').style.backgroundColor = '#22c55e';
                    console.log('Test walk completed!');
                    return;
                }
                
                const currentPos = testWalkPath[testWalkIndex];
                
                // Move or create the walker marker
                if (testWalkMarker) {
                    testWalkMarker.setLatLng(currentPos);
                } else {
                    testWalkMarker = L.marker(currentPos, {
                        icon: L.divIcon({
                            html: 'üö∂‚Äç‚ôÇÔ∏è',
                            className: 'test-walker',
                            iconSize: [20, 20],
                            iconAnchor: [10, 10]
                        })
                    });
                    testWalkMarker.addTo(map);
                }
                
                // Check for nearby segments and track progress (15m radius)
                const walkRadius = 15; // meters
                for (const layer of segmentLayers) {
                    const segmentCoords = layer.getLatLngs();
                    const segmentId = layer.options.segmentId;
                    
                    if (segmentId) {
                        // Check if any point in the segment is within walking radius
                        for (const coord of segmentCoords) {
                            const distance = calculateDistance(currentPos[0], currentPos[1], coord.lat, coord.lng);
                            if (distance <= walkRadius) {
                                // Track progress on this segment using persistence system
                                trackSegmentProgress(segmentId, layer, currentPos[0], currentPos[1], {});
                                break;
                            }
                        }
                    }
                }
                
                testWalkIndex++;
            }, 300); // Move every 300ms
        }

        // Create a test walk route that stays within the radius
        function createTestWalkRoute() {
            const center = map.getCenter();
            const bounds = map.getBounds();
            const radius = getRadiusFromInput() * 0.8; // Use 80% of radius to stay well within bounds
            
            console.log(`Creating test walk route within ${radius}m of center`);
            
            // Create 15-20 waypoints in a semi-random pattern within the radius
            const route = [];
            const numWaypoints = 15 + Math.floor(Math.random() * 6); // 15-20 waypoints
            
            // Start near center
            route.push([center.lat, center.lng]);
            
            let currentLat = center.lat;
            let currentLng = center.lng;
            
            for (let i = 1; i < numWaypoints; i++) {
                // Generate next waypoint within reasonable distance but staying in radius
                const maxStepDistance = Math.min(radius * 0.2, 150); // Max 150m steps or 20% of radius
                const stepDistance = 50 + Math.random() * (maxStepDistance - 50); // 50m to maxStepDistance
                const direction = Math.random() * 2 * Math.PI; // Random direction
                
                // Calculate next position
                const deltaLat = (stepDistance * Math.cos(direction)) / 111000; // ~111km per degree lat
                const deltaLng = (stepDistance * Math.sin(direction)) / (111000 * Math.cos(currentLat * Math.PI / 180));
                
                let nextLat = currentLat + deltaLat;
                let nextLng = currentLng + deltaLng;
                
                // Check if next position is within radius from center
                const distanceFromCenter = calculateDistance(center.lat, center.lng, nextLat, nextLng);
                
                if (distanceFromCenter > radius) {
                    // If outside radius, adjust waypoint to be within radius
                    const angleToCenter = Math.atan2(center.lat - currentLat, center.lng - currentLng);
                    const maxDistanceFromCurrent = radius - calculateDistance(center.lat, center.lng, currentLat, currentLng);
                    const safeDistance = Math.min(stepDistance, maxDistanceFromCurrent * 0.8);
                    
                    // Move in a direction that keeps us within the radius
                    const adjustedDirection = angleToCenter + (Math.random() - 0.5) * Math.PI * 0.5; // ¬±45¬∞ from center direction
                    
                    const adjustedDeltaLat = (safeDistance * Math.cos(adjustedDirection)) / 111000;
                    const adjustedDeltaLng = (safeDistance * Math.sin(adjustedDirection)) / (111000 * Math.cos(currentLat * Math.PI / 180));
                    
                    nextLat = currentLat + adjustedDeltaLat;
                    nextLng = currentLng + adjustedDeltaLng;
                }
                
                route.push([nextLat, nextLng]);
                currentLat = nextLat;
                currentLng = nextLng;
            }
            
            // End back near center for a nice loop
            route.push([center.lat + (Math.random() - 0.5) * 0.001, center.lng + (Math.random() - 0.5) * 0.001]);
            
            console.log(`Generated test route with ${route.length} waypoints, staying within ${radius}m radius`);
            return route;
        }

        // Old test walking functions removed - now using improved radius-constrained version in startTestWalk()

        // Keyboard shortcuts for easier testing
        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'c') {
                clearGrid();
                e.preventDefault();
            }
            if (e.key.toLowerCase() === 'g') {
                generateGrid();
                e.preventDefault();
            }
            if (e.key.toLowerCase() === 'r') {
                toggleRawDataOverlay();
                e.preventDefault();
            }
            if (e.key.toLowerCase() === 'e') {
                toggleEnhancedDetection();
                e.preventDefault();
            }
        });

        // Initialize with default coordinates
        document.getElementById('latitude').value = defaultCoords.lat;
        document.getElementById('longitude').value = defaultCoords.lng;

        // Welcome message
        console.log('üó∫Ô∏è Walkable Areas Grid Test loaded');
        console.log('');
        console.log('üìã Instructions:');
        console.log('1. Enter your coordinates or click "Use My Location"');
        console.log('2. Click "Load Map" to visualize your area');
        console.log('3. Click "Generate Grid" to create the test grid');
        console.log('4. Click grid cells to cycle through: Unknown ‚Üí Walkable ‚Üí Non-walkable');
        console.log('');
        console.log('‚å®Ô∏è Keyboard shortcuts: C=clear, G=generate');
        console.log('');
        console.log('This test simulates how your dog walking app would analyze walkable areas!');

        // === SIMPLIFIED GAMIFICATION SYSTEM ===
        // Simplified approach: Roads with sidewalks + Parks for discovery
        
        // Modify the segment button to use simplified rendering
        document.getElementById('segmentBtn').onclick = async function() {
            if (segmentMode) {
                clearSegmentOverlays();
                this.textContent = 'üó∫Ô∏è Segment Mode: OFF';
                this.style.backgroundColor = '#6b7280';
                segmentMode = false;
                console.log('Segment mode disabled');
            } else {
                try {
                    await renderSimplifiedGameSegments(); // Use new simplified function
                    this.textContent = 'üó∫Ô∏è Segment Mode: ON';
                    this.style.backgroundColor = '#10b981';
                    segmentMode = true;
                    console.log('Simplified gamification mode enabled');
                } catch (error) {
                    console.error('Error enabling simplified mode:', error);
                    alert('Failed to load simplified mode. Please try again.');
                }
            }
        };

        // New simplified segment rendering for gamification
        async function renderSimplifiedGameSegments() {
            const center = map.getCenter();
            const radius = getRadiusFromInput();
            
            console.log(`üéÆ Loading simplified gamification segments within ${radius}m`);
            
            try {
                // Get OSM data
                const osmData = await queryWalkableAreas(center.lat, center.lng, radius);
                if (!osmData || !osmData.elements) {
                    throw new Error('Failed to load OSM data');
                }
                
                clearSegmentOverlays();
                
                // Track different types for stats
                let roadSegments = 0;
                let parkSegments = 0;
                let filteredOut = 0;
                
                // Process each element with simplified logic
                for (const element of osmData.elements) {
                    if (element.type === 'way' && element.geometry && element.geometry.length >= 2) {
                        const tags = element.tags || {};
                        
                        // SIMPLIFIED CATEGORIZATION - Only roads with sidewalks + parks
                        const isRoad = tags.highway && tags.highway.match(/^(primary|secondary|tertiary|residential|unclassified)$/);
                        const isPark = tags.leisure === 'park' || tags.leisure === 'recreation_ground' || 
                                      tags.landuse === 'recreation_ground' || tags.leisure === 'playground';
                        
                        // Skip restricted areas
                        if (tags.fee === 'yes' || tags.access === 'private' || tags.access === 'no') {
                            continue;
                        }
                        
                        // SIMPLIFIED LOGIC: Include main roads (assuming they have sidewalks) and parks
                        if (isRoad) {
                            // For gamification, assume main roads have sidewalks - much simpler!
                            roadSegments++;
                        } else if (isPark) {
                            parkSegments++;
                            // Add park discovery logic here if desired
                        } else {
                            continue; // Only main roads and parks
                        }
                        
                        // Check if within radius
                        const coordinates = element.geometry.map(node => [node.lat, node.lon]);
                        const hasPointInRadius = coordinates.some(coord => {
                            const distance = calculateDistance(center.lat, center.lng, coord[0], coord[1]);
                            return distance <= radius;
                        });
                        
                        if (!hasPointInRadius) continue;
                        
                        // Create single segment per way (simplified)
                        const segmentId = `simple_${element.id}`;
                        
                        // Calculate length
                        let segmentLength = 0;
                        for (let i = 1; i < coordinates.length; i++) {
                            segmentLength += calculateDistance(
                                coordinates[i-1][0], coordinates[i-1][1],
                                coordinates[i][0], coordinates[i][1]
                            );
                        }
                        
                        // Visual style for simplified approach
                        let color = '#94a3b8'; // Gray (not walked)
                        let weight = isPark ? 6 : 8; // Parks slightly thinner
                        
                        const walkData = walkedSegments.get(segmentId);
                        if (walkData && walkData.completed) {
                            if (isRoad) {
                                color = '#3b82f6'; // Blue for completed roads
                                weight = 10; // Thick when completed
                            } else if (isPark) {
                                color = '#10b981'; // Emerald for discovered parks
                                weight = 8;
                            }
                        }
                        
                        const polyline = L.polyline(coordinates, {
                            color: color,
                            weight: weight,
                            opacity: 0.9,
                            lineJoin: 'round',
                            lineCap: 'round',
                            segmentId: segmentId,
                            segmentLength: segmentLength
                        });
                        
                        // Click to complete
                        polyline.on('click', () => {
                            markSegmentAsWalkedWithBlockCheck(segmentId, polyline, tags);
                        });
                        
                        // Tooltip
                        const name = tags.name || (isRoad ? 'Street' : 'Park');
                        const type = isRoad ? 'üõ£Ô∏è Road' : 'üèûÔ∏è Park';
                        const status = walkData && walkData.completed ? '‚úÖ Explored' : '‚¨ú Not explored';
                        
                        polyline.bindTooltip(`${type} ${name} [${Math.round(segmentLength)}m] ${status}`, {
                            sticky: true,
                            direction: 'top'
                        });
                        
                        polyline.addTo(map);
                        segmentLayers.push(polyline);
                    }
                }
                
                console.log(`üéÆ Simplified gamification loaded: ${roadSegments} main roads, ${parkSegments} parks`);
                console.log(`‚ú® Ready for dog walking variety and exploration!`);
                updateSegmentStats();
                
            } catch (error) {
                console.error('Error loading simplified segments:', error);
                alert('Failed to load gamification segments. Please try again.');
            }
        }

        // Toggle between complex and simplified gamification modes
        async function toggleGameMode() {
            const gameBtn = document.getElementById('gameBtn');
            const segmentBtn = document.getElementById('segmentBtn');
            
            try {
                if (segmentMode) {
                    // Already in segment mode, just switch to simplified
                    clearSegmentOverlays();
                    await renderSimplifiedGameSegments();
                    gameBtn.textContent = 'üéÆ Simple Game Mode: ON';
                    gameBtn.style.backgroundColor = '#10b981';
                    segmentBtn.textContent = 'ÔøΩÔøΩÔ∏è Segment Mode: OFF';
                    segmentBtn.style.backgroundColor = '#6b7280';
                    console.log('Switched to simplified gamification mode');
                } else {
                    // Enable simplified mode
                    await renderSimplifiedGameSegments();
                    segmentMode = true;
                    gameBtn.textContent = 'üéÆ Simple Game Mode: ON';
                    gameBtn.style.backgroundColor = '#10b981';
                    segmentBtn.textContent = 'üõ£Ô∏è Segment Mode: OFF';
                    segmentBtn.style.backgroundColor = '#6b7280';
                    console.log('Enabled simplified gamification mode');
                }
            } catch (error) {
                console.error('Error in toggleGameMode:', error);
                alert('Failed to toggle game mode. Please try again.');
            }
        }

        // === BLOCK COMPLETION SYSTEM ===
        // Detect when user has "looped" around blocks and fill them with color
        
        let blockFillLayers = []; // Store completed block polygons
        const MAX_ACTIVE_BLOCKS = 20; // Limit for performance
        let totalCompletedArea = 0; // Track total area of completed blocks (m¬≤)
        let estimatedTotalArea = 0; // Estimated total walkable area in radius
        
        // Check for completed blocks after each segment completion
        function checkBlockCompletion() {
            const completedSegments = Array.from(walkedSegments.entries())
                .filter(([id, data]) => data.completed)
                .map(([id, data]) => id);
            
            console.log(`üîç Checking block completion with ${completedSegments.length} completed segments`);
            
            // Find potential blocks (this is a simplified approach)
            const blocks = findCompletedBlocks(completedSegments);
            
            console.log(`üîç Found ${blocks.length} potential blocks`);
            
            // Filter out duplicate/overlapping blocks before creating
            const uniqueBlocks = filterUniqueBlocks(blocks);
            console.log(`üîç Filtered to ${uniqueBlocks.length} unique blocks from ${blocks.length} candidates`);
            
            // Fill in any newly completed blocks
            uniqueBlocks.forEach(block => {
                if (!completedBlocks.has(block.id)) {
                    // Performance optimization: remove oldest blocks if we have too many
                    if (blockFillLayers.length >= MAX_ACTIVE_BLOCKS) {
                        console.log(`‚ö° Performance: Removing oldest block (${blockFillLayers.length}/${MAX_ACTIVE_BLOCKS})`);
                        const oldestBlock = blockFillLayers.shift();
                        map.removeLayer(oldestBlock);
                    }
                    
                    fillCompletedBlock(block);
                    completedBlocks.add(block.id);
                    console.log(`üéâ Block completed! ${block.id} (${blockFillLayers.length}/${MAX_ACTIVE_BLOCKS} active)`);
                }
            });
        }
        
        // Find blocks that have been completely walked around
        function findCompletedBlocks(completedSegmentIds) {
            const blocks = [];
            const center = map.getCenter();
            const radius = getRadiusFromInput();
            
            // Get all completed segment polylines
            const completedPolylines = segmentLayers.filter(layer => 
                completedSegmentIds.includes(layer.options.segmentId)
            );
            
            if (completedPolylines.length < 3) return blocks; // Need at least 3 segments to form a block
            
            // Simple block detection: look for rectangular patterns
            // This is a simplified approach - in reality you'd need more sophisticated topology
            const blockCandidates = detectSimpleBlocks(completedPolylines, center, radius);
            
            return blockCandidates;
        }
        
        // Advanced polygon detection algorithm - traces actual block shapes
        function detectSimpleBlocks(polylines, center, radius) {
            const blocks = [];
            
            console.log(`üîß Building road graph from ${polylines.length} polylines`);
            
            // Build a graph of connected road segments
            const roadGraph = buildRoadGraph(polylines);
            
            console.log(`üîß Road graph has ${roadGraph.size} nodes`);
            
            // Find closed loops in the road graph (actual block shapes)
            const loops = findClosedLoops(roadGraph);
            
            console.log(`üîß Found ${loops.length} closed loops`);
            
            // Convert valid loops into block polygons
            loops.forEach((loop, index) => {
                if (loop.length >= 3) { // Need at least 3 points for a polygon
                    const blockId = `block_${Date.now()}_${index}`;
                    const polygon = createPolygonFromLoop(loop);
                    
                    if (polygon && isValidBlockSize(polygon)) {
                        console.log(`‚úÖ Valid block created: ${blockId}, area: ${calculatePolygonArea(polygon)}m¬≤`);
                        blocks.push({
                            id: blockId,
                            polygon: polygon,
                            area: calculatePolygonArea(polygon),
                            isActualShape: true // Flag to indicate this is a real shape, not a rectangle
                        });
                    } else {
                        console.log(`‚ùå Invalid block: ${blockId}, area: ${polygon ? calculatePolygonArea(polygon) : 'no polygon'}m¬≤`);
                    }
                }
            });
            
            console.log(`üîß Final blocks array has ${blocks.length} valid blocks`);
            
            return blocks;
        }
        
        // Build a graph of connected road segments with intersection detection
        function buildRoadGraph(polylines) {
            const graph = new Map();
            const tolerance = 0.0001; // ~10 meters tolerance for intersections
            
            // First, find all intersection points between segments
            const intersections = findAllIntersections(polylines, tolerance);
            console.log(`üîó Found ${intersections.length} intersection points`);
            
            // Create nodes for all intersection points
            intersections.forEach((intersection, index) => {
                const key = getPointKey(intersection.point);
                if (!graph.has(key)) {
                    graph.set(key, {
                        point: intersection.point,
                        connections: [],
                        isIntersection: true,
                        segments: intersection.segments
                    });
                }
            });
            
            // Connect segments through their intersection points
            polylines.forEach((polyline, polylineIndex) => {
                const coords = polyline.getLatLngs();
                const roadPoints = coords.map(coord => ({lat: coord.lat, lng: coord.lng}));
                
                // Find which intersections this polyline passes through
                const segmentIntersections = intersections.filter(int => 
                    int.segments.includes(polylineIndex)
                ).sort((a, b) => {
                    // Sort by position along the polyline
                    const distA = getDistanceAlongPolyline(roadPoints, a.point);
                    const distB = getDistanceAlongPolyline(roadPoints, b.point);
                    return distA - distB;
                });
                
                // Connect consecutive intersection points along this polyline
                for (let i = 0; i < segmentIntersections.length - 1; i++) {
                    const fromKey = getPointKey(segmentIntersections[i].point);
                    const toKey = getPointKey(segmentIntersections[i + 1].point);
                    
                    if (graph.has(fromKey) && graph.has(toKey)) {
                        // Get the road points between these intersections
                        const fromDist = getDistanceAlongPolyline(roadPoints, segmentIntersections[i].point);
                        const toDist = getDistanceAlongPolyline(roadPoints, segmentIntersections[i + 1].point);
                        const segmentPoints = getPointsBetweenDistances(roadPoints, fromDist, toDist);
                        
                        // Add bidirectional connections
                        graph.get(fromKey).connections.push({
                            to: toKey,
                            roadPoints: segmentPoints,
                            polyline: polyline
                        });
                        
                        graph.get(toKey).connections.push({
                            to: fromKey,
                            roadPoints: [...segmentPoints].reverse(),
                            polyline: polyline
                        });
                    }
                }
            });
            
            return graph;
        }
        
        // Find all intersection points between polylines
        function findAllIntersections(polylines, tolerance) {
            const intersections = [];
            
            for (let i = 0; i < polylines.length; i++) {
                for (let j = i + 1; j < polylines.length; j++) {
                    const intersectionPoints = findPolylineIntersections(
                        polylines[i].getLatLngs(),
                        polylines[j].getLatLngs(),
                        tolerance
                    );
                    
                    intersectionPoints.forEach(point => {
                        // Check if this intersection already exists
                        const existing = intersections.find(int => 
                            Math.abs(int.point.lat - point.lat) < tolerance &&
                            Math.abs(int.point.lng - point.lng) < tolerance
                        );
                        
                        if (existing) {
                            existing.segments.push(i, j);
                        } else {
                            intersections.push({
                                point: point,
                                segments: [i, j]
                            });
                        }
                    });
                }
            }
            
            return intersections;
        }
        
        // Find intersection points between two polylines
        function findPolylineIntersections(coords1, coords2, tolerance) {
            const intersections = [];
            
            // Check each segment of polyline1 against each segment of polyline2
            for (let i = 0; i < coords1.length - 1; i++) {
                for (let j = 0; j < coords2.length - 1; j++) {
                    const intersection = lineSegmentIntersection(
                        coords1[i], coords1[i + 1],
                        coords2[j], coords2[j + 1],
                        tolerance
                    );
                    
                    if (intersection) {
                        intersections.push(intersection);
                    }
                }
            }
            
            return intersections;
        }
        
        // Find intersection between two line segments
        function lineSegmentIntersection(p1, p2, p3, p4, tolerance) {
            const x1 = p1.lng, y1 = p1.lat;
            const x2 = p2.lng, y2 = p2.lat;
            const x3 = p3.lng, y3 = p3.lat;
            const x4 = p4.lng, y4 = p4.lat;
            
            const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (Math.abs(denom) < 1e-10) return null; // Lines are parallel
            
            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
            
            // Check if intersection is within both line segments (with tolerance)
            if (t >= -tolerance && t <= 1 + tolerance && u >= -tolerance && u <= 1 + tolerance) {
                return {
                    lat: y1 + t * (y2 - y1),
                    lng: x1 + t * (x2 - x1)
                };
            }
            
            return null;
        }
        
        // Get distance along polyline to a point
        function getDistanceAlongPolyline(roadPoints, targetPoint) {
            let totalDistance = 0;
            let closestDistance = Infinity;
            let result = 0;
            
            for (let i = 0; i < roadPoints.length - 1; i++) {
                const segmentStart = roadPoints[i];
                const segmentEnd = roadPoints[i + 1];
                
                // Check distance from target point to this segment
                const distance = pointToLineDistance(targetPoint, segmentStart, segmentEnd);
                
                if (distance < closestDistance) {
                    closestDistance = distance;
                    result = totalDistance + pointDistanceAlongSegment(targetPoint, segmentStart, segmentEnd);
                }
                
                totalDistance += calculateDistance(segmentStart.lat, segmentStart.lng, segmentEnd.lat, segmentEnd.lng);
            }
            
            return result;
        }
        
        // Get points between two distances along a polyline
        function getPointsBetweenDistances(roadPoints, startDist, endDist) {
            const result = [];
            let currentDistance = 0;
            
            for (let i = 0; i < roadPoints.length - 1; i++) {
                const segmentStart = roadPoints[i];
                const segmentEnd = roadPoints[i + 1];
                const segmentLength = calculateDistance(segmentStart.lat, segmentStart.lng, segmentEnd.lat, segmentEnd.lng);
                
                if (currentDistance + segmentLength >= startDist && currentDistance <= endDist) {
                    if (result.length === 0) result.push(segmentStart);
                    result.push(segmentEnd);
                }
                
                currentDistance += segmentLength;
                if (currentDistance > endDist) break;
            }
            
            return result;
        }
        
        // Distance from point to line segment
        function pointToLineDistance(point, lineStart, lineEnd) {
            const A = point.lng - lineStart.lng;
            const B = point.lat - lineStart.lat;
            const C = lineEnd.lng - lineStart.lng;
            const D = lineEnd.lat - lineStart.lat;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            
            if (lenSq === 0) return Math.sqrt(A * A + B * B);
            
            const param = dot / lenSq;
            
            let closestPoint;
            if (param < 0) {
                closestPoint = lineStart;
            } else if (param > 1) {
                closestPoint = lineEnd;
            } else {
                closestPoint = {
                    lng: lineStart.lng + param * C,
                    lat: lineStart.lat + param * D
                };
            }
            
            const dx = point.lng - closestPoint.lng;
            const dy = point.lat - closestPoint.lat;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        // Distance along segment to closest point
        function pointDistanceAlongSegment(point, segmentStart, segmentEnd) {
            const A = point.lng - segmentStart.lng;
            const B = point.lat - segmentStart.lat;
            const C = segmentEnd.lng - segmentStart.lng;
            const D = segmentEnd.lat - segmentStart.lat;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            
            if (lenSq === 0) return 0;
            
            const param = Math.max(0, Math.min(1, dot / lenSq));
            return param * Math.sqrt(lenSq) * 111000; // Convert to meters approximately
        }
        
        // Find closed loops in the road graph
        function findClosedLoops(graph) {
            const loops = [];
            const visited = new Set();
            
            // Try to find loops starting from each node
            for (const [startKey, startNode] of graph) {
                if (visited.has(startKey)) continue;
                
                const foundLoops = findLoopsFromNode(graph, startKey, visited);
                loops.push(...foundLoops);
            }
            
            return loops;
        }
        
        // Find loops starting from a specific node using DFS
        function findLoopsFromNode(graph, startKey, globalVisited) {
            const loops = [];
            const path = [startKey];
            const pathSet = new Set([startKey]);
            
            function dfs(currentKey, depth) {
                if (depth > 8) return; // Prevent infinite loops, max 8 segments per block
                
                const currentNode = graph.get(currentKey);
                if (!currentNode) return;
                
                for (const connection of currentNode.connections) {
                    const nextKey = connection.to;
                    
                    // Found a loop back to start
                    if (nextKey === startKey && path.length >= 3) {
                        const loopPoints = createLoopFromPath(graph, path);
                        if (loopPoints.length >= 3) {
                            loops.push(loopPoints);
                        }
                        continue;
                    }
                    
                    // Continue exploring if not already in current path
                    if (!pathSet.has(nextKey)) {
                        path.push(nextKey);
                        pathSet.add(nextKey);
                        dfs(nextKey, depth + 1);
                        path.pop();
                        pathSet.delete(nextKey);
                    }
                }
            }
            
            dfs(startKey, 0);
            globalVisited.add(startKey);
            
            return loops;
        }
        
        // Create actual polygon coordinates from a path of connected roads
        function createLoopFromPath(graph, path) {
            const loopPoints = [];
            
            for (let i = 0; i < path.length; i++) {
                const currentKey = path[i];
                const nextKey = path[(i + 1) % path.length];
                
                const currentNode = graph.get(currentKey);
                if (!currentNode) continue;
                
                // Find the connection to the next node
                const connection = currentNode.connections.find(conn => conn.to === nextKey);
                if (connection && connection.roadPoints) {
                    // Add all points along this road segment (except the last to avoid duplicates)
                    const points = connection.roadPoints.slice(0, -1);
                    loopPoints.push(...points);
                }
            }
            
            return loopPoints;
        }
        
        // Helper function to get a consistent key for a point
        function getPointKey(point) {
            return `${point.lat.toFixed(5)},${point.lng.toFixed(5)}`;
        }
        
        // Create a polygon from a loop of points
        function createPolygonFromLoop(loop) {
            if (loop.length < 3) return null;
            
            // Ensure the polygon is closed
            const polygonPoints = [...loop];
            const firstPoint = polygonPoints[0];
            const lastPoint = polygonPoints[polygonPoints.length - 1];
            
            // Close the polygon if not already closed
            if (Math.abs(firstPoint.lat - lastPoint.lat) > 0.00001 || 
                Math.abs(firstPoint.lng - lastPoint.lng) > 0.00001) {
                polygonPoints.push(firstPoint);
            }
            
            return polygonPoints;
        }
        
        // Check if a polygon is a valid block size
        function isValidBlockSize(polygon) {
            const area = calculatePolygonArea(polygon);
            return area > 1000 && area < 50000; // Between ~1000m¬≤ and ~50000m¬≤ (reasonable block sizes)
        }
        
        // Calculate polygon area using shoelace formula
        function calculatePolygonArea(polygon) {
            if (polygon.length < 3) return 0;
            
            let area = 0;
            const earthRadius = 6371000; // Earth radius in meters
            
            for (let i = 0; i < polygon.length - 1; i++) {
                const p1 = polygon[i];
                const p2 = polygon[i + 1];
                
                // Convert to approximate meters for area calculation
                const lat1Rad = p1.lat * Math.PI / 180;
                const lat2Rad = p2.lat * Math.PI / 180;
                const lng1Rad = p1.lng * Math.PI / 180;
                const lng2Rad = p2.lng * Math.PI / 180;
                
                area += (lng2Rad - lng1Rad) * (2 + Math.sin(lat1Rad) + Math.sin(lat2Rad));
            }
            
            area = Math.abs(area * earthRadius * earthRadius / 2);
            return area;
        }
        
        // Fill a completed block with color using actual polygon shape
        function fillCompletedBlock(block) {
            let polygonCoords;
            
            // Use actual polygon shape if available, otherwise fall back to rectangle
            if (block.isActualShape && block.polygon && block.polygon.length >= 3) {
                // Use full polygon for better visibility (less simplification)
                polygonCoords = block.polygon.map(point => [point.lat, point.lng]);
                
                // Ensure polygon is closed
                const first = polygonCoords[0];
                const last = polygonCoords[polygonCoords.length - 1];
                if (first[0] !== last[0] || first[1] !== last[1]) {
                    polygonCoords.push(first);
                }
                
                // Only simplify if polygon is very complex (>20 points)
                if (polygonCoords.length > 20) {
                    polygonCoords = simplifyPolygon(polygonCoords, 0.00005);
                }
                
                console.log(`üìê Creating polygon with ${polygonCoords.length} points`);
            } else if (block.bounds) {
                // Fallback to rectangle for legacy blocks
                const bounds = block.bounds;
                polygonCoords = [
                    [bounds.north, bounds.west], // Northwest
                    [bounds.north, bounds.east], // Northeast  
                    [bounds.south, bounds.east], // Southeast
                    [bounds.south, bounds.west], // Southwest
                    [bounds.north, bounds.west]  // Close the polygon
                ];
            } else {
                console.warn('Block has invalid polygon or bounds data:', block);
                console.warn('Polygon length:', block.polygon ? block.polygon.length : 'undefined');
                console.warn('Has bounds:', !!block.bounds);
                return;
            }
            
            // Validate polygon coordinates
            if (!polygonCoords || polygonCoords.length < 3) {
                console.warn('Invalid polygon coordinates:', polygonCoords);
                return;
            }
            
            // Create a more visible filled polygon
            const blockPolygon = L.polygon(polygonCoords, {
                color: '#059669', // Darker emerald border for visibility
                fillColor: '#10b981', // Emerald fill
                fillOpacity: 0.6, // Much more opaque for visibility
                weight: 4, // Thicker border for visibility
                opacity: 1.0, // Fully opaque border
                dashArray: null // Remove dashed pattern - use solid line
            });
            
            // Calculate area and add persistent label
            const areaM2 = Math.round(block.area || 0);
            const center = getPolygonCenter(polygonCoords);
            
            // Create a permanent label showing the area
            const areaLabel = L.marker(center, {
                icon: L.divIcon({
                    className: 'block-area-label',
                    html: `<div style="background: rgba(16, 185, 129, 0.9); color: white; padding: 2px 6px; border-radius: 4px; font-weight: bold; font-size: 11px; text-align: center; border: 1px solid #059669;">${areaM2}m¬≤</div>`,
                    iconSize: [60, 20],
                    iconAnchor: [30, 10]
                }),
                interactive: false
            });
            
            // Add tooltip for more details
            blockPolygon.bindTooltip(`üéâ Completed Block!<br/>Area: ${areaM2}m¬≤<br/>Shape: ${block.isActualShape ? 'Actual' : 'Rectangle'}`, {
                sticky: true,
                direction: 'center',
                opacity: 0.9
            });
            
            // Add both polygon and label to map
            blockPolygon.addTo(map);
            areaLabel.addTo(map);
            
            // Store both for cleanup
            blockFillLayers.push(blockPolygon);
            blockFillLayers.push(areaLabel);
            
            // Track total completed area
            totalCompletedArea += areaM2;
            
            console.log(`‚úÖ Filled completed block: ${block.id}, ${areaM2}m¬≤ (Total: ${totalCompletedArea}m¬≤)`);
            
            // Update statistics
            updateBlockAreaStats();
        }
        
        // Clear all completed block overlays
        function clearBlockFills() {
            blockFillLayers.forEach(layer => {
                map.removeLayer(layer);
            });
            blockFillLayers = [];
            completedBlocks.clear();
            totalCompletedArea = 0; // Reset area tracking
            updateBlockAreaStats(); // Update display
            console.log('üóëÔ∏è Cleared all completed blocks and reset area tracking');
        }
        
        // Modified click handler to check for block completion
        function markSegmentAsWalkedWithBlockCheck(segmentId, polyline, tags) {
            const walkData = walkedSegments.get(segmentId) || {progress: 0, completed: false};
            walkData.completed = !walkData.completed;
            walkData.progress = walkData.completed ? 100 : 0;
            walkedSegments.set(segmentId, walkData);
            
            // Update visual
            const isRoad = tags.highway && tags.highway.match(/^(primary|secondary|tertiary|residential|unclassified)$/);
            const isPark = tags.leisure === 'park' || tags.leisure === 'recreation_ground';
            
            if (walkData.completed) {
                polyline.setStyle({
                    color: isRoad ? '#3b82f6' : '#10b981',
                    weight: isRoad ? 10 : 8
                });
            } else {
                polyline.setStyle({
                    color: '#94a3b8',
                    weight: isPark ? 6 : 8
                });
            }
            
            updateSegmentStats();
            
            // Check for block completion after each segment is marked
            setTimeout(() => checkBlockCompletion(), 100); // Small delay to ensure UI updates
        }

        // Debug block detection
        function debugBlockDetection() {
            console.log('üîç Manual block detection debug started...');
            
            const completedSegments = Array.from(walkedSegments.entries())
                .filter(([id, data]) => data.completed)
                .map(([id, data]) => id);
            
            console.log(`üìä Completed segments: ${completedSegments.length}`, completedSegments);
            
            if (completedSegments.length === 0) {
                alert('No completed segments found! Click on some blue road segments first.');
                return;
            }
            
            // Show which polylines are completed
            const completedPolylines = segmentLayers.filter(layer => 
                completedSegments.includes(layer.options.segmentId)
            );
            
            console.log(`üìä Completed polylines: ${completedPolylines.length}`);
            
            // Test block detection manually
            checkBlockCompletion();
            
            // Also try to detect blocks manually
            if (completedPolylines.length >= 3) {
                console.log('üîß Attempting manual block detection with completed polylines...');
                const center = map.getCenter();
                const radius = getRadiusFromInput();
                const manualBlocks = detectSimpleBlocks(completedPolylines, center, radius);
                console.log(`üîß Manual detection found ${manualBlocks.length} blocks`);
            } else {
                console.log('‚ö†Ô∏è Need at least 3 completed segments to form a block');
            }
        }

        // Simplify polygon using Douglas-Peucker algorithm to reduce rendering lag
        function simplifyPolygon(points, tolerance) {
            if (points.length <= 2) return points;
            
            // Find the point with the maximum distance from the line between first and last
            let maxDistance = 0;
            let maxIndex = 0;
            
            for (let i = 1; i < points.length - 1; i++) {
                const distance = perpendicularDistance(points[i], points[0], points[points.length - 1]);
                if (distance > maxDistance) {
                    maxDistance = distance;
                    maxIndex = i;
                }
            }
            
            // If max distance is greater than tolerance, recursively simplify
            if (maxDistance > tolerance) {
                const firstHalf = simplifyPolygon(points.slice(0, maxIndex + 1), tolerance);
                const secondHalf = simplifyPolygon(points.slice(maxIndex), tolerance);
                
                // Combine results (remove duplicate point at junction)
                return firstHalf.slice(0, -1).concat(secondHalf);
            } else {
                // If all points are within tolerance, just return start and end
                return [points[0], points[points.length - 1]];
            }
        }
        
        // Calculate perpendicular distance from point to line
        function perpendicularDistance(point, lineStart, lineEnd) {
            const [px, py] = point;
            const [x1, y1] = lineStart;
            const [x2, y2] = lineEnd;
            
            const A = y2 - y1;
            const B = x1 - x2;
            const C = x2 * y1 - x1 * y2;
            
            return Math.abs(A * px + B * py + C) / Math.sqrt(A * A + B * B);
        }
        
        // Get the center point of a polygon
        function getPolygonCenter(coords) {
            let lat = 0, lng = 0;
            for (const coord of coords) {
                lat += coord[0];
                lng += coord[1];
            }
            return [lat / coords.length, lng / coords.length];
        }
        
        // Filter out duplicate or overlapping blocks
        function filterUniqueBlocks(blocks) {
            const unique = [];
            const tolerance = 50; // 50 meter tolerance for considering blocks the same
            
            for (const block of blocks) {
                const blockCenter = getPolygonCenter(block.polygon ? block.polygon.map(p => [p.lat, p.lng]) : []);
                
                // Check if this block is too close to an existing one
                const isDuplicate = unique.some(existing => {
                    const existingCenter = getPolygonCenter(existing.polygon ? existing.polygon.map(p => [p.lat, p.lng]) : []);
                    const distance = calculateDistance(
                        blockCenter[0], blockCenter[1], 
                        existingCenter[0], existingCenter[1]
                    );
                    return distance < tolerance;
                });
                
                if (!isDuplicate) {
                    unique.push(block);
                }
            }
            
            return unique;
        }
        
        // Update block area statistics and display
        function updateBlockAreaStats() {
            const completedBlocks = blockFillLayers.length / 2; // Divide by 2 because we store both polygon and label
            const radius = getRadiusFromInput();
            
            // Estimate total area (rough calculation based on circular area)
            const circleAreaM2 = Math.PI * radius * radius;
            estimatedTotalArea = circleAreaM2 * 0.6; // ~60% of circle is typically walkable blocks
            
            const completionPercentage = estimatedTotalArea > 0 ? (totalCompletedArea / estimatedTotalArea * 100).toFixed(1) : 0;
            
            // Update the segment stats display with area information
            const statsDisplay = document.getElementById('segmentStats');
            if (statsDisplay) {
                const segmentCount = Array.from(walkedSegments.entries()).filter(([id, data]) => data.completed).length;
                const totalSegments = segmentLayers.length;
                const segmentPercentage = totalSegments > 0 ? (segmentCount / totalSegments * 100).toFixed(1) : 0;
                
                statsDisplay.innerHTML = `
                    <strong>üìä Progress:</strong><br/>
                    üõ£Ô∏è Segments: ${segmentCount}/${totalSegments} (${segmentPercentage}%)<br/>
                    üèòÔ∏è Blocks: ${completedBlocks} completed<br/>
                    üìê Area: ${totalCompletedArea.toLocaleString()}m¬≤ / ~${estimatedTotalArea.toLocaleString()}m¬≤ (${completionPercentage}%)<br/>
                    üéØ Coverage: ${completionPercentage}% of neighborhood explored
                `;
            }
            
            console.log(`üìä Area Stats: ${totalCompletedArea}m¬≤ completed (${completionPercentage}% of ~${estimatedTotalArea}m¬≤ total)`);
        }

    </script>
</body>
</html> 