<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Walkable Areas Grid Test</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        h1 {
            margin-bottom: 24px;
            color: #1f2937;
        }

        .controls {
            display: flex;
            gap: 16px;
            margin-bottom: 24px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        label {
            font-size: 14px;
            font-weight: 500;
            color: #374151;
        }

        input, select, button {
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
        }

        button {
            background: #4f46e5;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s;
        }

        button:hover {
            background: #4338ca;
        }

        .map-container {
            position: relative;
            width: 100%;
            height: 600px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            overflow: hidden;
            background: #f9fafb;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 1000;
        }

        .grid-cell {
            position: absolute;
            border: 2px solid rgba(79, 70, 229, 0.4);
            background: rgba(79, 70, 229, 0.15);
            transition: all 0.2s;
            cursor: pointer;
            pointer-events: auto;
        }

        .grid-cell.walkable {
            background: rgba(34, 197, 94, 0.6);
            border: 2px solid rgba(22, 163, 74, 0.9);
        }

        .grid-cell.non-walkable {
            background: rgba(239, 68, 68, 0.6);
            border: 2px solid rgba(220, 38, 38, 0.9);
        }

        .grid-cell.restricted {
            background: rgba(168, 85, 247, 0.6);
            border: 2px solid rgba(147, 51, 234, 0.9);
        }

        .grid-cell.unknown {
            background: rgba(156, 163, 175, 0.4);
            border: 2px solid rgba(107, 114, 128, 0.7);
        }

        .grid-cell:hover {
            opacity: 0.8;
            transform: scale(1.02);
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-top: 16px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.2);
        }

        .info-panel {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
            margin-top: 20px;
        }

        .info-panel h3 {
            margin-bottom: 8px;
            color: #1e293b;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 16px;
            margin-top: 12px;
        }

        .stat {
            text-align: center;
            padding: 12px;
            background: white;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #1e293b;
        }

        .stat-label {
            font-size: 12px;
            color: #64748b;
            margin-top: 4px;
        }

        .instructions {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 24px;
        }

        .instructions h3 {
            color: #92400e;
            margin-bottom: 8px;
        }

        .instructions ul {
            color: #92400e;
            margin-left: 20px;
        }

        .instructions li {
            margin-bottom: 4px;
        }

        .keyboard-shortcuts {
            background: #eff6ff;
            border: 1px solid #3b82f6;
            border-radius: 8px;
            padding: 12px;
            margin-top: 16px;
            font-size: 12px;
        }

        .keyboard-shortcuts strong {
            color: #1e40af;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .map-container {
                height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üó∫Ô∏è Walkable Areas Grid Test</h1>
        
        <div class="instructions">
            <h3>üìã How to Use This Test</h3>
            <ul>
                <li>Enter your coordinates or click "üìç Use My Location"</li>
                <li>Click "üó∫Ô∏è Load Map" to visualize your area</li>
                <li>Click "‚¨ú Generate Grid" to create the test grid</li>
                <li>Click grid cells to cycle through: Unknown ‚Üí Walkable ‚Üí Non-walkable</li>
                <li>Observe how coverage percentage changes as you classify areas</li>
            </ul>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="latitude">Your Latitude:</label>
                <input type="number" id="latitude" step="0.000001" placeholder="e.g., 40.7128" />
            </div>
            
            <div class="control-group">
                <label for="longitude">Your Longitude:</label>
                <input type="number" id="longitude" step="0.000001" placeholder="e.g., -74.0060" />
            </div>
            
            <div class="control-group">
                <label for="grid-size">Grid Size:</label>
                <select id="grid-size">
                    <option value="15">15x15</option>
                    <option value="20">20x20</option>
                    <option value="25" selected>25x25</option>
                    <option value="30">30x30</option>
                    <option value="40">40x40</option>
                    <option value="50">50x50</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="radius">Radius (meters):</label>
                <input type="number" id="radius" value="500" min="100" max="2000" step="50" />
            </div>
            
            <button onclick="getCurrentLocation()">üìç Use My Location</button>
            <button onclick="showLocationHelp()">‚ùì Need Coordinates?</button>
            <button onclick="loadMap()">üó∫Ô∏è Load Map</button>
            <button onclick="generateGrid()">‚¨ú Generate Grid</button>
            <button onclick="autoDetectWalkable()" id="autoDetectBtn">ü§ñ Auto-Detect Walkable Areas</button>
            <button onclick="showRestrictedAreas()" id="restrictedBtn">üö´ Show Restricted Areas</button>
            <button onclick="debugOSMData()" id="debugBtn">üîç Debug OSM Data</button>
            <button onclick="toggleRawDataOverlay()" id="rawDataBtn">üìä Show Raw OSM Data</button>
            <button onclick="toggleEnhancedDetection()" id="enhancedBtn">üéØ Enhanced Detection</button>
            <button onclick="debugSpecificCell()" id="debugCellBtn">üî¨ Debug Cell Intersection</button>
            <button onclick="toggleSegmentMode()" id="segmentBtn">üõ£Ô∏è Segment Mode (Prototype)</button>
            <button onclick="startTestWalk()" id="testWalkBtn">üö∂‚Äç‚ôÇÔ∏è Test Walk Simulation</button>
            <button onclick="clearGrid()">üßπ Clear Grid</button>
        </div>

        <div class="map-container">
            <div id="map">
                <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #6b7280; font-size: 18px; text-align: center; flex-direction: column; gap: 16px;">
                    <div style="font-size: 48px;">üìç</div>
                    <div>Enter coordinates and click "Load Map" to begin</div>
                    <div style="font-size: 14px; color: #9ca3af;">This simulates how your dog walking app would analyze walkable areas</div>
                </div>
            </div>
            <div class="grid-overlay" id="grid-overlay"></div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(34, 197, 94, 0.3); border-color: rgba(34, 197, 94, 0.6);"></div>
                <span>Walkable (roads, sidewalks, parks)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(239, 68, 68, 0.3); border-color: rgba(239, 68, 68, 0.6);"></div>
                <span>Non-walkable (private property, buildings)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(156, 163, 175, 0.2); border-color: rgba(156, 163, 175, 0.4);"></div>
                <span>Unknown/Unclassified</span>
            </div>
        </div>

        <div class="info-panel">
            <h3>üìä Grid Analysis</h3>
            <p>Click on grid cells to classify areas. This simulates how the app would analyze walkable vs non-walkable areas in your residential neighborhood.</p>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(34, 197, 94, 0.6); border: 2px solid rgba(22, 163, 74, 0.9);"></div>
                    <span>Walkable Areas</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(239, 68, 68, 0.6); border: 2px solid rgba(220, 38, 38, 0.9);"></div>
                    <span>Non-walkable Areas</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(168, 85, 247, 0.6); border: 2px solid rgba(147, 51, 234, 0.9);"></div>
                    <span>Restricted Areas</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(156, 163, 175, 0.4); border: 2px solid rgba(107, 114, 128, 0.7);"></div>
                    <span>Unknown Areas</span>
                </div>
            </div>

            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="walkable-count">0</div>
                    <div class="stat-label">Walkable Cells</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="non-walkable-count">0</div>
                    <div class="stat-label">Non-walkable Cells</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="restricted-count">0</div>
                    <div class="stat-label">Restricted Cells</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="unknown-count">0</div>
                    <div class="stat-label">Unknown Cells</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="coverage-percent">0%</div>
                    <div class="stat-label">Area Coverage</div>
                </div>
            </div>

            <div class="keyboard-shortcuts">
                <strong>Keyboard Shortcuts:</strong> Press <strong>1</strong> then click = Walkable | <strong>2</strong> then click = Non-walkable | <strong>3</strong> then click = Unknown | <strong>C</strong> = Clear grid | <strong>G</strong> = Generate grid | <strong>R</strong> = Toggle raw OSM data | <strong>E</strong> = Enhanced detection
            </div>
        </div>
    </div>

    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        let map = null;
        let gridCells = [];
        let currentState = 'walkable'; // Current classification mode

        // Sample coordinates (New York City) - user will replace with their location
        const defaultCoords = { lat: 40.7128, lng: -74.0060 };

        function getCurrentLocation() {
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = 'üì° Getting location...';
            button.disabled = true;

            console.log('Attempting to get location...');

            if (!navigator.geolocation) {
                alert('Geolocation is not supported by this browser.');
                button.textContent = originalText;
                button.disabled = false;
                return;
            }

            // Check if page is served over HTTPS or localhost
            const isSecure = location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
            if (!isSecure) {
                alert('Geolocation requires HTTPS or localhost. Please enter coordinates manually or serve the page over HTTPS.');
                button.textContent = originalText;
                button.disabled = false;
                return;
            }

            const options = {
                enableHighAccuracy: true,
                timeout: 10000, // 10 seconds
                maximumAge: 60000 // 1 minute
            };

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    console.log('Location success:', position);
                    document.getElementById('latitude').value = position.coords.latitude.toFixed(6);
                    document.getElementById('longitude').value = position.coords.longitude.toFixed(6);
                    button.textContent = '‚úÖ Location found!';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.disabled = false;
                    }, 2000);
                    console.log(`Location obtained: ${position.coords.latitude}, ${position.coords.longitude}`);
                },
                (error) => {
                    console.error('Geolocation error:', error);
                    let errorMessage = 'Could not get your location. ';
                    
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                            errorMessage += 'Permission denied. Please allow location access and try again.';
                            break;
                        case error.POSITION_UNAVAILABLE:
                            errorMessage += 'Location information unavailable.';
                            break;
                        case error.TIMEOUT:
                            errorMessage += 'Location request timed out.';
                            break;
                        default:
                            errorMessage += 'An unknown error occurred.';
                            break;
                    }
                    
                    errorMessage += '\n\nPlease enter coordinates manually or try again.';
                    alert(errorMessage);
                    
                    button.textContent = '‚ùå Location failed';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.disabled = false;
                    }, 3000);
                },
                options
            );
        }

        function showLocationHelp() {
            const helpMessage = `üìç How to get your coordinates:

Method 1: Google Maps
‚Ä¢ Open maps.google.com
‚Ä¢ Right-click on your location
‚Ä¢ Click the coordinates that appear
‚Ä¢ Copy them here

Method 2: GPS Coordinates app
‚Ä¢ Search "GPS coordinates" in your app store
‚Ä¢ Use any GPS app on your phone

Method 3: Manual entry
‚Ä¢ If you know your approximate address, search online for "[your address] coordinates"

The format should be:
Latitude: Like 40.7128 (North/South)
Longitude: Like -74.0060 (East/West)`;

            alert(helpMessage);
        }

        function loadMap() {
            const lat = parseFloat(document.getElementById('latitude').value);
            const lng = parseFloat(document.getElementById('longitude').value);

            if (isNaN(lat) || isNaN(lng)) {
                alert('Please enter valid coordinates.');
                return;
            }

            // Validate coordinates are reasonable
            if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                alert('Please enter valid coordinates (latitude: -90 to 90, longitude: -180 to 180).');
                return;
            }

            // Clear the map div and create a new map
            const mapDiv = document.getElementById('map');
            mapDiv.innerHTML = '';
            
            // Destroy existing map if it exists
            if (map !== null) {
                map.remove();
                map = null;
            }

            // Create new Leaflet map
            map = L.map('map').setView([lat, lng], 16);

            // Add OpenStreetMap tiles
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            // Add a marker at the center location
            L.marker([lat, lng])
                .addTo(map)
                .bindPopup(`üìç Your Location<br>${lat.toFixed(4)}, ${lng.toFixed(4)}`)
                .openPopup();

            // Add a circle to show the radius
            const radius = parseInt(document.getElementById('radius').value);
            L.circle([lat, lng], {
                color: '#4f46e5',
                fillColor: '#4f46e5',
                fillOpacity: 0.1,
                radius: radius
            }).addTo(map).bindPopup(`Search radius: ${radius}m`);

            console.log(`Real map loaded for coordinates: ${lat}, ${lng} with ${radius}m radius`);
        }

        function generateGrid() {
            const gridSize = parseInt(document.getElementById('grid-size').value);
            const radius = parseInt(document.getElementById('radius').value);
            const gridOverlay = document.getElementById('grid-overlay');
            
            // Clear existing grid
            gridOverlay.innerHTML = '';
            gridCells = [];

            if (!map) {
                alert('Please load the map first!');
                return;
            }

            // Get the actual map container dimensions
            const mapContainer = map.getContainer();
            const containerWidth = mapContainer.clientWidth;
            const containerHeight = mapContainer.clientHeight;
            
            // Use the smaller dimension to ensure square cells that fit in the view
            const smallerDimension = Math.min(containerWidth, containerHeight);
            const cellPixelSize = smallerDimension / gridSize;
            
            // Calculate offsets to center the grid
            const leftOffset = (containerWidth - smallerDimension) / 2;
            const topOffset = (containerHeight - smallerDimension) / 2;

            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell unknown';
                    
                    // Position cells as perfect squares using pixel dimensions
                    cell.style.left = `${leftOffset + (col * cellPixelSize)}px`;
                    cell.style.top = `${topOffset + (row * cellPixelSize)}px`;
                    cell.style.width = `${cellPixelSize}px`;
                    cell.style.height = `${cellPixelSize}px`;
                    
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.dataset.state = 'unknown';
                    
                    // Add tooltip
                    cell.title = `Cell ${row},${col} - Click to classify`;
                    
                    cell.addEventListener('click', () => toggleCellState(cell));
                    
                    gridOverlay.appendChild(cell);
                    gridCells.push(cell);
                }
            }

            updateStats();
            console.log(`Generated ${gridSize}x${gridSize} SQUARE grid (${gridCells.length} cells, ${cellPixelSize.toFixed(1)}px each)`);
            
            // Show success message
            const originalText = event.target.textContent;
            event.target.textContent = `‚úÖ ${gridCells.length} square cells created!`;
            setTimeout(() => {
                event.target.textContent = originalText;
            }, 2000);
        }

        function toggleCellState(cell) {
            const currentState = cell.dataset.state;
            let newState;
            
            // Cycle through states: unknown -> walkable -> non-walkable -> restricted -> unknown
            switch (currentState) {
                case 'unknown':
                    newState = 'walkable';
                    break;
                case 'walkable':
                    newState = 'non-walkable';
                    break;
                case 'non-walkable':
                    newState = 'restricted';
                    break;
                case 'restricted':
                    newState = 'unknown';
                    break;
                default:
                    newState = 'unknown';
            }
            
            cell.dataset.state = newState;
            cell.className = `grid-cell ${newState}`;
            cell.title = `Cell ${cell.dataset.row},${cell.dataset.col} - ${newState.replace('-', ' ')}`;
            
            updateStats();

            // Visual feedback
            cell.style.transform = 'scale(1.1)';
            setTimeout(() => {
                cell.style.transform = '';
            }, 150);
        }

        function updateStats() {
            const walkable = gridCells.filter(cell => cell.dataset.state === 'walkable').length;
            const nonWalkable = gridCells.filter(cell => cell.dataset.state === 'non-walkable').length;
            const restricted = gridCells.filter(cell => cell.dataset.state === 'restricted').length;
            const unknown = gridCells.filter(cell => cell.dataset.state === 'unknown').length;
            const total = gridCells.length;
            
            const classified = walkable + nonWalkable + restricted;
            const coveragePercent = total > 0 ? Math.round((classified / total) * 100) : 0;
            
            document.getElementById('walkable-count').textContent = walkable;
            document.getElementById('non-walkable-count').textContent = nonWalkable;
            document.getElementById('restricted-count').textContent = restricted;
            document.getElementById('unknown-count').textContent = unknown;
            document.getElementById('coverage-percent').textContent = `${coveragePercent}%`;
        }

        function clearGrid() {
            if (gridCells.length === 0) {
                alert('No grid to clear. Generate a grid first!');
                return;
            }

            gridCells.forEach(cell => {
                cell.dataset.state = 'unknown';
                cell.className = 'grid-cell unknown';
                cell.title = `Cell ${cell.dataset.row},${cell.dataset.col} - Click to classify`;
            });
            updateStats();
            
            // Visual feedback
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = '‚úÖ Grid cleared!';
            setTimeout(() => {
                button.textContent = originalText;
            }, 1500);
        }

        // Auto-detect walkable areas using OpenStreetMap data
        async function autoDetectWalkable() {
            if (!map) {
                alert('Please load the map first!');
                return;
            }

            if (gridCells.length === 0) {
                alert('Please generate a grid first!');
                return;
            }

            const button = document.getElementById('autoDetectBtn');
            const originalText = button.textContent;
            button.textContent = 'üîç Analyzing area...';
            button.disabled = true;

            try {
                const center = map.getCenter();
                const radius = parseInt(document.getElementById('radius').value);
                
                console.log(`Querying walkable areas around ${center.lat}, ${center.lng} within ${radius}m`);
                
                // Query both walkable AND restricted areas
                const [walkableData, restrictedData] = await Promise.all([
                    queryWalkableAreas(center.lat, center.lng, radius),
                    queryRestrictedAreas(center.lat, center.lng, radius)
                ]);
                
                // Combine the data
                const combinedData = {
                    elements: [
                        ...(walkableData?.elements || []),
                        ...(restrictedData?.elements || [])
                    ]
                };
                
                // Apply the data to existing grid
                if (combinedData.elements.length > 0) {
                    classifyGridWithOSMData(combinedData);
                    button.textContent = '‚úÖ Detection complete!';
                } else {
                    button.textContent = '‚ùå No data found';
                }
                
            } catch (error) {
                console.error('Auto-detection error:', error);
                button.textContent = '‚ùå Detection failed';
            }
            
            setTimeout(() => {
                button.textContent = originalText;
                button.disabled = false;
            }, 3000);
        }

        // Query OpenStreetMap Overpass API for walkable areas
        async function queryWalkableAreas(lat, lng, radius) {
            const overpassUrl = 'https://overpass-api.de/api/interpreter';
            
            // Enhanced Overpass query for walkable areas with access restrictions
            const query = `
                [out:json][timeout:25];
                (
                  // Roads and highways (walkable, not private)
                  way["highway"~"^(primary|secondary|tertiary|residential|unclassified|service|footway|path|pedestrian|cycleway)$"]["access"!="private"]["access"!="no"](around:${radius},${lat},${lng});
                  
                  // Sidewalks specifically  
                  way["footway"="sidewalk"]["access"!="private"](around:${radius},${lat},${lng});
                  
                  // Parks and recreational areas (exclude fee-based and private)
                  way["leisure"~"^(park|playground|recreation_ground|garden)$"]["access"!="private"]["fee"!="yes"](around:${radius},${lat},${lng});
                  rel["leisure"~"^(park|playground|recreation_ground|garden)$"]["access"!="private"]["fee"!="yes"](around:${radius},${lat},${lng});
                  
                  // Public paths and trails (explicitly exclude private)
                  way["highway"="track"]["access"!="private"]["access"!="no"](around:${radius},${lat},${lng});
                );
                out geom;
            `;

            try {
                const response = await fetch(overpassUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: 'data=' + encodeURIComponent(query)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('OSM Data received:', data.elements?.length || 0, 'elements');
                return data;
                
            } catch (error) {
                console.error('Error querying OpenStreetMap:', error);
                return null;
            }
        }

        // Classify grid cells based on OSM data
        function classifyGridWithOSMData(osmData) {
            if (!osmData || !osmData.elements) {
                console.error('No OSM data to process');
                return;
            }

            const bounds = map.getBounds();
            const gridSize = parseInt(document.getElementById('grid-size').value);
            
            let classifiedCount = 0;
            
            console.log(`\nüîç Classification Method: ${enhancedDetectionEnabled ? 'ENHANCED GEOMETRIC INTERSECTION' : 'CENTER-POINT + RADIUS'}`);
            
            gridCells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                
                let isWalkable, isRestricted, detectionInfo = '';
                
                if (enhancedDetectionEnabled) {
                    // ENHANCED: Use geometric intersection with grid cell boundaries
                    const cellBounds = getGridCellBounds(row, col, gridSize, bounds);
                    
                    const walkableResult = checkGridCellIntersectsWalkableAreas(cellBounds, osmData.elements);
                    const restrictedResult = checkGridCellIntersectsRestrictedAreas(cellBounds, osmData.elements);
                    
                    isWalkable = walkableResult.intersects;
                    isRestricted = restrictedResult.intersects;
                    
                    if (walkableResult.intersects) {
                        detectionInfo = ` - intersects with ${walkableResult.feature} (${walkableResult.type})`;
                    } else if (restrictedResult.intersects) {
                        detectionInfo = ` - intersects with ${restrictedResult.feature} (${restrictedResult.type})`;
                    }
                    
                } else {
                    // ORIGINAL: Use center point + radius detection
                    const latRange = bounds.getNorthEast().lat - bounds.getSouthWest().lat;
                    const lngRange = bounds.getNorthEast().lng - bounds.getSouthWest().lng;
                    
                    const cellLat = bounds.getSouthWest().lat + (latRange * (1 - (row + 0.5) / gridSize));
                    const cellLng = bounds.getSouthWest().lng + (lngRange * (col + 0.5) / gridSize);
                    
                    isWalkable = checkPointInWalkableAreas(cellLat, cellLng, osmData.elements);
                    isRestricted = checkPointInRestrictedAreas(cellLat, cellLng, osmData.elements);
                    
                    detectionInfo = ` - center point at ${cellLat.toFixed(6)}, ${cellLng.toFixed(6)}`;
                }
                
                // PRIORITY: Walkable areas take precedence over restricted areas
                // If there's any public walkable access, the cell is considered walkable
                if (isWalkable) {
                    cell.dataset.state = 'walkable';
                    cell.className = 'grid-cell walkable';
                    cell.title = `Cell ${row},${col} - walkable (${enhancedDetectionEnabled ? 'geometric' : 'radius'} detection)${detectionInfo}`;
                    classifiedCount++;
                    console.log(`Cell ${row},${col} marked as WALKABLE${detectionInfo}`);
                } else if (isRestricted) {
                    cell.dataset.state = 'restricted';
                    cell.className = 'grid-cell restricted';
                    cell.title = `Cell ${row},${col} - restricted (${enhancedDetectionEnabled ? 'geometric' : 'radius'} detection)${detectionInfo}`;
                    classifiedCount++;
                    console.log(`Cell ${row},${col} marked as RESTRICTED${detectionInfo}`);
                } else {
                    cell.dataset.state = 'non-walkable';
                    cell.className = 'grid-cell non-walkable';
                    cell.title = `Cell ${row},${col} - non-walkable (${enhancedDetectionEnabled ? 'geometric' : 'radius'} detection)`;
                }
            });
            
            console.log(`\nüìä Auto-classified ${classifiedCount} cells as walkable/restricted out of ${gridCells.length} total using ${enhancedDetectionEnabled ? 'GEOMETRIC' : 'CENTER-POINT'} detection`);
            updateStats();
        }

        // Check if a point is within any walkable areas
        function checkPointInWalkableAreas(pointLat, pointLng, osmElements) {
            // First, find all restricted areas for proximity checking
            const restrictedAreas = osmElements.filter(element => {
                const tags = element.tags || {};
                return tags.fee === 'yes' || 
                       tags.access === 'private' || 
                       tags.access === 'no' || 
                       tags.access === 'customers' ||
                       tags.landuse === 'military' || 
                       tags.dog === 'no' ||
                       tags.admission ||
                       (tags.leisure === 'garden' && tags.tourism) ||
                       (tags.tourism === 'attraction' && tags.leisure === 'garden') ||
                       (tags.name && tags.name.toLowerCase().includes('botanical')) ||
                       (tags.name && tags.name.toLowerCase().includes('vandusen')) ||
                       (tags.tourism === 'zoo') ||
                       (tags.tourism === 'museum') ||
                       (tags.tourism === 'theme_park');
            });
            
            for (const element of osmElements) {
                if (element.type === 'way' && element.geometry) {
                    // Only check walkable elements (not restricted ones)
                    const tags = element.tags || {};
                    const isRestrictedElement = tags.fee === 'yes' || tags.access === 'private' || 
                                              tags.access === 'no' || tags.access === 'customers' ||
                                              tags.landuse === 'military' || tags.dog === 'no';
                    
                    if (!isRestrictedElement) {
                        // Check if this path is inside or very close to a restricted area
                        const isNearRestrictedArea = checkIfPathNearRestrictedAreas(element, restrictedAreas);
                        
                        if (!isNearRestrictedArea) {
                            // Check proximity to walkable infrastructure
                            for (const node of element.geometry) {
                                const distance = calculateDistance(pointLat, pointLng, node.lat, node.lon);
                                
                                // Different detection radii based on infrastructure type
                                let detectionRadius = 30; // Default 30m
                                
                                if (tags.highway === 'footway' || tags.highway === 'pedestrian') {
                                    detectionRadius = 20; // Footways and pedestrian areas
                                } else if (tags.highway === 'residential' || tags.highway === 'service') {
                                    detectionRadius = 50; // Residential streets (likely have sidewalks)
                                } else if (tags.highway && tags.highway.match(/^(primary|secondary|tertiary)$/)) {
                                    detectionRadius = 60; // Major roads (wider with sidewalks)
                                } else if (tags.leisure === 'park') {
                                    detectionRadius = 40; // Parks
                                }
                                
                                if (distance < detectionRadius) {
                                    console.log(`Found walkable: ${tags.name || tags.highway || 'unnamed'} at ${distance.toFixed(1)}m (radius: ${detectionRadius}m)`);
                                    return true;
                                }
                            }
                        } else {
                            console.log(`Skipping path near restricted area: ${tags.name || tags.highway || 'unnamed'}`);
                        }
                    }
                }
            }
            return false;
        }

        // Check if a point is within any restricted areas
        function checkPointInRestrictedAreas(pointLat, pointLng, osmElements) {
            for (const element of osmElements) {
                if (element.type === 'way' && element.geometry) {
                    // Enhanced restricted element detection
                    const tags = element.tags || {};
                    const isRestrictedElement = 
                        tags.fee === 'yes' || 
                        tags.access === 'private' || 
                        tags.access === 'no' || 
                        tags.access === 'customers' ||
                        tags.landuse === 'military' || 
                        tags.dog === 'no' ||
                        // Additional fee-based attraction tags
                        tags.admission ||
                        (tags.leisure === 'garden' && tags.tourism) || // Botanical gardens that are tourist attractions
                        (tags.tourism === 'attraction' && tags.leisure === 'garden') ||
                        (tags.name && tags.name.toLowerCase().includes('botanical')) ||
                        (tags.name && tags.name.toLowerCase().includes('vandusen')) ||
                        // Common patterns for fee-based venues
                        (tags.tourism === 'zoo') ||
                        (tags.tourism === 'museum') ||
                        (tags.tourism === 'theme_park');
                    
                    if (isRestrictedElement) {
                        console.log(`Found restricted element: ${tags.name || 'Unnamed'} with tags:`, tags);
                        // Check proximity to restricted areas
                        for (const node of element.geometry) {
                            const distance = calculateDistance(pointLat, pointLng, node.lat, node.lon);
                            // If within 15 meters of a restricted area, consider it restricted
                            if (distance < 15) {
                                console.log(`Point ${pointLat.toFixed(6)}, ${pointLng.toFixed(6)} is ${distance.toFixed(1)}m from restricted area: ${tags.name || 'Unnamed'}`);
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        // Show restricted areas that are excluded from walkable detection
        async function showRestrictedAreas() {
            if (!map) {
                alert('Please load the map first!');
                return;
            }

            const button = document.getElementById('restrictedBtn');
            const originalText = button.textContent;
            button.textContent = 'üîç Finding restrictions...';
            button.disabled = true;

            try {
                const center = map.getCenter();
                const radius = parseInt(document.getElementById('radius').value);
                
                // Query for restricted areas
                const restrictedData = await queryRestrictedAreas(center.lat, center.lng, radius);
                
                if (restrictedData && restrictedData.elements && restrictedData.elements.length > 0) {
                    displayRestrictedAreasInfo(restrictedData.elements);
                    button.textContent = '‚úÖ Restrictions found!';
                } else {
                    alert('No specifically tagged restricted areas found in this area.\n\nThis could mean:\n‚Ä¢ Area has good public access\n‚Ä¢ OSM data may not have detailed access tags\n‚Ä¢ Your pay-to-enter garden might not be tagged with fee=yes');
                    button.textContent = 'ü§∑ No restrictions found';
                }
                
            } catch (error) {
                console.error('Error finding restricted areas:', error);
                button.textContent = '‚ùå Query failed';
            }
            
            setTimeout(() => {
                button.textContent = originalText;
                button.disabled = false;
            }, 3000);
        }

        // Query OpenStreetMap for restricted/fee-based areas
        async function queryRestrictedAreas(lat, lng, radius) {
            const overpassUrl = 'https://overpass-api.de/api/interpreter';
            
            const query = `
                [out:json][timeout:25];
                (
                  // Fee-based areas (like your pay-to-enter garden)
                  way["fee"="yes"](around:${radius},${lat},${lng});
                  rel["fee"="yes"](around:${radius},${lat},${lng});
                  
                  // Private access areas
                  way["access"="private"](around:${radius},${lat},${lng});
                  way["access"="no"](around:${radius},${lat},${lng});
                  
                  // Customer-only areas
                  way["access"="customers"](around:${radius},${lat},${lng});
                  rel["access"="customers"](around:${radius},${lat},${lng});
                  
                  // Military or restricted areas
                  way["landuse"="military"](around:${radius},${lat},${lng});
                  
                  // Dog-restricted areas
                  way["dog"="no"](around:${radius},${lat},${lng});
                );
                out geom;
            `;

            try {
                const response = await fetch(overpassUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: 'data=' + encodeURIComponent(query)
                });

                const data = await response.json();
                console.log('Restricted areas data:', data.elements?.length || 0, 'elements');
                return data;
                
            } catch (error) {
                console.error('Error querying restricted areas:', error);
                return null;
            }
        }

        // Display information about restricted areas found
        function displayRestrictedAreasInfo(restrictedElements) {
            let restrictionTypes = {};
            
            restrictedElements.forEach(element => {
                const tags = element.tags || {};
                
                if (tags.fee === 'yes') {
                    restrictionTypes['Fee-based (pay-to-enter)'] = (restrictionTypes['Fee-based (pay-to-enter)'] || 0) + 1;
                }
                if (tags.access === 'private') {
                    restrictionTypes['Private access'] = (restrictionTypes['Private access'] || 0) + 1;
                }
                if (tags.access === 'no') {
                    restrictionTypes['No access'] = (restrictionTypes['No access'] || 0) + 1;
                }
                if (tags.access === 'customers') {
                    restrictionTypes['Customers only'] = (restrictionTypes['Customers only'] || 0) + 1;
                }
                if (tags.landuse === 'military') {
                    restrictionTypes['Military/restricted'] = (restrictionTypes['Military/restricted'] || 0) + 1;
                }
                if (tags.dog === 'no') {
                    restrictionTypes['No dogs allowed'] = (restrictionTypes['No dogs allowed'] || 0) + 1;
                }
            });
            
            let message = `üö´ Found ${restrictedElements.length} restricted areas:\n\n`;
            
            for (const [type, count] of Object.entries(restrictionTypes)) {
                message += `‚Ä¢ ${type}: ${count}\n`;
            }
            
            message += `\nüí° These areas are excluded from walkable detection because they have access restrictions that matter for everyday dog walking.`;
            
            alert(message);
        }

        // Debug function to show all OSM data in the area
        async function debugOSMData() {
            if (!map) {
                alert('Please load the map first!');
                return;
            }

            const button = document.getElementById('debugBtn');
            const originalText = button.textContent;
            button.textContent = 'üîç Gathering data...';
            button.disabled = true;

            try {
                const center = map.getCenter();
                const radius = parseInt(document.getElementById('radius').value);
                
                // Query for ALL relevant areas (walkable AND restricted)
                const [walkableData, restrictedData] = await Promise.all([
                    queryWalkableAreas(center.lat, center.lng, radius),
                    queryRestrictedAreas(center.lat, center.lng, radius)
                ]);
                
                // Also query specifically for botanical gardens, museums, etc.
                const specialData = await querySpecialAreas(center.lat, center.lng, radius);
                
                // Combine and analyze
                const allElements = [
                    ...(walkableData?.elements || []),
                    ...(restrictedData?.elements || []),
                    ...(specialData?.elements || [])
                ];
                
                displayOSMDebugInfo(allElements);
                button.textContent = '‚úÖ Data analyzed!';
                
            } catch (error) {
                console.error('Debug error:', error);
                button.textContent = '‚ùå Debug failed';
            }
            
            setTimeout(() => {
                button.textContent = originalText;
                button.disabled = false;
            }, 3000);
        }

        // Query for special fee-based areas that might use different tags
        async function querySpecialAreas(lat, lng, radius) {
            const overpassUrl = 'https://overpass-api.de/api/interpreter';
            
            const query = `
                [out:json][timeout:25];
                (
                  // Botanical gardens, museums, attractions
                  way["leisure"="garden"](around:${radius},${lat},${lng});
                  way["tourism"~"^(attraction|museum|zoo|theme_park)$"](around:${radius},${lat},${lng});
                  rel["leisure"="garden"](around:${radius},${lat},${lng});
                  rel["tourism"~"^(attraction|museum|zoo|theme_park)$"](around:${radius},${lat},${lng});
                  
                  // Anything with admission fees using different tags
                  way["admission"](around:${radius},${lat},${lng});
                  rel["admission"](around:${radius},${lat},${lng});
                  
                  // Places with opening hours (often indicates restricted access)
                  way["opening_hours"](around:${radius},${lat},${lng});
                  rel["opening_hours"](around:${radius},${lat},${lng});
                );
                out geom;
            `;

            try {
                const response = await fetch(overpassUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: 'data=' + encodeURIComponent(query)
                });

                const data = await response.json();
                console.log('Special areas data:', data.elements?.length || 0, 'elements');
                return data;
                
            } catch (error) {
                console.error('Error querying special areas:', error);
                return null;
            }
        }

        // Display detailed OSM debug information
        function displayOSMDebugInfo(elements) {
            let debugInfo = `üîç OSM Debug Report\n\n`;
            debugInfo += `Found ${elements.length} total elements in your area:\n\n`;
            
            const categorizedElements = {
                'Botanical Gardens': [],
                'Tourism/Attractions': [],
                'Parks/Recreation': [],
                'Fee-based Areas': [],
                'Access Restricted': [],
                'Roads/Walkways': [],
                'Other': []
            };
            
            elements.forEach(element => {
                const tags = element.tags || {};
                const name = tags.name || 'Unnamed';
                
                if (tags.leisure === 'garden' || (tags.name && tags.name.toLowerCase().includes('garden'))) {
                    categorizedElements['Botanical Gardens'].push({name, tags, element});
                } else if (tags.tourism) {
                    categorizedElements['Tourism/Attractions'].push({name, tags, element});
                } else if (tags.fee === 'yes' || tags.admission) {
                    categorizedElements['Fee-based Areas'].push({name, tags, element});
                } else if (tags.access === 'private' || tags.access === 'no' || tags.access === 'customers') {
                    categorizedElements['Access Restricted'].push({name, tags, element});
                } else if (tags.leisure === 'park' || tags.landuse === 'recreation_ground') {
                    categorizedElements['Parks/Recreation'].push({name, tags, element});
                } else if (tags.highway) {
                    categorizedElements['Roads/Walkways'].push({name, tags, element});
                } else {
                    categorizedElements['Other'].push({name, tags, element});
                }
            });
            
            for (const [category, items] of Object.entries(categorizedElements)) {
                if (items.length > 0) {
                    debugInfo += `üìç ${category} (${items.length}):\n`;
                    items.slice(0, 5).forEach(item => { // Show first 5 items
                        debugInfo += `  ‚Ä¢ ${item.name}\n`;
                        debugInfo += `    Tags: ${Object.entries(item.tags).map(([k,v]) => `${k}=${v}`).join(', ')}\n`;
                    });
                    if (items.length > 5) {
                        debugInfo += `  ... and ${items.length - 5} more\n`;
                    }
                    debugInfo += `\n`;
                }
            }
            
            // Specific analysis for VanDusen Gardens
            const vandusenElements = elements.filter(el => 
                el.tags?.name && el.tags.name.toLowerCase().includes('vandusen')
            );
            
            if (vandusenElements.length > 0) {
                debugInfo += `üåø VanDusen Gardens Analysis:\n`;
                vandusenElements.forEach(el => {
                    debugInfo += `  ‚Ä¢ Name: ${el.tags.name}\n`;
                    debugInfo += `  ‚Ä¢ All tags: ${JSON.stringify(el.tags, null, 2)}\n`;
                });
                debugInfo += `\n`;
            }
            
            debugInfo += `üí° If VanDusen Gardens shows as green (walkable), it means OSM data doesn't include proper restriction tags like fee=yes or access=private.`;
            
            // Show in a scrollable dialog
            const textarea = document.createElement('textarea');
            textarea.value = debugInfo;
            textarea.style.width = '80vw';
            textarea.style.height = '60vh';
            textarea.style.fontFamily = 'monospace';
            textarea.style.fontSize = '12px';
            
            const modal = document.createElement('div');
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100%';
            modal.style.height = '100%';
            modal.style.backgroundColor = 'rgba(0,0,0,0.8)';
            modal.style.display = 'flex';
            modal.style.alignItems = 'center';
            modal.style.justifyContent = 'center';
            modal.style.zIndex = '10000';
            
            const container = document.createElement('div');
            container.style.backgroundColor = 'white';
            container.style.padding = '20px';
            container.style.borderRadius = '8px';
            container.style.maxWidth = '90vw';
            container.style.maxHeight = '90vh';
            container.style.overflow = 'auto';
            
            const closeButton = document.createElement('button');
            closeButton.textContent = '‚úï Close';
            closeButton.style.marginBottom = '10px';
            closeButton.onclick = () => document.body.removeChild(modal);
            
            container.appendChild(closeButton);
            container.appendChild(textarea);
            modal.appendChild(container);
            document.body.appendChild(modal);
        }

        // Calculate distance between two points in meters using Haversine formula
        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 6371e3; // Earth's radius in meters
            const œÜ1 = lat1 * Math.PI/180;
            const œÜ2 = lat2 * Math.PI/180;
            const ŒîœÜ = (lat2-lat1) * Math.PI/180;
            const ŒîŒª = (lng2-lng1) * Math.PI/180;

            const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
                      Math.cos(œÜ1) * Math.cos(œÜ2) *
                      Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c; // Distance in meters
        }

        // Variables to store raw data overlays
        let rawDataLayers = [];
        let rawDataVisible = false;
        let enhancedDetectionEnabled = false;
        
        // Segment mode variables
        let segmentMode = false;
        let segmentLayers = [];
        let walkedSegments = new Map(); // segmentId -> {progress: number, completed: boolean, touchPoints: array} // Store IDs of segments that have been "walked"
        let subSegments = []; // Store subdivided segments for granular tracking
        
        // Test walk variables
        let isTestWalking = false;
        let testWalkMarker = null;
        let testWalkPath = [];
        let testWalkTimer = null;
        let testWalkIndex = 0;

        // Toggle raw OSM data overlay on the map
        async function toggleRawDataOverlay() {
            if (!map) {
                alert('Please load the map first!');
                return;
            }

            const button = document.getElementById('rawDataBtn');
            
            if (rawDataVisible) {
                // Remove existing overlays
                clearRawDataOverlays();
                button.textContent = 'üìä Show Raw OSM Data';
                rawDataVisible = false;
                return;
            }

            const originalText = button.textContent;
            button.textContent = 'üîç Loading OSM data...';
            button.disabled = true;

            try {
                const center = map.getCenter();
                const radius = parseInt(document.getElementById('radius').value);
                
                console.log('Loading raw OSM data for visualization...');
                
                // Get both walkable and restricted areas data
                const [walkableData, restrictedData, specialData] = await Promise.all([
                    queryWalkableAreas(center.lat, center.lng, radius),
                    queryRestrictedAreas(center.lat, center.lng, radius),
                    querySpecialAreas(center.lat, center.lng, radius)
                ]);
                
                // Create overlays for different types of data
                if (walkableData?.elements) {
                    createDataOverlay(walkableData.elements, 'walkable', '#22c55e', 'Walkable areas from OSM');
                }
                
                if (restrictedData?.elements) {
                    createDataOverlay(restrictedData.elements, 'restricted', '#ef4444', 'Restricted areas from OSM');
                }
                
                if (specialData?.elements) {
                    createDataOverlay(specialData.elements, 'special', '#a855f7', 'Special areas (gardens, tourism)');
                }
                
                button.textContent = '‚úÖ Raw data visible';
                rawDataVisible = true;
                
                // Add legend for raw data
                showRawDataLegend();
                
            } catch (error) {
                console.error('Error loading raw data:', error);
                button.textContent = '‚ùå Failed to load';
            }
            
            setTimeout(() => {
                if (rawDataVisible) {
                    button.textContent = 'üóëÔ∏è Hide Raw OSM Data';
                }
                button.disabled = false;
            }, 2000);
        }

        // Create overlay for specific data type
        function createDataOverlay(elements, type, color, description) {
            const layerGroup = L.layerGroup();
            let addedFeatures = 0;
            
            elements.forEach((element, index) => {
                if (element.type === 'way' && element.geometry) {
                    const coordinates = element.geometry.map(node => [node.lat, node.lon]);
                    
                    if (coordinates.length >= 2) {
                        const tags = element.tags || {};
                        const name = tags.name || `Unnamed ${type} feature`;
                        
                        // Create polyline for ways
                        const polyline = L.polyline(coordinates, {
                            color: color,
                            weight: 3,
                            opacity: 0.7
                        });
                        
                        // Create popup with detailed information
                        const tagsList = Object.entries(tags)
                            .map(([key, value]) => `<strong>${key}:</strong> ${value}`)
                            .join('<br>');
                        
                        polyline.bindPopup(`
                            <div style="max-width: 300px;">
                                <h4 style="margin: 0 0 8px 0; color: ${color};">${name}</h4>
                                <p style="margin: 0 0 8px 0; font-size: 12px; color: #666;">
                                    ${description} ‚Ä¢ ID: ${element.id}
                                </p>
                                <div style="max-height: 200px; overflow-y: auto; font-size: 11px;">
                                    ${tagsList}
                                </div>
                            </div>
                        `);
                        
                        layerGroup.addLayer(polyline);
                        addedFeatures++;
                    }
                } else if (element.type === 'relation' && element.members) {
                    // Handle relations (like parks that are relations)
                    const tags = element.tags || {};
                    const name = tags.name || `Unnamed ${type} relation`;
                    
                    // For relations, we'll just show a marker at the center if we can calculate it
                    // This is simplified - in reality, you'd need to resolve the relation members
                    if (element.center) {
                        const marker = L.circleMarker([element.center.lat, element.center.lon], {
                            color: color,
                            fillColor: color,
                            fillOpacity: 0.5,
                            radius: 8
                        });
                        
                        const tagsList = Object.entries(tags)
                            .map(([key, value]) => `<strong>${key}:</strong> ${value}`)
                            .join('<br>');
                        
                        marker.bindPopup(`
                            <div style="max-width: 300px;">
                                <h4 style="margin: 0 0 8px 0; color: ${color};">${name}</h4>
                                <p style="margin: 0 0 8px 0; font-size: 12px; color: #666;">
                                    ${description} (Relation) ‚Ä¢ ID: ${element.id}
                                </p>
                                <div style="max-height: 200px; overflow-y: auto; font-size: 11px;">
                                    ${tagsList}
                                </div>
                            </div>
                        `);
                        
                        layerGroup.addLayer(marker);
                        addedFeatures++;
                    }
                }
            });
            
            if (addedFeatures > 0) {
                layerGroup.addTo(map);
                rawDataLayers.push(layerGroup);
                console.log(`Added ${addedFeatures} ${type} features to map`);
            } else {
                console.log(`No ${type} features found to display`);
            }
        }

        // Clear all raw data overlays
        function clearRawDataOverlays() {
            rawDataLayers.forEach(layer => {
                map.removeLayer(layer);
            });
            rawDataLayers = [];
            hideRawDataLegend();
        }

        // Show legend for raw data overlays
        function showRawDataLegend() {
            // Remove existing raw data legend if it exists
            hideRawDataLegend();
            
            const legendDiv = document.createElement('div');
            legendDiv.id = 'raw-data-legend';
            legendDiv.innerHTML = `
                <div style="position: absolute; top: 10px; right: 10px; background: white; padding: 12px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.3); z-index: 1000; font-size: 12px; min-width: 200px;">
                    <h4 style="margin: 0 0 8px 0; color: #1f2937;">üó∫Ô∏è Raw OSM Data</h4>
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                        <div style="width: 16px; height: 3px; background: #22c55e;"></div>
                        <span>Walkable areas</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                        <div style="width: 16px; height: 3px; background: #ef4444;"></div>
                        <span>Restricted areas</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                        <div style="width: 16px; height: 3px; background: #a855f7;"></div>
                        <span>Special areas</span>
                    </div>
                    <div style="font-size: 10px; color: #666; border-top: 1px solid #eee; padding-top: 6px;">
                        Click any line/marker for details
                    </div>
                </div>
            `;
            
            document.querySelector('.map-container').appendChild(legendDiv);
        }

        // Hide raw data legend
        function hideRawDataLegend() {
            const legend = document.getElementById('raw-data-legend');
            if (legend) {
                legend.remove();
            }
        }

        // Toggle enhanced geometric detection
        function toggleEnhancedDetection() {
            enhancedDetectionEnabled = !enhancedDetectionEnabled;
            const button = document.getElementById('enhancedBtn');
            
            if (enhancedDetectionEnabled) {
                button.textContent = 'üéØ Enhanced: ON';
                button.style.background = '#22c55e';
                console.log('‚úÖ Enhanced geometric detection enabled - will check grid cell boundaries vs OSM geometry');
            } else {
                button.textContent = 'üéØ Enhanced Detection';
                button.style.background = '#4f46e5';
                console.log('‚ùå Enhanced detection disabled - using center-point method');
            }
        }

        // Calculate grid cell boundary coordinates - FIXED to match visual grid positioning
        function getGridCellBounds(row, col, gridSize, bounds) {
            const northeast = bounds.getNorthEast();
            const southwest = bounds.getSouthWest();
            
            const latRange = northeast.lat - southwest.lat;
            const lngRange = northeast.lng - southwest.lng;
            
            // Get the map container dimensions (same as visual grid calculation)
            const mapContainer = map.getContainer();
            const containerWidth = mapContainer.clientWidth;
            const containerHeight = mapContainer.clientHeight;
            
            // Use the smaller dimension to match visual grid (creates square cells)
            const smallerDimension = Math.min(containerWidth, containerHeight);
            
            // Calculate how much of the map bounds the grid actually covers
            const gridWidthRatio = smallerDimension / containerWidth;
            const gridHeightRatio = smallerDimension / containerHeight;
            
            // Calculate the actual lat/lng range covered by the grid (not full bounds)
            const gridLatRange = latRange * gridHeightRatio;
            const gridLngRange = lngRange * gridWidthRatio;
            
            // Calculate centering offsets in geographic coordinates
            const latOffset = (latRange - gridLatRange) / 2;
            const lngOffset = (lngRange - gridLngRange) / 2;
            
            // Calculate the southwest corner of the grid area (not the map bounds)
            const gridSouthwest = {
                lat: southwest.lat + latOffset,
                lng: southwest.lng + lngOffset
            };
            
            // Calculate cell boundaries within the actual grid area
            const cellLatMin = gridSouthwest.lat + (gridLatRange * (1 - (row + 1) / gridSize));
            const cellLatMax = gridSouthwest.lat + (gridLatRange * (1 - row / gridSize));
            const cellLngMin = gridSouthwest.lng + (gridLngRange * col / gridSize);
            const cellLngMax = gridSouthwest.lng + (gridLngRange * (col + 1) / gridSize);
            
            return {
                north: cellLatMax,
                south: cellLatMin,
                east: cellLngMax,
                west: cellLngMin,
                center: {
                    lat: (cellLatMin + cellLatMax) / 2,
                    lng: (cellLngMin + cellLngMax) / 2
                },
                // Debug info
                debug: {
                    gridWidthRatio: gridWidthRatio.toFixed(3),
                    gridHeightRatio: gridHeightRatio.toFixed(3),
                    containerDimensions: `${containerWidth}x${containerHeight}`,
                    smallerDimension: smallerDimension
                }
            };
        }

        // Check if a line segment intersects with a rectangle (grid cell)
        function lineIntersectsRect(x1, y1, x2, y2, rectWest, rectSouth, rectEast, rectNorth) {
            // Check if line is completely inside rectangle
            if (pointInRect(x1, y1, rectWest, rectSouth, rectEast, rectNorth) || 
                pointInRect(x2, y2, rectWest, rectSouth, rectEast, rectNorth)) {
                return true;
            }
            
            // Check line intersection with each edge of rectangle
            return (
                lineIntersectsLine(x1, y1, x2, y2, rectWest, rectSouth, rectEast, rectSouth) || // bottom edge
                lineIntersectsLine(x1, y1, x2, y2, rectEast, rectSouth, rectEast, rectNorth) || // right edge
                lineIntersectsLine(x1, y1, x2, y2, rectEast, rectNorth, rectWest, rectNorth) || // top edge
                lineIntersectsLine(x1, y1, x2, y2, rectWest, rectNorth, rectWest, rectSouth)    // left edge
            );
        }

        // Check if point is inside rectangle
        function pointInRect(x, y, west, south, east, north) {
            return x >= west && x <= east && y >= south && y <= north;
        }

        // Check if two line segments intersect
        function lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) {
            const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (Math.abs(denom) < 1e-10) return false; // parallel lines
            
            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
            
            return t >= 0 && t <= 1 && u >= 0 && u <= 1;
        }

        // Enhanced check for walkable areas using geometric intersection
        function checkGridCellIntersectsWalkableAreas(cellBounds, osmElements) {
            // First, find all restricted areas for proximity checking
            const restrictedAreas = osmElements.filter(element => {
                const tags = element.tags || {};
                return tags.fee === 'yes' || 
                       tags.access === 'private' || 
                       tags.access === 'no' || 
                       tags.access === 'customers' ||
                       tags.landuse === 'military' || 
                       tags.dog === 'no' ||
                       tags.admission ||
                       (tags.leisure === 'garden' && tags.tourism) ||
                       (tags.tourism === 'attraction' && tags.leisure === 'garden') ||
                       (tags.name && tags.name.toLowerCase().includes('botanical')) ||
                       (tags.name && tags.name.toLowerCase().includes('vandusen')) ||
                       (tags.tourism === 'zoo') ||
                       (tags.tourism === 'museum') ||
                       (tags.tourism === 'theme_park');
            });
            
            for (const element of osmElements) {
                if (element.type === 'way' && element.geometry && element.geometry.length >= 2) {
                    const tags = element.tags || {};
                    const isRestrictedElement = tags.fee === 'yes' || tags.access === 'private' || 
                                              tags.access === 'no' || tags.access === 'customers' ||
                                              tags.landuse === 'military' || tags.dog === 'no';
                    
                    if (!isRestrictedElement) {
                        // Check if this path is inside or very close to a restricted area
                        const isNearRestrictedArea = checkIfPathNearRestrictedAreas(element, restrictedAreas);
                        
                        if (!isNearRestrictedArea) {
                            // Check if any segment of this OSM way intersects with the grid cell
                            for (let i = 0; i < element.geometry.length - 1; i++) {
                                const node1 = element.geometry[i];
                                const node2 = element.geometry[i + 1];
                                
                                if (lineIntersectsRect(
                                    node1.lon, node1.lat, 
                                    node2.lon, node2.lat,
                                    cellBounds.west, cellBounds.south, 
                                    cellBounds.east, cellBounds.north
                                )) {
                                    console.log(`Geometric intersection found: ${tags.name || tags.highway || 'unnamed'} crosses grid cell`);
                                    return {
                                        intersects: true,
                                        feature: tags.name || tags.highway || 'unnamed feature',
                                        type: tags.highway || tags.leisure || 'unknown'
                                    };
                                }
                            }
                            
                            // Also check if any nodes are within the cell bounds
                            for (const node of element.geometry) {
                                if (pointInRect(node.lon, node.lat, cellBounds.west, cellBounds.south, cellBounds.east, cellBounds.north)) {
                                    console.log(`Point intersection found: ${tags.name || tags.highway || 'unnamed'} has nodes in grid cell`);
                                    return {
                                        intersects: true,
                                        feature: tags.name || tags.highway || 'unnamed feature',
                                        type: tags.highway || tags.leisure || 'unknown'
                                    };
                                }
                            }
                        } else {
                            console.log(`Skipping path near restricted area: ${tags.name || tags.highway || 'unnamed'}`);
                        }
                    }
                }
            }
            return { intersects: false };
        }

        // Check if a path is near any restricted areas (to exclude VanDusen internal paths)
        function checkIfPathNearRestrictedAreas(pathElement, restrictedAreas) {
            if (!pathElement.geometry || restrictedAreas.length === 0) return false;
            
            const pathTags = pathElement.tags || {};
            
            // Special handling for paths that might be inside fee-based attractions
            for (const restrictedArea of restrictedAreas) {
                if (!restrictedArea.geometry) continue;
                
                const restrictedTags = restrictedArea.tags || {};
                
                // Check if any point of the path is close to the restricted area
                for (const pathNode of pathElement.geometry) {
                    for (const restrictedNode of restrictedArea.geometry) {
                        const distance = calculateDistance(
                            pathNode.lat, pathNode.lon,
                            restrictedNode.lat, restrictedNode.lon
                        );
                        
                        // If path is within 50m of a restricted area, consider it part of that area
                        if (distance < 50) {
                            console.log(`Path ${pathTags.name || pathTags.highway || 'unnamed'} is ${distance.toFixed(1)}m from restricted area ${restrictedTags.name || 'unnamed'}`);
                            return true;
                        }
                    }
                }
            }
            
            return false;
        }

        // Enhanced check for restricted areas using geometric intersection
        function checkGridCellIntersectsRestrictedAreas(cellBounds, osmElements) {
            for (const element of osmElements) {
                if (element.type === 'way' && element.geometry && element.geometry.length >= 2) {
                    const tags = element.tags || {};
                    const isRestrictedElement = 
                        tags.fee === 'yes' || 
                        tags.access === 'private' || 
                        tags.access === 'no' || 
                        tags.access === 'customers' ||
                        tags.landuse === 'military' || 
                        tags.dog === 'no' ||
                        tags.admission ||
                        (tags.leisure === 'garden' && tags.tourism) ||
                        (tags.tourism === 'attraction' && tags.leisure === 'garden') ||
                        (tags.name && tags.name.toLowerCase().includes('botanical')) ||
                        (tags.name && tags.name.toLowerCase().includes('vandusen')) ||
                        (tags.tourism === 'zoo') ||
                        (tags.tourism === 'museum') ||
                        (tags.tourism === 'theme_park');
                    
                    if (isRestrictedElement) {
                        // Check geometric intersection
                        for (let i = 0; i < element.geometry.length - 1; i++) {
                            const node1 = element.geometry[i];
                            const node2 = element.geometry[i + 1];
                            
                            if (lineIntersectsRect(
                                node1.lon, node1.lat, 
                                node2.lon, node2.lat,
                                cellBounds.west, cellBounds.south, 
                                cellBounds.east, cellBounds.north
                            )) {
                                console.log(`Restricted area intersection found: ${tags.name || 'unnamed'} crosses grid cell`);
                                return {
                                    intersects: true,
                                    feature: tags.name || 'unnamed restricted area',
                                    type: tags.tourism || tags.leisure || 'restricted'
                                };
                            }
                        }
                        
                        // Check if any nodes are within the cell bounds
                        for (const node of element.geometry) {
                            if (pointInRect(node.lon, node.lat, cellBounds.west, cellBounds.south, cellBounds.east, cellBounds.north)) {
                                console.log(`Restricted area point found: ${tags.name || 'unnamed'} has nodes in grid cell`);
                                return {
                                    intersects: true,
                                    feature: tags.name || 'unnamed restricted area',
                                    type: tags.tourism || tags.leisure || 'restricted'
                                };
                            }
                        }
                    }
                }
            }
            return { intersects: false };
        }

        // Debug specific cell intersection
        async function debugSpecificCell() {
            if (!map || gridCells.length === 0) {
                alert('Please load map and generate grid first!');
                return;
            }

            const button = document.getElementById('debugCellBtn');
            const originalText = button.textContent;
            button.textContent = 'üî¨ Click a cell to debug...';
            button.style.background = '#f59e0b';

            // Add temporary click handler to grid cells
            const debugClickHandler = async (event) => {
                const cell = event.target;
                if (!cell.classList.contains('grid-cell')) return;

                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const gridSize = parseInt(document.getElementById('grid-size').value);

                console.log(`\nüî¨ DEBUGGING CELL ${row},${col}`);
                
                // Get cell bounds
                const bounds = map.getBounds();
                const cellBounds = getGridCellBounds(row, col, gridSize, bounds);
                
                console.log('Cell Bounds:', cellBounds);
                console.log('Grid Scaling Debug:', cellBounds.debug);
                
                // Get fresh OSM data for this area
                try {
                    button.textContent = 'üîç Analyzing intersection...';
                    
                    const center = map.getCenter();
                    const radius = parseInt(document.getElementById('radius').value);
                    const osmData = await queryWalkableAreas(center.lat, center.lng, radius);
                    
                    console.log(`Found ${osmData?.elements?.length || 0} OSM elements total`);
                    
                    // Check each OSM element against this specific cell
                    let intersectionCount = 0;
                    let walkableIntersections = [];
                    
                    if (osmData?.elements) {
                        osmData.elements.forEach((element, idx) => {
                            if (element.type === 'way' && element.geometry && element.geometry.length >= 2) {
                                const tags = element.tags || {};
                                const featureName = tags.name || tags.highway || `Element-${idx}`;
                                
                                // Check each line segment
                                for (let i = 0; i < element.geometry.length - 1; i++) {
                                    const node1 = element.geometry[i];
                                    const node2 = element.geometry[i + 1];
                                    
                                    const intersects = lineIntersectsRect(
                                        node1.lon, node1.lat, 
                                        node2.lon, node2.lat,
                                        cellBounds.west, cellBounds.south, 
                                        cellBounds.east, cellBounds.north
                                    );
                                    
                                    if (intersects) {
                                        intersectionCount++;
                                        walkableIntersections.push({
                                            feature: featureName,
                                            segment: i,
                                            from: `${node1.lat.toFixed(6)}, ${node1.lon.toFixed(6)}`,
                                            to: `${node2.lat.toFixed(6)}, ${node2.lon.toFixed(6)}`,
                                            tags: tags
                                        });
                                        console.log(`‚úÖ INTERSECTION ${intersectionCount}: ${featureName} segment ${i}`);
                                        console.log(`   From: ${node1.lat.toFixed(6)}, ${node1.lon.toFixed(6)}`);
                                        console.log(`   To: ${node2.lat.toFixed(6)}, ${node2.lon.toFixed(6)}`);
                                        console.log(`   Tags:`, tags);
                                    }
                                }
                            }
                        });
                    }
                    
                    // Show results
                    const currentState = cell.dataset.state;
                    console.log(`\nüìä CELL ${row},${col} ANALYSIS:`);
                    console.log(`   Current state: ${currentState}`);
                    console.log(`   Found ${intersectionCount} intersections with walkable features`);
                    console.log(`   Cell bounds: ${cellBounds.south.toFixed(6)} to ${cellBounds.north.toFixed(6)} lat, ${cellBounds.west.toFixed(6)} to ${cellBounds.east.toFixed(6)} lng`);
                    
                    if (intersectionCount > 0 && currentState !== 'walkable') {
                        console.log(`‚ö†Ô∏è  MISMATCH: Cell has ${intersectionCount} walkable intersections but is marked as "${currentState}"`);
                        
                        // Create detailed alert
                        let alertMessage = `üî¨ CELL ${row},${col} DEBUG RESULTS:\n\n`;
                        alertMessage += `Current state: ${currentState}\n`;
                        alertMessage += `Found ${intersectionCount} walkable intersections!\n\n`;
                        
                        if (walkableIntersections.length > 0) {
                            alertMessage += `Intersecting features:\n`;
                            walkableIntersections.slice(0, 3).forEach((intersection, idx) => {
                                alertMessage += `${idx + 1}. ${intersection.feature}\n`;
                            });
                            if (walkableIntersections.length > 3) {
                                alertMessage += `... and ${walkableIntersections.length - 3} more\n`;
                            }
                        }
                        
                        alertMessage += `\nThis suggests the intersection detection isn't working properly for this cell.`;
                        alert(alertMessage);
                    } else if (intersectionCount === 0 && currentState === 'walkable') {
                        alert(`üî¨ CELL ${row},${col}: No intersections found but marked as walkable.\nThis could be from center-point detection or restricted area logic.`);
                    } else {
                        alert(`üî¨ CELL ${row},${col}: ${intersectionCount} intersections found, state "${currentState}" appears correct.`);
                    }
                    
                } catch (error) {
                    console.error('Debug error:', error);
                    alert('Debug failed: ' + error.message);
                }
                
                // Remove click handlers and reset button
                gridCells.forEach(c => c.removeEventListener('click', debugClickHandler));
                button.textContent = originalText;
                button.style.background = '#4f46e5';
            };

            // Add click handlers to all grid cells
            gridCells.forEach(cell => {
                cell.addEventListener('click', debugClickHandler);
            });

            // Reset button after 30 seconds
            setTimeout(() => {
                gridCells.forEach(cell => cell.removeEventListener('click', debugClickHandler));
                if (button.textContent.includes('Click a cell')) {
                    button.textContent = originalText;
                    button.style.background = '#4f46e5';
                }
            }, 30000);
        }

        // Toggle segment visualization mode (Strava-style)
        async function toggleSegmentMode() {
            if (!map) {
                alert('Please load the map first!');
                return;
            }

            const button = document.getElementById('segmentBtn');
            
            if (segmentMode) {
                // Turn off segment mode
                clearSegmentOverlays();
                segmentMode = false;
                button.textContent = 'üõ£Ô∏è Segment Mode (Prototype)';
                button.style.background = '';
                console.log('‚ùå Segment mode disabled');
            } else {
                // Turn on segment mode
                segmentMode = true;
                button.textContent = 'üõ£Ô∏è Segment Mode: ON';
                button.style.background = '#3b82f6';
                button.disabled = true;
                
                console.log('‚úÖ Segment mode enabled - Loading walkable segments...');
                
                try {
                    await renderWalkableSegments();
                    button.disabled = false;
                    console.log('‚úÖ Segment visualization ready! Click segments to mark as walked.');
                } catch (error) {
                    console.error('‚ùå Error loading segments:', error);
                    button.disabled = false;
                    button.textContent = 'üõ£Ô∏è Segment Mode (ERROR)';
                    button.style.background = '#ef4444';
                }
            }
        }

        // Calculate appropriate radius based on map bounds
        function calculateRadius(bounds) {
            const center = map.getCenter();
            const ne = bounds.getNorthEast();
            
            // Calculate distance from center to northeast corner
            const distance = calculateDistance(center.lat, center.lng, ne.lat, ne.lng);
            
            // Use a reasonable radius - much smaller than the full bounds
            // For neighborhood walking, 400-800m is more realistic
            const radius = Math.min(Math.max(distance * 0.3, 200), 800); // Between 200m and 800m
            
            return Math.round(radius);
        }

        // Render all walkable segments as interactive polylines
        async function renderWalkableSegments() {
            const center = map.getCenter();
            const bounds = map.getBounds();
            const radius = calculateRadius(bounds);
            
            console.log(`Loading walkable segments within ${radius}m of ${center.lat.toFixed(6)}, ${center.lng.toFixed(6)}`);
            
            // Get OSM data for walkable areas
            const osmData = await queryWalkableAreas(center.lat, center.lng, radius);
            if (!osmData || !osmData.elements) {
                throw new Error('Failed to load OSM data - no elements received');
            }
            
            console.log(`Received ${osmData.elements.length} OSM elements for segment processing`);
            
            // Clear existing segment overlays
            clearSegmentOverlays();
            
            // First pass: identify all intersections and nearby sidewalks
            const intersections = new Set();
            const sidewalksByLocation = new Map(); // location key -> sidewalk ways
            const roadsByLocation = new Map(); // location key -> road ways
            
            // Find intersections (nodes shared by multiple ways)
            const nodeUsage = new Map(); // nodeId -> count
            for (const element of osmData.elements) {
                if (element.type === 'way' && element.geometry) {
                    for (const node of element.geometry) {
                        const nodeId = `${node.lat.toFixed(6)},${node.lon.toFixed(6)}`;
                        nodeUsage.set(nodeId, (nodeUsage.get(nodeId) || 0) + 1);
                    }
                }
            }
            
            // Mark intersections (nodes used by 2+ ways)
            for (const [nodeId, count] of nodeUsage) {
                if (count >= 2) {
                    intersections.add(nodeId);
                }
            }
            
            // Categorize ways and group by proximity
            for (const element of osmData.elements) {
                if (element.type === 'way' && element.geometry && element.geometry.length >= 2) {
                    const tags = element.tags || {};
                    
                    // Skip restricted elements
                    const isRestrictedElement = tags.fee === 'yes' || tags.access === 'private' || 
                                              tags.access === 'no' || tags.access === 'customers' ||
                                              tags.landuse === 'military' || tags.dog === 'no';
                    if (isRestrictedElement) continue;
                    
                    const isRoad = tags.highway && tags.highway.match(/^(primary|secondary|tertiary|residential|unclassified)$/);
                    const isSidewalk = tags.highway === 'footway' || tags.highway === 'sidewalk';
                    
                    if (isRoad || isSidewalk) {
                        // Create a location key based on the way's center point
                        const coords = element.geometry.map(node => [node.lat, node.lon]);
                        const centerLat = coords.reduce((sum, coord) => sum + coord[0], 0) / coords.length;
                        const centerLng = coords.reduce((sum, coord) => sum + coord[1], 0) / coords.length;
                        
                        // Group ways that are within 30m of each other (same street corridor)
                        const locationKey = `${Math.round(centerLat * 1000)},${Math.round(centerLng * 1000)}`;
                        
                        if (isSidewalk) {
                            if (!sidewalksByLocation.has(locationKey)) {
                                sidewalksByLocation.set(locationKey, []);
                            }
                            sidewalksByLocation.get(locationKey).push(element);
                        } else if (isRoad) {
                            if (!roadsByLocation.has(locationKey)) {
                                roadsByLocation.set(locationKey, []);
                            }
                            roadsByLocation.get(locationKey).push(element);
                        }
                    }
                }
            }
            
            // Create segment overlays
            let segmentCount = 0;
            let filteredCount = 0;
            const restrictedAreas = osmData.elements.filter(element => {
                const tags = element.tags || {};
                return tags.fee === 'yes' || tags.access === 'private' || tags.access === 'no' || 
                       tags.access === 'customers' || tags.landuse === 'military' || tags.dog === 'no' ||
                       tags.admission || (tags.leisure === 'garden' && tags.tourism) ||
                       (tags.tourism === 'attraction' && tags.leisure === 'garden') ||
                       (tags.name && tags.name.toLowerCase().includes('botanical')) ||
                       (tags.name && tags.name.toLowerCase().includes('vandusen')) ||
                       (tags.tourism === 'zoo') || (tags.tourism === 'museum') || (tags.tourism === 'theme_park');
            });
            
            // Process each way individually, but prioritize sidewalks over roads
            for (const element of osmData.elements) {
                try {
                    if (element.type === 'way' && element.geometry && element.geometry.length >= 2) {
                        const tags = element.tags || {};
                        
                        // Skip restricted elements
                        const isRestrictedElement = tags.fee === 'yes' || tags.access === 'private' || 
                                                  tags.access === 'no' || tags.access === 'customers' ||
                                                  tags.landuse === 'military' || tags.dog === 'no';
                        
                        if (isRestrictedElement) continue;
                        
                        // Skip paths near restricted areas
                        const isNearRestrictedArea = checkIfPathNearRestrictedAreas(element, restrictedAreas);
                        if (isNearRestrictedArea) continue;
                        
                        // Check if within radius
                        const coordinates = element.geometry.map(node => [node.lat, node.lon]);
                        const hasPointInRadius = coordinates.some(coord => {
                            const distance = calculateDistance(center.lat, center.lng, coord[0], coord[1]);
                            return distance <= radius;
                        });
                        
                        if (!hasPointInRadius) {
                            filteredCount++;
                            continue;
                        }
                        
                        // Categorize walkable ways
                        const isRoad = tags.highway && tags.highway.match(/^(primary|secondary|tertiary|residential|unclassified)$/);
                        const isSidewalk = tags.highway === 'footway' || tags.highway === 'sidewalk';
                        const isPath = tags.highway === 'path' || tags.highway === 'pedestrian';
                        const isPark = tags.leisure === 'park';
                        const isService = tags.highway === 'service'; // Add service roads
                        
                        if (!isRoad && !isSidewalk && !isPath && !isPark && !isService) continue;
                        
                        // Skip roads if there are sidewalks nearby
                        if (isRoad) {
                            const centerLat = coordinates.reduce((sum, coord) => sum + coord[0], 0) / coordinates.length;
                            const centerLng = coordinates.reduce((sum, coord) => sum + coord[1], 0) / coordinates.length;
                            const locationKey = `${Math.round(centerLat * 1000)},${Math.round(centerLng * 1000)}`;
                            
                            // Check nearby location keys for sidewalks
                            let hasSidewalkNearby = false;
                            for (let latOffset = -1; latOffset <= 1; latOffset++) {
                                for (let lngOffset = -1; lngOffset <= 1; lngOffset++) {
                                    const nearbyKey = `${Math.round(centerLat * 1000) + latOffset},${Math.round(centerLng * 1000) + lngOffset}`;
                                    if (sidewalksByLocation.has(nearbyKey)) {
                                        hasSidewalkNearby = true;
                                        break;
                                    }
                                }
                                if (hasSidewalkNearby) break;
                            }
                            
                            if (hasSidewalkNearby) {
                                console.log(`üö´ Skipping road ${tags.name || 'unnamed'} - sidewalk available`);
                                continue; // Skip this road, use the sidewalk instead
                            }
                        }
                        
                        // Split segments at intersections for visual appeal
                        const segmentChunks = splitAtIntersections(coordinates, intersections);
                        
                        // Further subdivide long segments (max 40m)
                        const finalSegments = [];
                        for (const chunk of segmentChunks) {
                            const subChunks = subdivideSegmentByDistance(chunk, 40);
                            finalSegments.push(...subChunks);
                        }
                        
                        // Create polylines for each segment
                        for (let chunkIndex = 0; chunkIndex < finalSegments.length; chunkIndex++) {
                            const chunkCoords = finalSegments[chunkIndex];
                            const segmentId = `segment_${element.id}_${chunkIndex}`;
                            
                            if (chunkCoords.length < 2) continue;
                            
                            // Calculate actual segment length
                            let segmentLength = 0;
                            for (let i = 1; i < chunkCoords.length; i++) {
                                segmentLength += calculateDistance(
                                    chunkCoords[i-1][0], chunkCoords[i-1][1],
                                    chunkCoords[i][0], chunkCoords[i][1]
                                );
                            }
                            
                            // Skip very short segments (less than 3m)
                            if (segmentLength < 3) continue;
                            
                            // Determine visual style
                            let color = '#94a3b8'; // Default gray (not walked)
                            let weight = 5; // Default weight
                            
                            if (isSidewalk || isRoad) {
                                weight = 7; // Thicker for main walkways
                            } else if (isPath || isPark) {
                                weight = 5; // Normal for paths/parks
                            } else if (isService) {
                                weight = 6; // Medium for service roads
                            }
                            
                            let opacity = 0.8;
                            
                            const walkData = walkedSegments.get(segmentId);
                            if (walkData && walkData.completed) {
                                // This segment has been completed
                                if (isSidewalk || isRoad || isService) {
                                    color = '#3b82f6'; // Blue for roads/sidewalks
                                } else if (isPath) {
                                    color = '#22c55e'; // Green for paths
                                } else if (isPark) {
                                    color = '#10b981'; // Emerald for parks
                                }
                                weight = weight + 2; // Even thicker when completed
                                opacity = 1.0;
                            }
                            
                            const polyline = L.polyline(chunkCoords, {
                                color: color,
                                weight: weight,
                                opacity: opacity,
                                lineJoin: 'round',
                                lineCap: 'round',
                                segmentId: segmentId,
                                segmentLength: segmentLength
                            });
                            
                            // Add click handler to mark as walked
                            polyline.on('click', () => {
                                markSegmentAsWalked(segmentId, polyline, tags);
                            });
                            
                            // Add tooltip
                            const wayType = isSidewalk ? 'sidewalk' : isRoad ? 'road' : isPath ? 'path' : isPark ? 'park' : isService ? 'service' : 'walkway';
                            const name = tags.name || wayType;
                            const lengthText = `${Math.round(segmentLength)}m`;
                            const walkInfo = walkData ? 
                                (walkData.completed ? ' (COMPLETED)' : ` (${Math.round(walkData.progress)}% walked)`) : 
                                ' (not walked)';
                            
                            polyline.bindTooltip(`${name} [${lengthText}]${walkInfo}`, {
                                sticky: true,
                                direction: 'top'
                            });
                            
                            polyline.addTo(map);
                            segmentLayers.push(polyline);
                            segmentCount++;
                        }
                    }
                } catch (segmentError) {
                    console.log(`Error processing segment ${element.id}:`, segmentError);
                }
            }
            
            console.log(`‚úÖ Rendered ${segmentCount} walkable segments within ${radius}m radius`);
            console.log(`üö´ Filtered out ${filteredCount} segments outside radius`);
            console.log(`üîÑ Found ${intersections.size} intersections for segment splitting`);
            console.log(`üö∂ Prioritized sidewalks over roads where available`);
            updateSegmentStats();
        }

        // Split segments at intersections for better visual appeal
        function splitAtIntersections(coordinates, intersections) {
            const segments = [];
            let currentSegment = [coordinates[0]];
            
            for (let i = 1; i < coordinates.length; i++) {
                const coord = coordinates[i];
                const nodeId = `${coord[0].toFixed(6)},${coord[1].toFixed(6)}`;
                
                currentSegment.push(coord);
                
                // If this is an intersection and we have a meaningful segment, split here
                if (intersections.has(nodeId) && currentSegment.length > 1) {
                    segments.push([...currentSegment]);
                    currentSegment = [coord]; // Start new segment with intersection point
                }
            }
            
            // Add the final segment if it has multiple points
            if (currentSegment.length > 1) {
                segments.push(currentSegment);
            }
            
            return segments.length > 0 ? segments : [coordinates];
        }

        // Subdivide segment by actual distance rather than coordinate count
        function subdivideSegmentByDistance(coordinates, maxDistanceMeters) {
            if (coordinates.length < 2) return [coordinates];
            
            const subSegments = [];
            let currentSegment = [coordinates[0]];
            let currentDistance = 0;
            
            for (let i = 1; i < coordinates.length; i++) {
                const prevPoint = coordinates[i - 1];
                const currentPoint = coordinates[i];
                
                // Calculate distance between consecutive points
                const stepDistance = calculateDistance(
                    prevPoint[0], prevPoint[1],
                    currentPoint[0], currentPoint[1]
                );
                
                currentDistance += stepDistance;
                currentSegment.push(currentPoint);
                
                // If we've exceeded max distance, start a new segment
                if (currentDistance >= maxDistanceMeters && currentSegment.length > 1) {
                    subSegments.push([...currentSegment]);
                    currentSegment = [currentPoint]; // Start new segment with this point
                    currentDistance = 0;
                }
            }
            
            // Add the final segment if it has multiple points
            if (currentSegment.length > 1) {
                subSegments.push(currentSegment);
            }
            
            return subSegments.length > 0 ? subSegments : [coordinates];
        }

        // Mark a segment as walked with persistence tracking
        function markSegmentAsWalked(segmentId, polyline, tags) {
            const walkData = walkedSegments.get(segmentId);
            
            if (walkData && walkData.completed) {
                // Unmark as walked
                walkedSegments.delete(segmentId);
                polyline.setStyle({
                    color: '#94a3b8', // Gray
                    weight: 6,
                    opacity: 0.8
                });
                console.log(`‚ùå Unmarked segment: ${tags.name || tags.highway || 'unnamed'}`);
            } else {
                // Mark as walked (manual click = instant completion)
                walkedSegments.set(segmentId, {
                    progress: 100,
                    completed: true,
                    touchPoints: [],
                    method: 'manual'
                });
                
                // Set color based on type
                let color = '#8b5cf6'; // Default purple
                if (tags.highway && tags.highway.match(/^(primary|secondary|tertiary|residential)/)) {
                    color = '#3b82f6'; // Blue for roads (includes sidewalks)
                } else if (tags.highway === 'footway' || tags.highway === 'path' || tags.highway === 'pedestrian') {
                    color = '#22c55e'; // Green for paths
                } else if (tags.leisure === 'park') {
                    color = '#10b981'; // Emerald for parks
                }
                
                polyline.setStyle({
                    color: color,
                    weight: 8,
                    opacity: 1.0
                });
                console.log(`‚úÖ Manually marked segment as completed: ${tags.name || tags.highway || 'unnamed'}`);
            }
            
            // Update tooltip
            const name = tags.name || tags.highway || 'Unnamed segment';
            const segmentLength = Math.round(polyline.options.segmentLength || 0);
            const walkInfo = walkedSegments.get(segmentId) ? ' (COMPLETED)' : ' (not walked)';
            polyline.setTooltipContent(`${name} [${segmentLength}m]${walkInfo}`);
            
            updateSegmentStats();
        }

        // Track GPS position along a segment for persistence
        function trackSegmentProgress(segmentId, polyline, userLat, userLng, tags) {
            const walkData = walkedSegments.get(segmentId) || {
                progress: 0, 
                completed: false, 
                touchPoints: [],
                method: 'gps'
            };
            
            if (walkData.completed) return; // Already completed
            
            const segmentLength = polyline.options.segmentLength || 0;
            const requiredDistance = Math.max(10, segmentLength * 0.10); // Need 10% of segment or minimum 10m
            
            // Add this GPS point to touch history
            walkData.touchPoints.push({lat: userLat, lng: userLng, timestamp: Date.now()});
            
            // Keep only recent touch points (last 30 seconds)
            const thirtySecondsAgo = Date.now() - 30000;
            walkData.touchPoints = walkData.touchPoints.filter(point => point.timestamp > thirtySecondsAgo);
            
            // Calculate total distance covered along this segment
            let totalDistance = 0;
            for (let i = 1; i < walkData.touchPoints.length; i++) {
                const prev = walkData.touchPoints[i-1];
                const curr = walkData.touchPoints[i];
                totalDistance += calculateDistance(prev.lat, prev.lng, curr.lat, curr.lng);
            }
            
            // Update progress
            walkData.progress = Math.min(100, (totalDistance / requiredDistance) * 100);
            
            // Check if segment is now completed
            if (walkData.progress >= 100 && !walkData.completed) {
                walkData.completed = true;
                
                // Update visual style to completed
                let color = '#22c55e'; // Default green for auto-completed
                if (tags.highway && tags.highway.match(/^(primary|secondary|tertiary|residential)/)) {
                    color = '#3b82f6'; // Blue for roads
                } else if (tags.leisure === 'park') {
                    color = '#10b981'; // Emerald for parks
                }
                
                polyline.setStyle({
                    color: color,
                    weight: 8,
                    opacity: 1.0
                });
                
                // Update tooltip
                const name = tags.name || tags.highway || 'Unnamed segment';
                const segmentLength = Math.round(polyline.options.segmentLength || 0);
                polyline.setTooltipContent(`${name} [${segmentLength}m] (COMPLETED)`);
                
                console.log(`üéâ Auto-completed segment: ${segmentId} (${Math.round(totalDistance)}m walked of ${Math.round(requiredDistance)}m required)`);
                updateSegmentStats();
            }
            
            walkedSegments.set(segmentId, walkData);
        }

        // Update segment statistics
        function updateSegmentStats() {
            const totalSegments = segmentLayers.length;
            const completedCount = Array.from(walkedSegments.values()).filter(data => data.completed).length;
            const inProgressCount = Array.from(walkedSegments.values()).filter(data => !data.completed && data.progress > 0).length;
            const percentage = totalSegments > 0 ? ((completedCount / totalSegments) * 100).toFixed(1) : 0;
            
            console.log(`üìä Segment Progress: ${completedCount}/${totalSegments} completed (${percentage}%), ${inProgressCount} in progress`);
            
            // Update UI if we have a stats div
            const statsDiv = document.querySelector('.stats');
            if (statsDiv && segmentMode) {
                statsDiv.innerHTML = `
                    <div><strong>Segment Coverage:</strong> ${completedCount}/${totalSegments} completed (${percentage}%)</div>
                    <div><strong>In Progress:</strong> ${inProgressCount} segments partially walked</div>
                    <div><strong>Mode:</strong> Individual 40m segments with persistence tracking</div>
                    <div><strong>Requirement:</strong> Walk 10% of segment length to complete</div>
                `;
            }
        }

        // Clear all segment overlays
        function clearSegmentOverlays() {
            segmentLayers.forEach(layer => {
                map.removeLayer(layer);
            });
            segmentLayers = [];
        }

        // Start the test walk simulation
        function startTestWalk() {
            if (isTestWalking) {
                // Stop current walk
                clearInterval(testWalkTimer);
                isTestWalking = false;
                testWalkIndex = 0;
                
                if (testWalkMarker) {
                    map.removeLayer(testWalkMarker);
                    testWalkMarker = null;
                }
                
                document.getElementById('testWalkBtn').textContent = 'Start Test Walk';
                document.getElementById('testWalkBtn').style.backgroundColor = '#22c55e';
                console.log('Test walk stopped');
                return;
            }
            
            // Start new walk
            testWalkPath = createTestWalkRoute();
            
            if (!testWalkPath || testWalkPath.length === 0) {
                console.log('No test route available');
                return;
            }
            
            isTestWalking = true;
            testWalkIndex = 0;
            
            document.getElementById('testWalkBtn').textContent = 'Stop Test Walk';
            document.getElementById('testWalkBtn').style.backgroundColor = '#ef4444';
            
            console.log(`Starting test walk with ${testWalkPath.length} waypoints`);
            
            // Start the walk animation
            testWalkTimer = setInterval(() => {
                if (testWalkIndex >= testWalkPath.length) {
                    // Walk completed
                    clearInterval(testWalkTimer);
                    isTestWalking = false;
                    document.getElementById('testWalkBtn').textContent = 'Start Test Walk';
                    document.getElementById('testWalkBtn').style.backgroundColor = '#22c55e';
                    console.log('Test walk completed!');
                    return;
                }
                
                const currentPos = testWalkPath[testWalkIndex];
                
                // Move or create the walker marker
                if (testWalkMarker) {
                    testWalkMarker.setLatLng(currentPos);
                } else {
                    testWalkMarker = L.marker(currentPos, {
                        icon: L.divIcon({
                            html: 'üö∂‚Äç‚ôÇÔ∏è',
                            className: 'test-walker',
                            iconSize: [20, 20],
                            iconAnchor: [10, 10]
                        })
                    });
                    testWalkMarker.addTo(map);
                }
                
                // Check for nearby segments and track progress (15m radius)
                const walkRadius = 15; // meters
                for (const layer of segmentLayers) {
                    const segmentCoords = layer.getLatLngs();
                    const segmentId = layer.options.segmentId;
                    
                    if (segmentId) {
                        // Check if any point in the segment is within walking radius
                        for (const coord of segmentCoords) {
                            const distance = calculateDistance(currentPos[0], currentPos[1], coord.lat, coord.lng);
                            if (distance <= walkRadius) {
                                // Track progress on this segment using persistence system
                                trackSegmentProgress(segmentId, layer, currentPos[0], currentPos[1], {});
                                break;
                            }
                        }
                    }
                }
                
                testWalkIndex++;
            }, 300); // Move every 300ms
        }

        // Create a test walk route that stays within the radius
        function createTestWalkRoute() {
            const center = map.getCenter();
            const bounds = map.getBounds();
            const radius = calculateRadius(bounds) * 0.8; // Use 80% of radius to stay well within bounds
            
            console.log(`Creating test walk route within ${radius}m of center`);
            
            // Create 15-20 waypoints in a semi-random pattern within the radius
            const route = [];
            const numWaypoints = 15 + Math.floor(Math.random() * 6); // 15-20 waypoints
            
            // Start near center
            route.push([center.lat, center.lng]);
            
            let currentLat = center.lat;
            let currentLng = center.lng;
            
            for (let i = 1; i < numWaypoints; i++) {
                // Generate next waypoint within reasonable distance but staying in radius
                const maxStepDistance = Math.min(radius * 0.2, 150); // Max 150m steps or 20% of radius
                const stepDistance = 50 + Math.random() * (maxStepDistance - 50); // 50m to maxStepDistance
                const direction = Math.random() * 2 * Math.PI; // Random direction
                
                // Calculate next position
                const deltaLat = (stepDistance * Math.cos(direction)) / 111000; // ~111km per degree lat
                const deltaLng = (stepDistance * Math.sin(direction)) / (111000 * Math.cos(currentLat * Math.PI / 180));
                
                let nextLat = currentLat + deltaLat;
                let nextLng = currentLng + deltaLng;
                
                // Check if next position is within radius from center
                const distanceFromCenter = calculateDistance(center.lat, center.lng, nextLat, nextLng);
                
                if (distanceFromCenter > radius) {
                    // If outside radius, adjust waypoint to be within radius
                    const angleToCenter = Math.atan2(center.lat - currentLat, center.lng - currentLng);
                    const maxDistanceFromCurrent = radius - calculateDistance(center.lat, center.lng, currentLat, currentLng);
                    const safeDistance = Math.min(stepDistance, maxDistanceFromCurrent * 0.8);
                    
                    // Move in a direction that keeps us within the radius
                    const adjustedDirection = angleToCenter + (Math.random() - 0.5) * Math.PI * 0.5; // ¬±45¬∞ from center direction
                    
                    const adjustedDeltaLat = (safeDistance * Math.cos(adjustedDirection)) / 111000;
                    const adjustedDeltaLng = (safeDistance * Math.sin(adjustedDirection)) / (111000 * Math.cos(currentLat * Math.PI / 180));
                    
                    nextLat = currentLat + adjustedDeltaLat;
                    nextLng = currentLng + adjustedDeltaLng;
                }
                
                route.push([nextLat, nextLng]);
                currentLat = nextLat;
                currentLng = nextLng;
            }
            
            // End back near center for a nice loop
            route.push([center.lat + (Math.random() - 0.5) * 0.001, center.lng + (Math.random() - 0.5) * 0.001]);
            
            console.log(`Generated test route with ${route.length} waypoints, staying within ${radius}m radius`);
            return route;
        }

        // Old test walking functions removed - now using improved radius-constrained version in startTestWalk()

        // Keyboard shortcuts for easier testing
        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'c') {
                clearGrid();
                e.preventDefault();
            }
            if (e.key.toLowerCase() === 'g') {
                generateGrid();
                e.preventDefault();
            }
            if (e.key.toLowerCase() === 'r') {
                toggleRawDataOverlay();
                e.preventDefault();
            }
            if (e.key.toLowerCase() === 'e') {
                toggleEnhancedDetection();
                e.preventDefault();
            }
        });

        // Initialize with default coordinates
        document.getElementById('latitude').value = defaultCoords.lat;
        document.getElementById('longitude').value = defaultCoords.lng;

        // Welcome message
        console.log('üó∫Ô∏è Walkable Areas Grid Test loaded');
        console.log('');
        console.log('üìã Instructions:');
        console.log('1. Enter your coordinates or click "Use My Location"');
        console.log('2. Click "Load Map" to visualize your area');
        console.log('3. Click "Generate Grid" to create the test grid');
        console.log('4. Click grid cells to cycle through: Unknown ‚Üí Walkable ‚Üí Non-walkable');
        console.log('');
        console.log('‚å®Ô∏è Keyboard shortcuts: C=clear, G=generate');
        console.log('');
        console.log('This test simulates how your dog walking app would analyze walkable areas!');
    </script>
</body>
</html> 